#+TITLE: Summary from An Introduction to Programming in Emacs Lisp by Robert J Chassel
#+AUTHOR: Agung Tuanany
#+EMAIL: agung.tuanany@gmail.com
#+SUBJECT: Emacs, Elisp
#+KEYWORDS: Emacs, Elisp
#+PROPERTY: header-args:emacs-lisp :tangle ./intro_to_programming_in_emacs_lisp-02.el :mkdirp yes
#+OPTIONS: toc:t
#+STARTUP: content indent
#+MACRO: export-date (eval (format-time-string "%F %R %z" (current-time)))
#+MACRO: count-words (eval (count-words (point-min) (point-max)))

#+LATEX_CLASS: org-plain-latex
#+LATEX_CLASS_OPTIONS: [letterpaper]
#+SETUPFILE: ./latex-standard-export.org

#+begin_comment
#+LATEX_CLASS: article

#+SETUPFILE: ~/.emacs.d/modules/prelude-latex.el
#+LATEX_HEADER: \input{latex-standard-setup.tex}
;;;
#+LATEX_HEADER: \input{jake-latex-standard.setup}
#+end_comment

#+STARTUP: latexpreview

+ Created: 2022-02-19
+ Updated: *{{{export-date}}}*.
+ Word count: *{{{count-words}}}* (not a measure of quality, just to offer an
  idea on what to expect)
+ Git repository (part of my dotfiles for GNU/Linux):
  <https://github.com/agungTuanany/intro_to_programming_in_elips.git>

* List Processing
- To the untutored eye, Lisp is a strange programming language.  In
  Lisp code there are /parentheses everywhere/.  Some people even
  claim that the name stand for "Lots of Isolated Silly Parentheses".
  But the claim is unwarratend.

- Lisp stand for Lost processing, and the programming language handle
  /list/ (and list of list) by putting them between parentheses.  The
  parentheses mark the boundaries of the list.  Sometimes a list is
  preceded by an apostrophe '~'~', called a /single-quote/ in Lisp.

- Lists are the basic of lisps.

  - [[Lisp List & Atom][Lisp Lists]]              What are lists?

  - [[Lisp List & Atom][Run A program]]           Any list in Lisp is a program ready to run

  - [[Run A program][Making Errors]]           Generating an error message

  - [[Symbol Names and Function Definition][Names & Definitions]]     Names of symbol and function definitions

  - [[The Lisp Interpreter][Lisp Interpreter]]        What the Lisp interpreter does

  - [[Evaluation][Evaluation]]              Running a program

  - [[Variables][Variables]]               Returning a value from a variable

  - [[Arguments][Arguments]]               Passing information to a function

  - [[Setting the Value of a Variable][set & setq]]              Setting the value of a variable

  - [[Summary][Summary]]                 The major points


** Lisp List & Atom
*** Vocabularies:

- <<<apostrophe>>> : a punctuation mark (') used to indicated either
  possession.

- <<<indivisible>>> : unable to be divided or separated.

- <<<fission>>> : the action of dividing or splitting something into
  two or more parts.

- <<<sloth>>> : laziness; reluctant to work an effort.

- <<<precedes>>> : come before (something) in time.

- <<<deciphering>>> : convert (a text written in code, or coded signal)
  into normal language; decode, translate

- <<<ceases>>> :bring or come to end

*** Notes

- A list in Lisp consist of parentheses surrounding atoms separated by
  whitespace or surrounding other lists or surrounding both atoms and
  other lists.

- An empty list is considered both an atom and a list at the same
  time.

- The printed representation of atoms and list are called /symbolic
  expressions/ or more concisely */s-expressions/*.

- In Lisp, certain kind of atom, such an /array/, can be separated
  into parts; but the mechanism for doing this is different from the
  mechanism for splitting a list.

- As far as a list operation are concerned, the atoms of list are
  unsplittable.

- In Lisp, all of the quoted text including the punctuation mark and
  the blanks spaces is a single atom.  This kind of atom is called a
  /string/ (for "string characters").  Strings are different kind of
  atom than numbers or symbols and are used differently.

- A command to properly indent the code in a region is customarily
  bound to /"M-c\"/.

*** Example

- ex-1:

  #+begin_src emacs-lisp
    ;; try to comment out
    (message '(rose
               violet
               daisy
               buttercup))
  #+end_src

- ex-2:

  #+begin_src emacs-lisp
    '(this list
           looks like this)
  #+end_src

Above list is same as this:

- ex-3:

  #+begin_src emacs-lisp
    '(this list looks like this)
  #+end_src

** Run A program

- A list in Lisp--any list-- is a program ready to run.

- If you run it (for which the Lisp jargon is */evaluate/*), the
  computer will do one of three things:

  -- Do nothing except return you the list itself,

  -- send you an error message,

  -- treat the first symbols in the list as a command to do
  something. (the last of these three things that you really want
  Lisp to expect).

- The single apostrophe, /( ' )/, that put in front of some of the example
  lists in preceding section is called a */quote/*; when it precedes a
  list, it tells Lisp to do nothing with the list, other than take it
  as it is written.  But if there is */no quote/* preceding a list,
  the first item of the list is special: it is a command for the
  computer to obey.

** Generate an Error Message

  #+CAPTION: Error Example
  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function this)
     (this is an unquoted list)
     eval((this is an unquoted list) nil)
     elisp--eval-last-sexp(nil)
     eval-last-sexp(nil)
     funcall-interactively(eval-last-sexp nil)
     call-interactively(eval-last-sexp nil nil)
     command-execute(eval-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
  #+end_src

- We often try o generate error message intentionally.

- We have a jargon, /error message can be informative/.  Instead being
  called /"error"/ messages, they should be called /"help"/ messages.

- deciphering an error mesasge can be hard, but once understood, they
  can be point the way.

- You read the */=*Backtrace*=/* buffer from the *bottom--up*; it
  tells you what Emacs did.
- When you type /C-x C-e/, you made an interactive call to the command
  /eval-last-sexp/.

- /eval/ is an abbrevation for /"evaluate"/ and /sexp/ is an
  abbrevation for /"symbolic expression"/.  The command means
  /"evaluate last symbolic expression"/, which is the expression just
  before your cursor.

- At the top of the =*Backtrace*= buffer, you see the line:

#+BEGIN_CENTER
\begin{verbatim}
        *Debugger entered--Lisp error: (void-function this)*
\end{verbatim}
#+END_CENTER

- The Lisp interpreter tried to evaluate the first atom of the list,
  the word 'this'. It is this action that generated the error message
  'void-function this'.

- The word /'function'/ was mentioned before. It was a very important
  word. For our purposes, we an define it by saying that a /function
  is a set of instructions to the computer that tell the computer to
  do something/.

- Now we can begin to understand the error message: 'void-function
  this'. The function (that is, the word 'this') does not have a
  definition of any set of instructions for the computer to carry out.

- The slightly odd word, *'void-function'*, is designed to cover the
  way Emacs Lisp is implemented, which is that when a symbol does not
  have a function definition attached to it, the place that should
  contain the instruction is void.

- It is possible to prevent Emacs entering the debugger in cases like
  above. We do not explain how to do that here, but we will mention
  what the result looks like, because you may encounter a similar
  situation if there is a bug in some Emacs code that you are using.

- In such cases, you will see only one line of error message; it will
  appear in the echo area and look like this:

#+BEGIN_CENTER
\begin{verbatim}
        Symbol's function definition is void: this
\end{verbatim}
#+END_CENTER

- The message goes away as soon as you type a key, even just to move the cursor.

- We know the meaning of the word 'Symbols'. It refers to the first
  atom of the list, the word 'this'.  The word 'function' refers to
  the instructions that tell the computer what to do. (Technically,
  the symbol tell the computer where to find the instructions, but
  this is a complication we can ignore at the moment.).

- The error message can be understood: 'Symbol's function definition
  is void: this'.  The symbol (that is, the word 'this') lacks
  instructions for the computer to carry out.

** Symbol Names and Function Definition

- In Lisp, one set of instructions can be attached to several
  names. For examples, the computer instructions for adding numbers
  can be linked to the symbol plus as well as the symbol =+= (and are
  in some dialects of Lisp).

- On other hand, a symbol can have only one function attached to it at
  a time. Otherwise, the computer would be confused as to which
  definition to use.

- However, the /function definition/ to which the name refers can be
  *changed* readily.

- Since Emacs Lisp is large, it is customary to name symbols in a way
  that identifies the part of Emacs to which the function belongs.

- Thus all the names for function that deal with /Textinfo/ start with
  /'textinfo-'/, and those for function to deal with /reading mail/
  start with /'mail'/.

** The Lisp Interpreter

- Based on what we have seen, we can now start to figure out what Lisp
  interpreter does when we command it to evaluate a list.

- First, it looks to see whether there is *a quote* before the list;
  /if there is/, the interpreter looks at the first element in the
  list the interpreter just gives us the list.

- Second, if there is *no qoute*, the interpreter looks at the first
  element in the list and sees whether it has a /function
  definition/. If it does, the interpreter carries out the instruction
  in the function definition. Otherwise, the interpreter print an
  error message.

  -- [[Complications][Complications]] Variables, Special forms, list within.

  -- [[Byte Compiling][Byte Compiling]] Special processing code for speed.

*** Complications

- For the *first* - complication, in addition to list, the Lisp
  interpreter can evaluate a symbol that is not quoted and does not
  have parentheses around it.  The Lisp interpreter will attempt to
  determine a symbol's value as */variable/*.  This situation is
  described in the section (see section "Variables")

- the *second* - complication occurs because some functions are
  unusual and do not work in the usual manner.  Those that don't are
  called */special forms/*.  They are used for special jobs, like
  defining a function, and there are not many of them.

- As well as special forms, there are also /"macros"/. A /macro/ is
  construct defined in Lisp, which differs from a function in that it
  translates a Lisp expression into another expression that is to be
  evaluated in place of the original expression (see section "Lisp
  Macro").

- For the purpose of this introduction, you do not need to worry too
  much about whether something is a /special form/, /macro/, or
  /ordinary function/.

- For example, /=if=/ is a special form, but /=when=/ is a macro. In
  earlier versions of Emacs, /=defun=/ was a special form, but it is a
  macro.  It still behave the same way.

- The *final* complication is, if the function that the Lisp
  interpreter is looking at is *not* a special form, and if it is part
  of a list, the Lisp interpreter looks to see whether the list has a
  list inside of it.  If there is an inner list, the Lisp interpreter
  first figures out what it should do with the inside list, and then
  it works on the outside list.  If there is yet another list embedded
  inside inner list, it works that one first, and so on.

- The interpreter works on the innermost list first, to evaluate the
  result of that list.  The result may be used by the enclosing expression.

- Otherwise, the interpreter works */left to right/*, from one
  expression to the next.

*** Byte Compiling

- One other aspect of interpreting: the Lisp interpreter is able to
  interpret two kind of entity: /humanly readable code/, which we will
  focus exclusively, and special processed code, called /byte
  compiled/ code, which is not human readable.  Byte compiled code
  runs faster than humanly readable code.

- You can transform humanly readable code into byte compiled code by
  running one of the compile commands such as *=byte-compile-file=*.
  Byte compiled code is usually in a file that ends with a /=.ec=/
  extension rather than a /=.el=/ extension.

- As practical matter, for most thing you might do to customize or
  extend Emacs, you do not need to byte compile; and I will not
  discuss the topic here. See Section "Byte Compilation" in the /GNU
  Emacs Lisp Reference Manual/, for full description of byte compilation.

** Evaluation

- When the Lisp interpreter works on an expression, the term for the
  activity is called */=evaluation=/*.  We say that the interpreter
  "evaluates the expression".  The word comes from its use in everyday
  language, "to ascertain the value or amount of; to appraise",
  according to /Webster's New Collegiate Dictionary/.

  -- [[How Interpreter acts][How Interpreter acts]]         Returns and Side Effects

  -- [[Evaluating Inner Lists][Evaluating Inner Lists]]       List within lists

*** How Interpreter acts

- After evaluating an expression, the Lisp interpreter will most
  likely return the value that the computer produces by carrying out
  the instructions it found in the /function definition/, or perhaps
  it will give up on that function and produce error message.  Most
  frequently, the interpreter returns a value.

- At the same time the interpreter returns a value, it may do
  something else as well, such as move a cursor or copy a file; this
  other kind of action is called a */side effect/*.  Actions that we
  humans think are important, such as /printing results/, are often
  side effects to the Lisp interpreter.  It fairly easy to learn to
  use side effect.

- In summary, evaluating a symbolic expression most commonly causes
  the Lisp interpreter to return a value and perhaps carry out a side
  effect; or else produce an error.

*** Evaluating Inner Lists

- If evaluation applies to a list that is inside another list, the
  outer list may use the value returned by evaluation as information
  when the outer list is evaluated.  This explains why inner
  expression evaluated first: the values they returns are *used* by
  the outer expressions.

** Variables

- In Emacs Lisp, a symbol can have a /value/ attached to it just as it
  can have a /function definition/ attached to it.  *The two are
  different*.

- The /function definition/ is a set of instruction that a computer will
  obey.

- A /value/, on the other hand, is something, such a number or a name,
  that can vary (which is why such a symbol is called a variable).
  The value of symbol can be any expression in Lisp, such as a symbol,
  number, list, or string.

- A symbol that has a value is often called /variable/.

- A symbol can have both a function definition and a value attached to
  it at the same time. Or it can have just one or the other.  The two
  are separate.

- Another way to think about this is to imagine a symbol as being a
  /chest of drawers/.  The function definition is in one drawer, the
  value in another, and so on.  What is put in the drawer holding the
  value can be changed without affecting the contents of the drawer
  holding the function definition, and vise versa.

*** ~fill-column~ an Example Variable

- The variable /=fill-column=/ illustrate a symbol with a value
  attached to it: in every GNU Emacs buffer, this symbol is set to
  some value.  To find out the value of this symbol, evaluate it by
  itself.

  #+begin_src emacs-lisp
    fill-column     ;; type (C-x C-e) to evaluate the value
  #+end_src

- Notice that the value returned as a variable is printed in exactly
  the same way returned by a function carrying out its instruction.

- From the point of view of the Lisp interpreter, /a value returned is
  a value returned/.  What kind of expression it came from ceases to
  matter once the value is known.

- A symbol can have any value attached to it or, to use the jargon, we
  can *bind the variable to a value*: to a /number/, such as =72=; to
  a /string/, *"=such as this="*; to a /list/, such as *=(spruce pine
  oak)=*; we can bind a variable to a /function definition/.

- A symbol can be bound to a value in several ways, See "Setting the
  Value of a Variable".

*** Error Message for a Symbol Without a Function

- When we evaluated *=fill-column=* to find its value as a variable,
  we did not place parentheses around the word.  This is because we
  did not intend to use it as a /function-name/.

- If *=fill-column=* were the first or only element of a list, the
  Lisp interpreter would attempt to find the function definition
  attached to it. But =fill-column= has no function definition.

  #+begin_src emacs-lisp
    (fill-column)     ;; type (C-x C-e) to evaluate the value
  #+end_src

- You will create a *=*Backtrace*=* buffer that says:

  #+BEGIN_CENTER
  \begin{verbatim}
          * ---------- Buffer: *Backtrace* ----------
          * Debugger entered--Lisp error: (void-function fill-column)
          *   (fill-column)
          *   eval((fill-column) nil)
          *   elisp--eval-last-sexp(nil)
          *   eval-last-sexp(nil)
          *   funcall-interactively(eval-last-sexp nil)
          *   call-interactively(eval-last-sexp nil nil)
          *   command-execute(eval-last-sexp)
          * ---------- Buffer: *Backtrace* ----------
  \end{verbatim}
  #+END_CENTER

*** Error Message for a Symbol without value

- If you attempt to evaluate a symbol that does not have a value bound
  to it, you will receive an error message. You can see this by
  experimenting with 2 plus 2 addition.  In the following expression,
  put your cursor right after the =+=, before first number 2, type /C-x C-e/:

  #+begin_src emacs-lisp
    (+ 2 2)     ;; type (C-x C-e) to evaluate the value
  #+end_src

- You will create a *=*Backtrace*=* buffer that says:

  #+BEGIN_CENTER
 \begin{verbatim}
          * Debugger entered--Lisp error: (void-variable +)
          *   eval(+ nil)
          *   elisp--eval-last-sexp(nil)
          *   eval-last-sexp(nil)
          *   funcall-interactively(eval-last-sexp nil)
          *   call-interactively(eval-last-sexp nil nil)
          *   command-execute(eval-last-sexp)
  \end{verbatim}
  #+END_CENTER

- This backtrace is different from the very first error message we
  saw, which said '~Debugger entered--Lisp error: (void-function
  this)~'.  In this case, the function does not have a value as a
  variable; while in the other error message, the function (the word
  'this') did not have a definition.

  In this experiment with the =+=, what we did was cause the Lisp
  interpreter to evaluate the =+= and look for the value right after
  the symbol rather than after the parenthesis of the enclosing list
  as we did before.  As a consequence, the Lisp interpreter evaluated
  the preceding /s-expression/ (symbol-expression), which in this case
  was =+= by itself.

  Since =+= does not have a value bound to it, just the function
  definition, the error message reported that the symbol's value as a
  variable was void.

** Arguments

- To see how information is passed to functions, let's look again at
  our old standby, the addition of two plus two.  In Lisp, this is
  written as follows:

  #+begin_src emacs-lisp
    (+ 2 2)
  #+end_src

- If you evaluate this expression, the number 4 will appear in your
  echo area.  What the Lisp interpreter does is add the numbers that
<<<<<<< HEAD
  follow the ~+~.

- The numbers added by ~+~ are called the /arguments/ of the function
  ~+~.  These numbers are the information that is given to or /passed/
  to the function.
=======
  follows the ~+~.
>>>>>>> 91c0ca6 (Fix subsubsequent on Chapter-1 (arguments))

- The word "argument" comes from the way it used in mathematics and
  *does not* refer to a disputation between two people; instead it
  refers to the information presented to the function, in this case,
  to the ~+~.

- In Lisp, the arguments to a function are the atoms or lists that
  follow the function.  The values returned by the evaluation of these
  atoms or lists are passed to the function.

- Different function require different numbers of arguments; some
  function require none at all.

<<<<<<< HEAD
  - [[Argument's Data Types][Data Types]]                          Types of data passed to a function

  - [[An Argument as the Value of a Variable or List][Args as Variable or List]]            An arguments can be the value of variable or list

  - [[Variable Number of Arguments][Variable Number of Arguments]]        Some functions may take a variable number of arguments

  - [[Using the Wrong Type Object as an Argument][Wrong Type of Argument]]              Passing an argument of the wrong type to a function

  - [[The ~message~ Function][message]]                    A useful function for sending message
=======
  - [[Argument's Data Types][Argument's Data Types]]          Types data passed to a function

  - [[An Argument as the Value of a Variable or List][Args as Variable or List]]       An Arguments can be the value of a variable or list

  - [[Variable Number of Arguments][Variable Number of Arguments]]    Some function may take a variable number of arguments

  - [[Wrong Type of Argument][Wrong Type of Argument]]          Passing an argument of the wrong type of function

  - [[The ~message~ Function][ message]]               A useful function for sending messages
>>>>>>> 91c0ca6 (Fix subsubsequent on Chapter-1 (arguments))

*** Argument's Data Types

- The type of data that should be passed to a function depends in what
  kind of information it uses.  The arguments to a function such as
  ~+~ must have values that are numbers, since ~+~ adds numbers.
  Other function use different kinds of data for their arguments.

- For example, the ~concat~ function links together or unites two or
  more strings of text to produce a string.  The arguments are
  strings.  Concatenating the two character string ~abc~, ~def~
  produces the single string ~abcdef~.  This can be evaluating the
  following:

  #+begin_src emacs-lisp
    (concat "abc" "def")
  #+end_src

  The value produced by evaluating this expression is ~"abcdef"~.

- A function such as ~substring~ uses both a string and numbers as
  arguments.  The function returns as part of the string, a
  /substring/ of the first argument.  This function /takes three
  arguments/.  Its first arguments is the string of characters, the
  second and third arguments are numbers that indicate the beginning
  (inclusive) and end (exclusive) of the substring.  The numbers are a
  count of the number of characters (including spaces and punctuation)
  from the beginning of the string.

- Note that the characters in a string are numbered from zero, not one.

- For example, if you evaluate the following:

  #+begin_src emacs-lisp
(substring "The quick brown fox jumped." 16 19)
  #+end_src

  you will see ~"fox"~ in the echo area.  The arguments are the string
  and the two numbers.

- Note that the string passed to ~subtring~ is a single atom even
  though it is made up of several words separated by spaces.  Lisp
  counts everything between the two quotation marks as a part of the
  string, including the spaces.

- You can think of the ~substring~ function as a kind of atom smasher
  since it takes an otherwise indivisible atoms and extract a part.
  However, ~substring~ is only able to extract a substring from an
  argument that is a string, not from another type of atom such a
  number or symbol.


*** An Argument as the Value of a Variable or List

- An arguments can be a symbol that returns a value when it is
  evaluated.  For example, when the symbol ~fill-column~ by itself is
  evaluated, it returns a number.  This number can be used in an
  addition.

  #+begin_src emacs-lisp
    fill-column         ; Default value is 70

    (+ 2 fill-column)   ; The value become 72

  #+end_src

  The value will be a number two more than what you get by evaluating
  ~fill-column~ alone. For me, this is 72, because my value of
  ~fill-column~ is 72.

- as we have just seen, an arguments can be a symbol that returns a
  value when evaluated.  In addition, an argument can be a list that
  returns a value when it is evaluated. For example, on the following
  expression, the arguments to the function ~concat~ are the strings
  ~"The "~ and ~" red foxes."~ and the list ~(number-to-string (+ 2
  fill-column))~.

  #+begin_src emacs-lisp
    (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
  #+end_src

  If you evaluate this expression--and if, as with Emacs,
  ~fill-column~ evaluates to *70--*~"The 72 red foxes."~ will appear in the echo area.

  - Note that you must put spaces after the word ~"The"~ and before the
   word ~'red'~ so they will appear in the final string.

  - The function ~number-to-string~ converts the integer that the
    addition function returns to a string.

  - ~number-to-string~ is also known as ~int-to-string~.

*** Variable Number of Arguments

- Some functions, such as ~concat~, ~+~, or ~*~, take any number of
  arguments. This can be seen by evaluating each of the following
  expressions in the usual way.  What you will see in the echo area is
  printed in this text after '~=~', which you may read as /"evaluates
  to"/.

- In the first set, the function have no argument:

  #+begin_src emacs-lisp
    (+)       ⇒ 0
    (*)       ⇒ 1
  #+end_src

- In this set, the function have one argument each:

  #+begin_src emacs-lisp
    (+ 3)       ⇒ 3
    (* 3)       ⇒ 3
  #+end_src

- In this set, the function have three arguments each:

  #+begin_src emacs-lisp
    (+ 3 4 5)       ⇒ 12
    (* 3 4 5)       ⇒ 60
  #+end_src

*** Using the Wrong Type Object as an Argument

- When a function is passed an argument of the wrong type, the Lisp
  interpreter produces an error message.  For example, the ~+~
  function expects the values of its arguments to be numbers.  As an
  experiment we can pass it the quoted symbol ~hello~ instead of a number.

  #+begin_src emacs-lisp
    (+ 2 'hello)
  #+end_src

- When you do this you will generate an error message.  What has
  happened is that ~+~ has tried to add the 2 to the value returned by
  ~'hello~, but the value returned by ~'hello~ is the symbol ~hello~,
  not a number.  Only number can be added.  So ~+~ could not carry out
  its addition.

  #+caption: Error Example
  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
    Debugger entered--Lisp error:
    (wrong-type-argument number-or-marker-p hello)
    +(2 hello)
    eval((+ 2 'hello) nil)
    elisp--eval-last-sexp(t)
    eval-last-sexp(nil)
    funcall-interactively(eval-print-last-sexp nil)
    call-interactively(eval-print-last-sexp nil nil)
    command-execute(eval-print-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
 #+end_src

- As usual, the error message tries to be helpful and makes sense
  after you learn how to read it. (~quote-hello)~ is an expansion of
  the abbreviation ~'hello~.

- The first part of the error message is straightforward; it says
  '~wrong-type-argument~'.  Next comes the mysterious jargon word
  '~number-marker-p~'.  This word is trying to tell you what kind of
  argument the ~+~ expected.

- The symbol ~number-or-maker-p~ says that the Lisp interpreter is
  trying to determine whether the information presented (the value of
  the argument) is a number or a marker (a special object representing
  a buffer position).  What it does is test to see whether the ~+~ is
  being given numbers to add.  It also tests to see whether the
  argument is something called a marker, which is a specific feature
  in Emacs Lisp.  In Emacs Lisp, ~+~ can be used to add the numeric
  value of marker position as numbers.

- The ~'p~ of ~number-or-maker-p~ is the embodiment of a practice
  started in the early days of Lisp programming.  The ~p~ stands for
  "*predicate*".

  In the jargon used by the early Lisp researchers a predicate refers
  to a function to determine whether some property is true or false.

  So the '~p~' tells us that ~number-or-marker-p~ is the name of a
  function that determines whether it is true or false that the
  argument supplied is a number or a marker.

  Other Lisp symbol that end in '~p~' include ~zerop~, a function test
  whether its argument has the value of zero; and ~listp~, a function
  that tests whether its argument is a list.

*** The ~message~ Function

- Like ~+~, the ~message~ function takes a variable numbers of
  arguments.  It used to send messages to the user and is so useful
  that we will describe it here.

- A message is printed in the echo area.  For example, you can print a
  message in your echo area by evaluating the following list:

  #+begin_src emacs-lisp
    (message "This message appears in the echo area!")
  #+end_src

- The whole string between double quotation marks is a /single
  argument/ and is printed in /toto/.

  Note that in this example, the message itself will appear in the
  echo area within double quotes; that is because you see the value
  returned by the ~message~ function.  In most uses of ~message~ in
  program that you write, the text will be printed in the echo area as
  a side-effect, without quotes.  See ~multiply-by-seven~ in detail,
  for an example of this.

- However, if there is a '~%s~' in the quoted string of characters,
  the ~message~ function does not print the '~%s~' as such, but looks
  to the argument that follows the string.  It evaluates the second
  argument and prints the value at the location in the string where
  the '~%s~ is.

  #+begin_src emacs-lisp
    (message "The name of this buffer is: %s." (buffer-name))
  #+end_src

- In info, ~"The name of this buffer is: *info*."~ will appear in the
  echo area.  The function ~buffer-name~ returns the name of the
  buffer as a string, which the ~message~ function insert in place of
  ~%s~.

- To print a value as an integer, use '~%d~' in the same way as
  '~%s~'.  For example, to print a message in the echo area that
  states the value of the ~fill-column~, evaluate the following:

  #+begin_src emacs-lisp
(message "The value of fill-column is %d." fill-column)
  #+end_src

- On my system, when I evaluate this list, ~"The value of fill-column
  is 70."~ appears in my echo area. (actually, you can use ~%s~ to
  print a number.  It is non-specific.  ~%d~ prints only the pat of a
  number left of a decimal point, and not anything that is not a
  number.)

- If there is more than one '~%s~' in the quoted string, the value of
  the first argument following the quoted string is printed at the
  location of the first '~%s~' and the value of the second argument is
  printed at the location of the second '~%s~', and so on.

  #+begin_src emacs-lisp
    (message "Tere are %d %s in the office!"
         (- fill-column 14) "pink elephants")
  #+end_src

  a rather whimsical message will appear in your echo area.  On my
  system it says, ~"there are 56 pink elephants in the office!"~.

- The expression ~(- fill-column 14)~ is evaluated and the resulting
  number is inserted in place of the '~%d~'; and the string in double
  quotes, ~"pink elephants"~, is treated as a single argument and
  inserted in place of the '~%s~'.  (That is to say, a string between
  double quotes evaluates itself, like a number.)

- Finally, here is somewhat complex example that not only illustrates
  the computation of a number, but also shows you how you can use an
  expression within an expression to generate the text that is
  substituted for '~%s~':

  #+begin_src emacs-lisp
    (message "He saw %d %s"
             (- fill-column 32)
             (concat "red "
                     (substring
                      "The quick brown foxes jumped." 16 21)
                     " leaping."))
  #+end_src

- In this example, ~message~ has three arguments: the string, ~"He saw
  %d %s"~, the expression, ~(- fill-column 32)~, and the expression
  beginning with the function ~concat~.  The value resulting from
  evaluation of ~(- fill-column 32)~ is inserted in place of the
  '~%d~', and the value returned by the expression beginning with
  ~concat~ is inserted in place of the '~%s~'.

- When your fill column is 70, and you evaluate the expression, hte
  message ~"He saw 38 red foxes leaping."~ appears in your echo area.

** Setting the Value of a Variable

- There are several ways by which a variable can be given a value. One
  of the ways is to use either the function ~set~, or the special form
  ~setq~.  Another way is to use ~let~.

- The jargon for this process is to /bind/ a variable to a value.

  - [[Using set][Using set]]                 Setting values.
  - [[Using ~setq~][Using ~setq~]]              Setting a quoted value.
  - [[Counting][Counting]]                  Using ~setq~ to count.

*** Using set

- To set the value of the symbol ~flowers~ to the list ~'(rose violet
  daisy buttercup)~, evaluate the following expression by positioning
  the cursor after the expression and typing ~C-x C-e~.

  #+begin_src emacs-lisp
    (set 'flowers '(rose violet daisy buttercup))
  #+end_src

- When you evaluate ~flowers~, the list ~(rose violet daisy
  buttercup)~ appears in the echo area.

- Incidentally, if you evaluate ~'flowers~, the variable with a quote in
  front of it, what you will see in the echo area is the symbol
  itself, ~flowers~.  Here is the quoted symbol, so you can try this:

  #+begin_src emacs-lisp
    'flowers
  #+end_src

- Note also, that when you use ~set~, you need to *quote both arguments*
  to ~set~.  Unless you want them evaluated.

- Since we do not want either argument evaluated, neither the variable
  ~flowers~ nor the list ~(rose violet daisy buttercup)~, both are
  quoted.

- When you use ~set~ *without quoting* it first argument, the first
  argument is evaluated before anything else is done.  If you did this
  and ~flowers~ did not have a value already, you would get an error
  message that the ~'Symbol's value as variable is void'~; on the
  other hand, if ~flowers~ did return a value after it was evaluated,
  the ~set~ would attempt to set value that was returned.  There are
  situations where this is the right thing for the function to do; but
  such situation are *rare*.

*** Using ~setq~

- As a practical matter, you almost always quote the first argument to
  ~set~.  The combination of ~set~ and a quoted first argument is /so
  common/ that is has its own name: the special form ~setq~.  This
  special form is just like ~set~ except that the first argument is
  *quoted automatically*, so you don't need to type the quote mark
  yourself.

- Also, as an added convenience, ~setq~ permits you to set several
  different variables to different values, all in one expression.

- To set the value of the variable ~carnivores~ to the list ~'(lion
  tiger leopard)~ using ~setq~, the following expression is used

  #+begin_src emacs-lisp
    (setq carnivores '(lion tiger leopard))
  #+end_src

- This is exactly the same as using ~set~ except the first argument is
  automatically quoted by ~setq~

- The '~q~' in ~setq~ means *quote*.

- With ~set~, the expression would look like this:

  #+begin_src emacs-lisp
    (set 'carnivores '(lion tiger leopard))
  #+end_src

- Also, ~setq~ can be used to assign /different values to different
  variables/.  The first argument is bound to the value of the second
  argument, the third argument is bound to the value of the forth
  argument, and so on.

- For example, you could use the following to assign a list of trees to
  the symbol ~trees~ and list of herbivores to the symbol ~herbivores~:

  #+begin_src emacs-lisp
    (setq trees '(pine fir oak maple)
          herbivores '(gazelle antelope zebra))
  #+end_src

- The expression could just as well been on one line, but it might not
  have fit on a page; and humans find it easier to read nicely
  formatted lists.

  Although I have been using the term "*assign*", there is another way
  of thinking about the workings of ~set~ and ~setq~; and that is to
  say that ~set~ and ~setq~ make the symbol /point/ to the list.  This
  latter way of thinking is very common and in forthcoming chapters we
  shall come upon at least one symbol that has "*pointer*" as part of
  its name.  The name is chosen because the symbol has a value,
  specifically a list, attached to it; or, expressed another way, the
  symbol is set to point to the list.

*** Counting

- Here is an example that show how to use ~setq~ in a counter. You might
  use this to count how many times a part of your program repeats
  itself.  First set a variable to zero; then add one to the number
  each time the program repeat itself.  To do this, you need a
  variable that serves as a counter, and two expression; an initial
  ~setq~ expression that sets the counter variable top zero; and a
  second ~setq~ expression that increment the counter each time it is
  evaluated.

  #+begin_src emacs-lisp
    (setq counter 0)              ;; let's call this initializer

    (setq counter (+ counter 1))  ;; This is the increment

    counter                       ;; This is the counter
  #+end_src

- If you evaluate the first of these expression, the initialize,
  ~(setq counter 0)~, and then evaluate the third expression,
  ~counter~, the number ~0~ will appear in the echo area.

  If you then evaluate the second expression, the incremented, ~(setq
  counter (+ counter 1))~, the counter will get the value of ~1~.

  So if you again evaluate ~counter~, the number ~1~ will appear in
  the echo area.

  Each time you evaluate the second expression, the value of the
  counter will be increased.

- When you evaluate the incrementer, ~(setq counter (+ counter 1))~, the
  Lisp interpreter first evaluates the innermost list; this is the
  addition.  In order to evaluates this list, it must evaluates the
  variable ~counter~ and the number ~1~.  When it evaluates the
  variables ~counter~, it receives its current values.  It passes this
  values and the number ~1~ to the ~+~ which adds them together.  The
  sum is then returned as the value of the inner list and passed to
  the ~setq~ which sets the variables ~counter~ to this new values.
  Thus, the value of the variable, ~counter~, is changed.

** Summary

Learning Lisp is like climbing a hill in which the first part is the
steepest.  You have now climbed the most difficult part; what remains
becomes easier as you progress inwards.

- Lisp programs are made up of /expression/, which are /lists/ or
  /single atoms/.

- List are made up of /zero/ or /more atoms/ or /inner list/,
  separated by whitespace and surround by parentheses.  A list can be
  empty.

- Atoms are /multi-character symbols/, like ~forward-paragraph~,
  /single character symbol/ like ~+~, /string of characters/ between
  double quotes marks, or numbers.

- A number evaluates to itself.

- A string between double quotes also evaluates itself.

- When you evaluate a symbol by itself, its value is returned.

- When you evaluate a list, the Lisp interpreter looks at the first
  symbol in the list and then at the function definition bound to that
  symbol.  Then the instruction in the function definition are carried
  out.

- A single-quote *~'~*, tells the Lisp interpreter that it should
  returns the following expression as written, and not evaluate it as
  it would if the quote were not there.

- Arguments are the information passed to a function.  The arguments
  to a function are computed by evaluating the rest of the elements of
  the list of which the function is the first elements.

- A function always returns a value when it is evaluated (unless it
  gets an error); in addition, it may also carry out some action that
  is a /side effect/.

- In many cases, *a function's primary purpose is to create a side effect*.


* Practicing Evaluation

- It is useful to spend a little time evaluating various expression that
  have already written.  Theses expression will be lists with the
  functions as their first (and often only) element.  Since some of the
  *functions associated with buffers* are both simple and interesting,
  we will start with those.

- In this section, we will evaluate a few of these. In another section,
  we will study the code of several other buffer-related function, to
  see how they were written.

 - [[How to Evaluate][How to Evaluate]]         Typing editing or ~C-x C-e~ causes evaluation

 - [[Buffer Names][Buffer Names]]            Buffers and files are different.

 - [[Getting Buffers][Getting Buffers]]         Getting a buffer itself, not merely its name.

 - [[Switching Buffers][Switching Buffers]]       How to change to another Buffer.

 - [[Buffer Size and the location of Point][Buffer Size & Location]]  Where point is located and the size of the buffer

** How to Evaluate

- /Whenever you give an editing command/ to Emacs Lisp, such as the
  command to move the cursor or to scroll the screen, you are
  /evaluating an expression/, he first element of which is a
  function. /This is how Emacs works/.

- When you type keys, you cause the Lisp interpreter to evaluate an
  expression and that is how you get your result.

- Even typing plain text involves evaluating an Emacs Lisp function, in
  this case, one that use ~self-inserted-command~, which simply inserts
  the character you typed.

- The functions you evaluate by typing keystrokes are called
  /interactive/ function, or /commands/; how you make a function
  interactive will be illustrated in the chapter on how to write
  function definitions.

- In addition to typing keyboard commands, we have seen a second way to
  evaluate an expression: by positioning the cursor after a list and
  typing ~C-x C-e~.  This is what we will do in the rest of this
  section.  There are other ways to evaluate an expression as well;
  these will be described as we come to them.

- Beside being used for practicing evaluation, the functions shown in
  the next few section are important in their own right.  A study of
  these functions makes clear the distinction between /buffers/ and
  /files/, how to switch to a buffer, and how to determine a location
  with it.

** Buffer Names

- The two function, ~buffer-name~ and ~buffer-file-name~, show the
  difference between a file and a buffer.  When you evaluate the
  following expression, ~(buffer-name)~, the name of the buffer appears
  in the echo area. When you evaluate ~(buffer-file-name)~, the name of
  the file which the buffer refers appears in the echo area.  Usually,
  the name returned by ~(buffer-name)~ is the same as the name of the
  file to which it refers, and the name returned by ~(buffer-file-name)~
  is the full path-name of the file.

- A file and a buffer are two different entities.  A file is
  information recorded permanently in the computer (unless you delete
  it).

- A buffer, on the other had, is information inside of Emacs that will
  vanish at the end of the editing session (or when you kill the
  buffer).

- Usually a buffer contains information that contains information that
  you have copied from a file; we say that buffer is /visiting/ that
  file.  This copy is what you work on and modify.  Changes to the
  buffer do not change the file, until you save the buffer.  When you
  save the buffer is copied to the file and is thus saved permanently.

  #+begin_src emacs-lisp
    (buffer-name)
    (buffer-file-name)
  #+end_src

- In spite of the distinction between files and buffers, you will often
  find that people refer to a file when they mean a buffer and vice
  versa.  Indeed most say "I am editing a file," rather than saying,
  "I am editing a buffer which I will soon save to a file".  It is
  almost always clear from context what people mean.

  When dealing with computer programs, however, it is important to
  keep the distinction in mind, since the computer is not as smart as
  a person.

- The word "buffer", by the way, comes from the meaning of the word as a
  cushion that deadens the force of a collision.  In early computers,
  a buffer cushioned the interaction between files and computers
  central processing unit.  The drums or tapes that held a file and
  the central processing unit were pieces of equipment that were very
  different from each other, working at their own speed, in spurts.
  The buffer made it possible for them to work together effectively.
  Eventually, the buffer grew from being an intermediary, a temporary
  holding place, to being the place where work is done.  this
  transformation is rather like that of a small seaport that grew into
  a great city; once it was merely the place where cargo was
  warehoused temporarily before being loaded onto ship; then it became
  a business and cultural center in its own right

- Not all buffers are associated with files. For example, a ~*scratch*~
  buffer does not visit any files.  Similarly, a ~*Help*~ buffer is
  not associated with any file.

- In the old days, when you lacked a ~~/.emacs~ file and started an
  Emacs session by typing the command ~emacs~ alone, without naming
  any files, Emacs started with the ~*scratch*~ buffer visible.
  Nowadays, you will see a splash screen.  You can follow one of the
  command suggested on the splash screen, visit a file, or press ~q~
  to quit the splash screen and reach the ~*scratch*~ buffer.

- If you switch to the ~*scratch*~ buffer, type ~(buffer-name)~,
  position the cursor after it, and then type ~C-x C-e~ to evaluate
  the expression. The name ~"*scratch*"~ will returned and will appear
  in echo area.  ~"*scratch*"~ is the name of the buffer.  When you
  type ~(buffer-file-name)~ in the ~*scratch*~ buffer and evaluate
  that, ~nil~ will appear in the echo area, just as it does when you
  evaluate ~(buffer-file-name)~ in Info.

- Incidentally, if you are in the ~*scratch*~ buffer and want the value
  returned by an expression to appear in the ~*scratch*~ buffer itself
  rather than in the echo area, type ~C-u C-x C-e~ instead of ~C-x
  C-e~.  This causes the value returned to appear after the
  expression. The buffer will look like this:

  #+begin_src emacs-lisp
  ;; in *scratch* buffer
    (buffer-name)"*scratch*"
  #+end_src

- You cannot do this in Info since Info is read-only, and it will not
  allow you to change the contents of the buffer.  But you can do this
  in any buffer you can edit; and when you write code for
  documentation (such as this book), this feature is useful.

** Getting Buffers

- The ~buffer-name~ function returns the /name/ of the buffer; to get
  the buffer /itself/, a different function is needed; the
  ~current-buffer~ function.  If you use this function in code, what
  you get is the buffer it self.

- A name and the object or entity to which the name refers are different
  from each other.  The name of the scratch buffer is ~*scratch*~, but
  the name is *not* the buffer.  To get a buffer itself, you need to
  use a function such as ~current-buffer~.

- However, there is a slight complication: if you evaluate
  ~current-buffer~ in an expression on its own, as we will do here,
  what you see is a printed representation of the name of the buffer
  without the contents of the buffer.  Emacs work this way for *two
  reason*:

  -- the buffer may be thousand of line log--too long to be
  conveniently displayed

  -- Another buffer may have the same contents but a different name,
  and it is important to distinguish between them.

- Here is an expression containing the function:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (current-buffer)
  #+end_src

- If you evaluate this expression in ~*scratch*~ buffer in the usual
  way, ~#<buffer *scratch*>~ will appear in the echo area.  The
  special format indicates the buffer itself is being returned, rather
  than just its name.

  Incidentally, while you can type a number or symbol into a program,
  you cannot do that with the printed representation of a buffer; the
  only way.

  A related function is ~other-buffer~.  This returns the most recently
  selected buffer other than one you are in currently, bit a printed
  representation of its name.  If you have recently switched back and
  forth from the ~*scratch*~ buffer, ~other-buffer~ will return that
  buffer.

  You can see this by evaluating the expression:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (other-buffer)
  #+end_src

You should see ~#<buffer *scratch*>~ appear in the echo area, or the
name of whatever other buffer you switched back from most recently.

** Switching Buffers

The ~other-buffer~ function actually provides a buffer when it us used
an argument to a function that requires one.  We can see this by using
~other-buffer- and ~switch-to-buffer~ to switch to a different buffer.

But first, a brief introduction to the ~switch-to-buffer~ function.
When you switched back and forth from Info to the ~*scratch*~ buffer
to evaluate ~(buffer-name)~, you most likely typed ~C-x b~ and then
typed ~*scratch*~ when prompted in the minibuffer for the name of the
buffer to which you wanted to switch.  The keystroke ~C-x b~, cause
the Lisp interpreter to evaluate the interactive function
~switch-to-buffer~.  As we said before, this is how Emacs works:
/different keystrokes call or run different function/.  For example,
~C-f~ calls ~forward-char~, ~M-e~ calls ~forward-sentence~, and so on.


By writing ~switch-to-buffer~ in an expression, and giving it a buffer
to switch to, we can switch buffers just the way ~C-x b~ does:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (switch-to-buffer (other-buffer))
  #+end_src

- The symbol ~switch-to-buffer~ is the first element of the list, so the
  Lisp interpreter will treat it as a function and carry out the
  instruction that are attached to it.  But before doing that, the
  interpreter will note that ~other-buffer- is inside parentheses and
  work on that symbol first.

  ~other-buffer- is the first (and in this case, the only) element of
  the list, so the Lisp interpreter calls or runs the function.  It
  returns another buffer.

  Next the interpreter runs ~switch-to-buffer~, passing to it, as an
  argument, the other buffer, which is what Emacs will switch to. If
  you are reading this in Info, try this now.  Evaluate the
  expression.

- In the programming examples in later section of this document, you
  will see the function ~set-buffer~ more often than
  ~switch-to-buffer~.  This because of a difference between computer
  program and humans: /Humans eyes and expect to see the buffer on
  which they are working on their computer terminals/.  This is so
  obvious, it almost goes without saying.  However program do not have
  eyes.  /When a computer program work on a buffer, that buffer does
  not have to be visible on the screen/.

- ~switch-to-buffer~ is designed for humans and does two different things:

  -- It switches the buffer to which Emacs's attention is directed;

  -- It switches the buffer in the window to the new buffer.

- ~set-buffer~ on other hand does only one thing:

  -- It switches the attention of the computer program to a different
  buffer.  The buffer on screen remain unchanged (of course, normally
  nothing happens there until the command finished running).

- Also, we have just introduced another jargon term, the word
  */call/*.  When you evaluate a list in which the first symbol is a
  function, you are calling that function.  The use of the term comes
  from the notion of the function as an entity that can do something
  for you if you call it--just a plumber is an entity who can fix a
  leak if you call him or her.

** Buffer Size and the location of Point

Finally, let's look at several rather simple function, ~buffer-size~,
~point~, ~point-min~, and ~point~max~.  These give information about
the size of a buffer and the location of point within it.

- The function ~buffer-size~ tells you the size of the current buffer,
  that is, the function returns a count of the number of characters in
  the buffer

  #+begin_src emacs-lisp
    (buffer-size)
  #+end_src

- In Emacs, the */current position of the cursor/* is called
  */point/*.  The expression ~(point)~ returns a number that tells you
  where the cursor is located as a count of the number of characters
  from the beginning of the buffer up to point.

  You can see character count for point in this buffer by evaluating
  the following expression in the usual way:

  #+begin_src emacs-lisp
    (buffer-size)49770 ; C-u C-x C-e
  #+end_src

  As I write this, the value of point is 49770. The ~point~ function is
  frequently used in some of the examples later in this book.

- The value of point depends, of course, on its location within the
  buffer. If you evaluate point in this spot, the number will be
  larger

  #+begin_src emacs-lisp
    (buffer-size)49775  ; C-u C-x C-e
  #+end_src

- For me, the value of point in this location is 49775, which means that
  there 49855 characters (including spaces) between the two
  expression. (Doubtles, you will see different numbers, since I will
  have edited this since I first evaluated point.

  #+begin_src emacs-lisp
    (point-min)1  ; C-u C-x C-e

    (point-max)50296  ; C-u C-x C-e
  #+end_src

- The function ~point-min~ is somewhat similar to ~point~, but it
  returns the value of the /minimum permissible/ value of point in the
  current buffer.  This is the number ~1~ unless /narrowing/ is in
  effect.  (Narrowing is a mechanism whereby you can restrict
  yourself, or a program, to operations on juts a part of a
  buffer. See Narrowing and Widening).

- Likewise, the function ~point-max~ returns the value of the maximum
  permissible value of point in the current buffer.


* How To Write Function Definition

- When the Lisp interpreter evaluates a list, it looks to see whether
  the first symbol on the list has a function definition attached to
  it; or, put another way, whether the symbol points to a function
  definition.  If it does, the computer carries out the instruction in
  the definition.  A symbol that has a function definition is called,
  simply, a function (although, properly speaking, the definition is
  the function and the symbol refers to it).

  - [[An Aside about Primitive Function][Primitive Function]]

  - [[~defun~ Makro][~defun~]]                     The ~defun~ macro.

  - [[Install A Function Definition][install]]                     Install a function definition.

  - [[Make a Function Interactive][Interactive]]                 Making a function interactive.

  - [[Different Options for interactive][Interactive Options]]         Different options for ~interactive~.

  - [[Install Code Permanently][Permanent Installation]]      Installing code permanently.

  - [[let][let]]                         Creating and initializing local variables.

  - [[The ~if~ Special Form][if]]                      What if?

  - [[If-then-else Expression][else]]                        if-then-else expression.

  - [[Truth & Falsehood in Emacs Lisp][Truth & Falsehood]]           What Lisp considered false and true.

  - [[~save-excursion~][~save-excursion~]]            Keeping track of point and buffer.

  - [[Review][Review]]

** An Aside about Primitive Function

- /All function are defined in terms of other functions/,*except* for
  a few */primitive/* functions that are written in the C programming
  language.

- When you write functions' definitions, you will write them in Emacs
  Lisp and use other functions as your building blocks.  Some of the
  function you will use will themselves be written in Emacs Lisp
  (perhaps by you) and some will be primitives written in C.

- When you write code in Emacs Lisp, you d not distinguish between the
  use of function written in C and the use of functions written in
  Emacs Lisp.  The difference is irrelevant.  I mention the
  distinction only because it is interesting to know.  Indeed, unless
  you investigate, you won't know whether an already-written function
  is written in Emacs Lisp or C.

** ~defun~ Makro

- In Lisp, a symbol such as ~mark-whole-buffer~ has code attached to
  it that tells the computer what to do when the function is called.
  This code is called the /function definition/ and is created by
  evaluating a Lisp expression that start with the symbol /defun/
  (which abbreviation for /define function/).

  In Subsequent sections, we will look at function definitions from
  the Emacs source code, such as ~mark-whole-buffer~.  In this
  section, we will describe a simple function definition so you can
  see how it looks.

  This function definition uses arithmetic because it makes for a
  simple example.  Some people dislike example using arithmetic;
  however, if you are such a person, do not despair.  Hardly any of
  the code we will study in the remainder of this introduction
  involves arithmetic or mathematics.  The examples mostly involve
  text in one way or another.

- A function definition has up to *five* parts following the word ~defun~:

  - The name of the symbol to which the function definition should be attached

  - A list of the /arguments/ that will be passed to the function.  If
    no arguments will be passed to the function, this is an empty list
    ~()~

  - Documentation describing the function. (Technically optional, but
    strongly recommended).

  - Optionally, an expression to make the function *interactive* so
    you can use it by typing ~M-x~ and then the name of the function;
    or by typing an appropriate key or key chord.

  - The code that instruct the computer what to do; the /body/ of the
    function definition.

- It is helpful to think of the /five parts/ of a function definition
  as being organized in a template, with slots for each part:

  #+begin_src emacs-lisp
    (defun function-name (arguments...)
      "optional-documentaion.."
      (interactive argument-passing-info)      ; optional
      body..)
  #+end_src

- As an example, here is the code for a function that multiplies its
  arguments by 7. (This example is *not interactive*)

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))
  #+end_src

  - The definition begin with a parenthesis and the symbol ~defun~,
    followed by the name of the function.

  - The name of the function is followed by a list that contains the
    arguments that will be passed to the function.  This list is
    called the /argument list/.  In this example, the list has only
    one element, the symbol, ~number~.  When the function is used, the
    symbol will be bound to the value that is used as argument to the
    function.

  - The argument list is followed by the documentation string that
    describes the function.  This is what you see when you type ~C-h
    f~ and the name of a function.  Incidentally, when you write a
    documentation string like this, you should make the first line a
    complete sentence since some commands, such /apropos/, print only
    the first line of a multi-line documentation string.  Also, you
    should not indent the second line of a documentation string, if
    you have one, because that looks odd when you use ~C-h f
    (describe-function)~.

  - The documentation string is optional, but it is so useful, it
    should be included in almost every function you write.

  - The third line of the example consist of the body of the function
    definition.  In this function, the body is the list, ~(* 7
    number)~, which says to multiply the value of /number/ by 7.

- When you use the ~multiply-by-seven~ function, the argument ~number~
  evaluates to the actual number you want used.  Here is an example
  that shows ~multiply-by-seven~ is used; but don't try to evaluate
  this yet!!.

  #+begin_src emacs-lisp
    (multiply-by-seven 3)
  #+end_src

  - The symbol ~number~, specified in the function in the next
    section, is bound to the value 3 in the actual use of the
    function.

  - Note that although ~number~ was inside parentheses in the function
    definition, the argument passed to the ~multiply-by-seven~ is not
    parentheses.  The parentheses are written in the function
    definition so the computer can figure out where argument list ends
    and the rest of the function definition begins.

- If you evaluate this example, you are likely to get an error
  message.  This is because we have written the function definition,
  but not yet told the computer about the definition--we have *not yet
  loaded the function definition in Emacs*.  Installing a function is
  the process that tells the Lisp interpreter the definition of the
  function.

** Install A Function Definition

- If you are reading this inside Info in Emacs, you can try out the
  ~multiply-by-seven~ function by first evaluating the function
  definition and then evaluating ~(multiply-by-seven 3)~.  A copy of
  the function definition follows.

- Place the cursor after the last parenthesis of the function
  definition and type ~C-x C-e~.  When you do this,
  ~multiply-by-seven~ will appear in the echo area.  (What this means
  is that when a function definition is evaluated, the value it
  returns is the name of the defined function).  At the same time,
  this action installs the function definition.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))
  #+end_src

- By evaluating this ~defun~, you have just *installed*
  ~multiply-by-seven~ in Emacs.  The function is now just as much as
  part of Emacs as ~forward-word~ or any other editing function you
  use.

- ~multiply-by-seven~ will stay installed until you quit Emacs.  To
  reload code automatically whenever you start Emacs, see Installing
  Code Permanently.

  -- [[The effect of installation][Effect of installation]]

  -- [[Change a Function Definition][Change a defun]]             How to change a function definition

*** The effect of installation

- You can see the effect of installing ~multiply-by-seven~ by evaluating
  the following sample.  Place the cursor after the following expression
  and the ~C-x C-e~.  The number 21 will appear in the echo area.

  #+begin_src emacs-lisp
    (multiply-by-seven 3)
  #+end_src

- If you wish, you can read the documentation for the function by
  typing ~C-h f (describe-function)~ and then the name of the
  function, ~multiply-by-seven~.  When you do this, a ~*Help*~ window
  will appear on your screen that says

  #+begin_src emacs-lisp
  multiply-by-seven is a Lisp function.

  (multiply-by-seven NUMBER)

  Multiply NUMBER by seven.
  #+end_src

*** Change a Function Definition

- If you want to change the code in ~multiply-by-seven~, just rewrite
  it.  To install the new version in place of the old one, evaluate
  the function definition again.  This is how you modify code in
  Emacs.  It is very simple.

- As an example, you can change the ~multiply-by-seven~ function to
  add the number to itself seven times instead of multiplying the
  number by seven.  It produces the same answer, but by a different
  path.  At the same time, we will add comment to the code; a comment
  is text that Lisp interpreter ignores, but that a human reader may
  find useful or enlightening.

- The comment is that this is the second version.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)         ; Second version
      "Multiply NUMBER by seven."
      (+ number number number number number number number))
  #+end_src

- The comment follows a semicolon '~;~'.  In Lisp, everything on a
  line that follows a semicolon is a comment.  The end of the line is
  the end of the comment.  To stretch a comment or two or more lines,
  begin each lines with a semicolon.

- See Beginning a .emacs File, and Comments in The GNU Emacs Lisp
  Reference Manual, for more about comments.

- You can install the version of the ~multiply-by-seven~ function by
  evaluating it in the same way you evaluated the first function:
  place the cursor after the last parenthesis and type ~C-x C-e~.

- In summary, this is how you write code in Emacs Lisp: you write a
  function; install it; test it; and then make fixes or enhancements
  and install it again.

** Make a Function Interactive

- You make a function interactive by placing a list that begins with the
  special form ~interactive~ immediately after the documentation.  A
  user can invoke an interactive function by typing ~M-x~ and then the
  name of the function; or by typing the keys to which it is bound;
  for example, by typing ~C-n~ for ~next-line~ or ~C-x h~ for
  ~mark-whole-buffer~.

- Interestingly, when you call an interactive function interactively,
  the value returned is not automatically displayed in the echo area.
  This is because you often call an interactive function for its side
  effects, such as moving forward by a word or line, and /not for the
  value returned/.  If the returned value were displayed in the echo
  area each time you typed a key, it would be very distracting.


  -- [[An Interactive multiply-by-seven, An Overview][ An Interactive multiply-by-seven]]       An overview

  -- [[An Interactive ~multiply-by-seven~][multiply-by-seven in detail]]             The interactive version

*** An Interactive multiply-by-seven, An Overview

- Both the use of the special form ~interactive~ and one way to display
  a value in the echo area can be illustrated by creating an interactive
  version of ~multiply-by-seven~.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)           ; Interactive version
      "Multiply NUMBER by seven."
      (interactive "p")
      (message "the result is %d" (* 7 number)))
  #+end_src

- You can install this code by placing your cursor after it and typing
  ~C-x C-e~. The name of the function will appear in your echo area.
  Then, you can use this code by typing ~C-u~ and a number and then
  typing ~M-x multiply-by-seven~ and pressing ~RET~.  The phrase '~The
  result is ...~' followed by the product will appear in the echo
  area.

- Speaking more generally, you invoke a function like this in either
  of two ways:

  1. By typing a prefix argument that contains the number to be
     passed, and then typing ~M-x~ and the name of the function, as
     which "~C-u 3 M-x forward-sentence~"; or,

  2. By typing whatever key or key chord the function is bound to,
     with ~C-u 3 M-e~.

  - Both the examples just mentioned work identically to move point
    forward three sentences. (Since ~multiply-by-seven~ is not bound
    to any key, it could not be used as an example of key binding.).

- A /prefix argument/ is passed to an interactive function by typing
  the ~META~ key followed by a number, for example, ~M-3 M-e~, or by
  typing ~C-u~ and then a number, for example, ~C-u 3 M-e~ (if you
  type ~C-u~ without a number, it defaults to 4).

*** An Interactive ~multiply-by-seven~

- Let's look at the use of the special from ~interactive~ and then at
  the function ~message~ in the interactive version of
  ~multiply-by-seven~.  You will recall that the function definition looks like this:

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)           ; Interactive version
      "Multiply NUMBER by seven."
      (interactive "p")
      (message "The result is %d" (* 7 number)))
  #+end_src

- In this function, the expression, ~(interactive "p")~, is a list of
  two elements.  The ~"p"~ tells Emacs to pass the prefix argument to
  the function and use its value for the argument of the function.

- The argument will be a number.  This means that the symbol ~number~
  will be bound to a number in the line:

  #+begin_src emacs-lisp
    (message "The result is %d" (* 7 number))
  #+end_src

- For example, if you prefix argument is 5, the Lisp interpreter will
  evaluate the line as if it were:

  #+begin_src emacs-lisp
    (message "The result is %d" (* 7 5))
  #+end_src

- (If you are reading this in GNU Emacs, you can evaluate this
  expression yourself). First, the interpreter will evaluate the inner
  list, which ~(* 7 5)~.  This returns a value of 35.  Next, it will
  evaluate the outer list, passing the values of the second and
  subsequent elements of the list to the function ~message~.

- As we have seen, ~message~ in Emacs Lisp function especially
  designed for sending a one line message to a user.  In summary, the
  ~message~ function prints its first argument in the echo area as is,
  except for occurrences of '~%d~' and '~%s~' (and various other
  %-sequences which we have not mentioned).  When it sees a control
  sequence, the function looks to the second or subsequent arguments
  and prints the value of the argument in the location in the string
  where the control sequence is located.

- In the interactive ~multiply-by-seven~ function, the control string
  is '~%d~', which requires a number, and the value returned by
  evaluating ~(* 7 5)~ is the number 35.  Consequently, the number 35
  is printed in place of the '~%d~' and the message is '~The result is
  35~'.

- Note that when you call the function ~multiply-by-seven~, the
  message is printed without quotes, but when you call ~message~, the
  text is printed in double quotes.  This is because the value
  returned by ~message~ is what appears in the echo area when you
  evaluate an expression whose first element is ~message~; but when
  you embedded in a function, ~message~ prints the text as a /side
  effect/ without quotes.

** Different  Options for interactive

- In the example, ~multiply-by-seven~ used ~"p"~ as the argument to
  ~interactive~.  This argument told Emacs to interpret your typing
  either ~C-u~ followed by number or ~META~ followed by a number as a
  command to pass that number to the function argument.  Emacs has more
  that twenty characters predefined for use with ~interactive~.  In
  almost case, one of these options will enable you to pass the right
  information interactively to a function.  (See Code Characters for
  ~interactive~) in the GNU Emacs Lisp Reference Manual.)

- Consider the function ~zap-to-char~. Its interactive expression is

  #+begin_src emacs-lisp
    (interactive "p/ncZap to char: ")
  #+end_src

  - The first part of the argument to ~interactive~ is '~p~', with
    which you are already familiar.  This argument tells Emacs to
    interpret a prefix, as a number to be passed to a the function.
    You can specify a prefix either by typing ~C-u~ followed by a
    number or by typing ~META~ followed by a number.

  - The prefix is the number of specified characters.  Thus, if your
    prefix is three and the specified character is '~x~', then you
    will delete all the text up to and including the third next '~x~'.
    If you do not set a prefix, then you delete all the text up to an
    including the specified character, but no more.

  - The '~c~' tells the function the name of the character to which to
    delete.

  - More formally, a function with two or more arguments can have
    information passed to each argument by adding parts to the string
    that follows ~interactive~.  When you do this, the information is
    passed to each arguments in the same order it is specified in the
    ~interactive~ list.  In the string, each part is separated from
    the next part by a '~\n~', which is a newline.  For example, you
    can follow '~p~' with a '~/n~' and an '~cZap to char: ~'. This
    causes Emacs to pass the value of the prefix argument (if there is
    one) and the character.

  - In this case, the function definition looks like the following,
    where ~arg~ and ~char~ are the symbol to which ~interactive~ binds
    the prefix argument and the specified character:

    #+begin_src emacs-lisp
      (defun name-of-function (arg char)
        "Documentation..."
        (interactive "p/ncZap to char: ")
        body-of-function...)
    #+end_src

  - (The space after the colon in the prompt makes it look better when
    you are prompted. See The Definition of ~copy-to-buffer~, for an
    example)

  - When a function does not take arguments, ~interactive~ does not
    require any.  Such a function contains the simple expression
    ~(interactive)~.  The ~mark-whole-buffer~ function is like this.

  - Alternatively, if the special letter-codes are not right for your
    application, you can pass your own arguments to ~interactive~ as a list.

  - See The Definition of ~append-to-buffer~, for an example.  See
    Using Interactive in The GNU Emacs Lisp Reference Manual, for a
    more explanation about this technique.

** Install Code Permanently

- When you install a function definition by evaluating it, it will
  stay installed until you quit Emacs.  The next time you start a new
  session of Emacs, the function will not be installed unless you
  evaluate the function definition again.

- At some point, you may want to have code installed automatically
  whenever you start a new session of Emacs.  There are several ways
  of doing this:

  * If you have code that is just for yourself, you can put the code
    for the function definition in your ~.emacs~ initialization file.
    When you start Emacs, your ~.emacs~ file is automatically
    evaluated and all the function definition within it are
    installed. See Your ~.emacs~ File.

  * Alternatively, you can put the function definitions that you want
    installed in one or more files of their own and use the ~load~
    function to cause Emacs to evaluate and thereby install each of
    the function in this files.  See Loading Files.

  * Thirdly, if you have code that your whole site will use, it is
    usual to put it in a file called ~site-init.el~ that is loaded
    when Emacs is built.  This makes the code available to everyone
    who use your machine.  (See the ~INSTALL~ file that is part of the
    Emacs distribution.)

- Finally, if you have a code that everyone who use Emacs may want,
  you can post it on a computer network or send a copy to Free
  Software Foundation.  (When you do this, please license the code and
  its documentation under a license that permit other people to run,
  copy, study, modify, and redistribute the code and which protects
  you from having your work taken from you.)

- If you send a copy of your code to the Free Software Foundation, and
  properly protect yourself and others, it may be included in the next
  release of Emacs. In large part, this is how Emacs has grown over
  the past years, by donations.

** let

- The ~let~ expression is a special form in Lisp that you will need to
  use in most function definitions.

- ~let~ is used to attach or bind a symbol to a value in such a way
  the Lisp interpreter will not confuse the variable with a variable
  of the same name that is not part of the function.

- To understand why the ~let~ special form is necessary, consider the
  situation in which you own a home that you generally refer to as
  "the house", as in the sentence, "The house needs painting."  If you
  are visiting a friend and your host refer to "the house", he is
  likely to be referring to /his/ house, not yours, that is, to a
  different house.

- If your friend is referring to his house and you think he is
  referring to your house, you may be in for some confusion.  The same
  thing could happen in Lisp if a variable that is used inside of one
  function has the same name as a variable that is used of another
  function, and the two are not intended to refer to the same value.
  The ~let~ special form prevents this kind of confusion.

  -- [[~let~ Prevent confusion][Prevent confusion]]

  -- [[The Parts of a ~let~ Expression][Parts of let Expression]]

  -- [[Sample ~let~ Expression][Sample let Expression]]

  -- [[Uninitialized Variables in a ~let~ Statement][Initialized let Variables]]

*** ~let~ Prevent confusion

- The ~let~ special form prevent confusion. ~let~ creates a name for a
  /local variable/ that overshadows any use of the same name outside
  the ~let~ expression.  This is like understanding that whenever your
  host refers to "the house", he means his house, not yours.  (Symbol
  used in argument list work the same way. See The ~defun~ Macro).

- Local variables created by ~let~ expression retain their value
  /only/ within the ~let~ expression itself (and within expression
  called within the ~let~ expression); the local variables have no
  effect outside the ~let~ expression.

- Another way to think about ~let~ is that it is like a ~setq~ that is
  temporary and local.  The value set by ~let~ are automatically
  undone when the ~let~ is finished.  The setting only affects
  expressions that are inside the bounds of the ~let~ expression.

- In computer jargon, we would say the binding of a symbol is visible
  only in functions called in the ~let~ form; in Emacs Lisp, the
  default scoping is dynamic, not lexical. (The non-default lexical
  binding is not discussed in this manual.)

- ~let~ can create more than one variable at once.  Also, ~let~ gives
  each variable it creates an initial value, either a value specified
  by you, or ~nil~.  (In the jargon, this is binding the variable to
  the value.).

- After ~let~ has created and bound the variables, it /executes/ the
  code in the body of the ~let~, and returns the value of the last
  expression in the body, as the value of the whole ~let~ expression.

- "Execute", is a jargon term that means to evaluate a list; it comes
  from the use of the word meaning "to give practical effect to"
  (Oxford English Dictionary).  Since you evaluate an expression to
  perform an action, "execute" has evolved as a synonym to "evaluate".

*** The Parts of a ~let~ Expression

- A ~let~ expression is list of *three parts*.

  - The first part is the symbol ~let~,

  - The second part is a list, called a /varlist/, each element of
    which is either a symbol by itself or two-element list, the first
    element of which is a symbol.

  - The third part is the body of the ~let~.  The body usually
    consists of one or more lists.

- A template for a ~let~ expression looks like this:

  #+begin_src emacs-lisp
    (let varlist body...)
  #+end_src

- If the varlist is composed of two-element lists, as is often the
  case, the template for the ~let~ expression looks like this:

  #+begin_src emacs-lisp
    (let ((varlist value)
          (varlist value)
          ..)
      body...)
  #+end_src

*** Sample ~let~ Expression

- The following expression creates and gives initial value to the two
  variables ~zebra~ and ~tiger~.  The body of the ~let~ expression is
  a list which calls the ~message~ function.

  #+begin_src emacs-lisp
    (let ((zebra "stripes")
          (tiger "fierce"))
      (message "One kind of animal has %s and another is %s."
               zebra tiger))
  #+end_src

- Here, the varlist is ~(zebra "stripes") (tiger "fierce"))~.

- The two variables are ~zebra~ and ~tiger~.  Each variable is the
  first element of a two-element list and each value is the second
  element of its two-element list.

- In the varlist, Emacs binds the variable ~zebra~ to the value
  "~stripes~", and binds the variable ~tiger~ to the value "~fierce~".
  In this example, both values are strings.  The value could just as
  well have been another list or a symbol.

- The body of the ~let~ follows after the list holding the variables.
  In this example, the body is a list that uses the ~message~ function
  to print a string in the echo area.

- You many evaluate the example in the usual way, by placing the
  cursor after the last parenthesis and typing ~C-x C-e~.  When you do
  this, the following will appear in the echo area:

  #+begin_src emacs-lisp
    "One kind of animal has stripes and another is fierce"
  #+end_src

- As we have seen before, the ~message~ function prints its first
  argument, except for '~%s~'.  In this example, the value of the
  variable ~zebra~ is printed at the location of the first '~%s~' and
  the value of the variable ~tiger~ is printed at the location of the
  second '~%s~'.

*** Uninitialized Variables in a ~let~ Statement

- If you do not bind the variables in a ~let~ statement to specific
  initial values, they will automatically be bound to an initial value
  of ~nil~, as the following expression:

  #+begin_src emacs-lisp
    (let ((birch 3)
          pine
          fir
          (oak 'some))
      (message
       "Here are %d variables with %s, %s, and %s value."  birch
       pine fir oak))
  #+end_src

- Here, the varlist is ~(birch 3) pine fir (oak 'some))~.

- If you evaluate this expression in the usual way, the following will
  appear in your echo area:

  #+begin_src emacs-lisp
    "Here are 3 variabels with nil, nil, and some value."
  #+end_src

- In this example, Emacs binds the symbol ~birch~ to the number 3,
  binds the symbol ~pine~ and ~fir~ to ~nil~, and binds the symbol
  ~oak~ to the value ~some~.

- Note that in the first part of the ~let~, the variables ~pine~ and
  ~fir~ stand alone as atoms that are not surrounded by parentheses;
  this is because they are being bound to ~nil~, the empty list.  But
  ~oak~ is bound to ~some~ and so is a part of the list ~(oak 'some)~.
  Similarly, ~birch is bound to the number 3 and so is in a list with
  that number.  (Since a number evaluates to itself, the number does
  not need to be quoted.  Also, the number is printed in the message
  using a '~%d~' rather than a '~%s~'.) The four variables as a group
  into a list to delimit them from the body of the ~let~.

** The ~if~ Special Form

- Another special form is the condition ~if~.  This form is used to
  instruct the computer to make decisions.  You can write function
  definitions without using ~if~, but it is used often enough, and is
  important enough, to be included here.  It is used, for example, in
  the code for the function ~beginning-of-buffer~.

- The basic idea behind and ~if~, is that /if/ a test is *true*,
  /then/ an expression is *evaluated*.  If the test is *not true*, the
  expression is *not evaluated*.  For example, you might make a
  decision such as, "if it is warn and sunny, then go to the beach!"

  - [[~if~ in more detail][~if~ in more detail]]

  - [[The ~type-of-animal~ Function in Detail][~type-of-animal~ in detail]]     An example of an ~if~ expression.

*** ~if~ in more detail

- An ~if~ expression written in Lisp does not use the word "then"; the
  test and the action are the second and third elements of the list
  whose first element is ~if~.  Nonetheless, the test part of an ~if~
  expression is often called the /if-part/ and the second argument is
  often called the /then-part/.

- Also, when an ~if~ expression is written, the true-or-false is
  usually written on the same lines as the symbol ~if~, but the action
  to carry out if the test is true, the then-part, is written on the
  second and subsequent lines.  This makes the ~if~ expression is
  easier to read.

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-test-is-true)
  #+end_src

- The true-or-false test will be an expression that is evaluated by
  the Lisp interpreter.

- Here is an example that you can evaluate in the usual manner.  The
  test is whether the number 5 is greater than the number 4.  Since it
  is, the message "~5 is greater than 4!~' will be printed.

  #+begin_src emacs-lisp
    (if (> 5 4)                                 ; if-part
        (message "5 is greater than 4!"))       ; then-part
  #+end_src

  - The function ~>~ test whether its first argument is greater than
    its second argument and returns true if it is.

- Of course, in actual use, the test in an ~if~ expression will not be
  fixed for all time as it is by the expression ~(< 5 4)~.  Instead,
  at least one of the variables used in the test will be bound to a
  value that is not known ahead of time.  (If the value were known
  ahead of time, we would not need to run the test!)

- For example, the value may be bound to an argument of a function
  definition.  In the following function definition, the character of
  the animal is a value that is passed to the function. If the value
  bound to ~characteristic~ is "~fierce~", then the message, '~it is a
  tiger!~' will printed; otherwise, ~nil~ will be returned.

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)
      "Print message in echo area depending on CHARACTERISTIC.
        If the CHARACTERISTIC is the string \"fierce\",
    then warn of a tiger"
      (if (equal characteristic "fierce")
          (message "It is a tiger!")))
  #+end_src

- If you are reading this inside of GNU Emacs, you can evaluate the
  function definition in the usual way to install it in Emacs, and
  then you can evaluate the following two expression to see the
  results:

  #+begin_src emacs-lisp
    (type-of-animal "fierce")

    (type-of-animal "striped")
  #+end_src

- When you evaluate ~(type-of-animal "fierce")~, you will see the
  following message printed in the echo area: ~"it is a tiger!"~; and
  when you evalute ~(type-of-animal "stripe")~ you will see ~nil~
  printed in the echo area.

*** The ~type-of-animal~ Function in Detail

- Let's looks at the ~type-of-animal~ function in detail.

- The function definition for ~type-of-animal~ was written by filling
  the slots of two templates, one for a function definition as a
  whole, and a second for an ~if~ expression.

- The template for every function that is not /interactive/ is:

  #+begin_src emacs-lisp
    (defun name-of-function (argument-list)
      "documentation.."
      body..)
  #+end_src

- The part of the function that match this templates look like this:

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)
      "Print message in echo area depending on CHARACTERISTIC.
        If the CHARACTERISTIC is the string \"fierce\",
    then warn of a tiger."
      body: the if expression)
  #+end_src

- The name of function is ~type-of-animal~; it is passed the value of
  one argument.  The argument list is followed by a multi-line
  documentation string.  The documentation string is included in the
  example because it is a good habit to write documentation string for
  every function definition.  The body of the function definition
  consists of the if~ expression.

- The template for an ~if~ expression looks like this:

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-the-test-returns-true)
  #+end_src

- In the ~type-of-animal~ function, the code for the ~if~ looks like this:

  #+begin_src emacs-lisp
    (if (equal characteristic  "fierce")
        (message "It is a tiger!"))
  #+end_src

- Here, the true-or-false-test is the expression:

  #+begin_src emacs-lisp
    (equal characteristic "fierce")
  #+end_src

- In Lisp, ~equal~ is a function that determines whether its first
  argument is equal to its second argument.  The second argument is
  the string ~"fierce"~ and the first argument is the value of the
  symbol ~characteristic~--in other words, the argument passed to this
  function.

- In the first exercise of ~type-of-animal~, the argument ~"fierce"~
  is passed to ~type-of-animal~.  Since ~"fierce"~ is equal to
  ~"fierce"~, the expression, ~(equal characteristic "fierce")~,
  returns a value of /true/.  When this happens, the ~if~ evaluates
  the second argument or then-part of the ~if~: ~(message "It is a
  tiger!")~.

- On the other hand, in the second exercise of the ~type-of-animal~,
  the arguments ~"striped"~ is passed to
  ~type-of-animal"~. ~"striped"~ is not equal to ~"fierce"~, so the
  then-part is not evaluated and ~nil~ is returned by the ~if-
  expression.

** If-then-else Expression

- An ~if~ expression may have an optional third argument, called the
  /else-part/, for the case when the true-or-false-test returns false.
  When this happens, the second argument or then-part of the overall
  ~if~ expression is /not/ evaluated, but the third or else-part /is/
  evaluated.  You might think of this as cloudy day alternative for
  the decision "if it warn and sunny, then go to the beach, else read
  a book!".

- The word "else" is not written in the Lisp code; the else-part of an
  ~if~ expression comes after the then-part.  In the written Lisp, the
  else-part is usually written to start on a line of its own and is
  indented less than the then-part:

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-the-test-returns-true
      action-to-carry-out-if-the-test-returns-false)
  #+end_src

- For example, the following ~If~ expression prints the message ~"4
  not greater than 5!"~ when you evaluate it in the usual way:

  #+begin_src emacs-lisp
    (if (> 4 5)                                 ; if-part
        (message "4 falsely greater than 5!")   ; then-part
      (message "4 is not greater than 5!"))     ; else-part
  #+end_src

- Note that the /different levels of indentation/ make it easy to
  distinguish the then-part from the else-part.

- We can extend the ~type-of-animal~ function t include an else-part by
  simply incorporating an additional part of the ~if~ expression.

- You can see the consequences of doing this if you evaluate the
  following version of the ~type-animal- function to install it and
  then evaluate the two subsequent expression to pass different
  argument to the function.

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)              ; Second version
      "Print message in echo area depending on CHARACTERISTIC.
              If the CHARACTERISTIC is the string \"fierce\",
              then warn of a tiger; else say it is not fierce."
      (if (equal characteristic "fierce")
      (message "It is a tiger!")
      (message "It is not fierce!")))
  #+end_src

  #+begin_src emacs-lisp
    (type-of-animal "fierce")

    (type-of-animal "striped")
  #+end_src

- When you evaluate ~(type-of-animal "fierce")~, you will see the
  following message printed in the echo area: ~"It is a tiger!"~; but
  when you evaluate ~(type-of-animal "stripes")~, you will see ~"It is
  not fierce!"~.

- Of course, i the /characteristic/ were ~"ferocious"~, the message
  ~"It is not fierce!"~ would be printed; and it would be misleading!
  When you write code, you need to take into account the possibility
  that some such argument will be tested by the ~if~ and write your
  program accordingly

** Truth & Falsehood in Emacs Lisp

- There is an important aspect to the truth test in an ~if~
  expression.  So far, we have spoken if "true" and "false" as values
  of predicates as if they were new kinds of Emacs of Emacs Lisp
  objects.  In fact, "false" is just our old friend ~nil~.  Anything
  else--anything at all--is "true".

- The expression that test for truth is interpreted as /true/ if the
  result of evaluating it is a value that is not ~nil~.  In other
  words, the result of the test is considered true if the value
  returned is a /number/ such as 47, a /string/ such as ~"hello"~, or
  a /symbol/ (other than ~nil~) such as ~flowers~, or a /list/ (so
  long as it is not empty) or even a /buffer/!.

  - [[An explanation of ~nil~][nil explained]]        ~nil~ has two meaning

*** An explanation of ~nil~

- Before illustrating a test for truth, we need an explanation of
  ~nil~.

- In Emacs Lisp, the symbol ~nil~ has two meanings. First, it means
  the empty list.  Second, it means false and is the value returned
  when a true-or-false-test tests false.  ~nil~ can be written as an
  empty list, ~()~, or as ~nil~.  As far as the Lisp interpreter is
  concerned, ~()~ and ~nil~ are the same.  Humans, however, tend to
  use ~nil~ for false and ~()~ for the empty list,

- In the first example, the number 4 is evaluated as the test in the
  ~if~ expression and returns itself; consequently, the then-part of
  the expression is evaluated and returned: ~'true'~ appears in the
  echo area.  In the second example, the ~nil~ indicates false,
  consequently, the else-part of the expression is evaluated and
  returned: ~'false'~ appears in the echo area.

  #+begin_src emacs-lisp
    (if 4
        'true
      'false)

    (if nil
        'true
      'false)
  #+end_src

- Incidentally, if some other useful value is not available for a test
  that returns true, then the Lisp interpreter will return the symbol
  ~t~ for true.  For example, the expression ~(> 5 4)~ returns ~t~
  when evaluated, as you can see by evaluating it in the usual way:

  #+begin_src emacs-lisp
    (> 5 4)
  #+end_src

  on the other hand, this function ~nil~ if the else is false.

  #+begin_src emacs-lisp
    (> 4 5)
  #+end_src

** ~save-excursion~

- The ~save-excursion~ function is the final special form that we will
  discuss in this chapter.

- In Emacs Lisp programs used for editing, the ~save-excursion~
  function is very common.  It saves the location of point, executes
  the body of the function, and the restores point to its previous
  position if its location was changed.  It primary purpose is to keep
  the user being surprised and disturbed by unexpected movement of
  point.

  -- [[Point and Mark][Point and Mark]]

  -- [[Template for a ~save-excursion~ Expression][Template for ~save-excursion]]

*** Point and Mark

- Before discussing ~save-excursion~, however, it may be useful first
  to review what point and mark are in GNU Emacs.  /Point/ is the
  *current location of the cursor*.  Whenever the cursor is, that is
  point.  More precisely, on terminals where the cursor appears to be
  on top of a character, point is immediately before the character.
  In Emacs Lisp, point is an *integer*.  The first character in a
  buffer is number one, the second is number two, and so on.  The
  function ~point~ returns the current position of the cursor as a
  number.  Each buffer has its own value for point.

- The /mark/ is another position in the *buffer*; its value can be set
  with a command such as ~C-SPC (set-mark-command)~.  If a mark has
  been set, you can use the command ~C-x C-x
  (exchange-point-and-mark)~ to cause the cursor to jump to the mark
  and set the mark to be the previous position of point.  In addition,
  if you set another mark, the position of the previous mark is saved
  in the mark ring.  Many mark positions can be saved this way.  You
  can jump the cursor to a saved mark by typing ~(C-u C-SPC)~ one or
  more times.

- The part of the buffer between point and mark is called /the
  region/.  Numerous commands work on the region, including
  ~center-region~, ~count-lines-region~, ~kill-region~, and
  ~print-region~.

- The ~save-excursion~ special form saves the location point and
  restore this point and restore this position after the code within
  the body of the special form is evaluated by the Lisp interpreter.
  Thus if point were in the beginning of a piece of text and some code
  moved point to the he end of the buffer, the ~save-excursion~ would
  put point back to where it was before, after the expression in the
  body of the function were evaluated.

- In Emacs, a function frequently moves point as part of its internal
  workings even though a user would not expect this.  For example,
  ~count-lines-region~ moves point.  To prevent the user from being
  bothered by jumps that are both unexpected and (from the user's
  point of view) unnecessary, ~save-excursion~ is often used to keep
  point in the location expected by the user.  The use of
  ~save-excursion- is *good housekeeping*.

- To make sure the house stays clean, ~save-excursion~ restores the
  value of point even if something goes wrong in the code inside of it
  (or, to be more precise and to use the proper jargon, "in case of
  abnormal exit").  This is feature is very helpful.

- In addition to recording the value of point, ~save-excursion~ keeps
  track of the current buffer, and restore it, too.  This means you
  can write code that will change the buffer and have ~save-excursion~
  switch you back to the original buffer.  This is how
  ~save-excursion~ is used in ~append-to-buffer~.  (See The Definition
  of ~append-to-buffer~).

*** Template for a ~save-excursion~ Expression

- The template for a ~save-excursion~ is simple:

  #+begin_src emacs-lisp
    (save-excursion
      body...)
  #+end_src

- The body of the function is one or more expressions that will be
  evaluated in sequence by the Lisp interpreter.  If there is more
  than one expression in the body, the value of the last one will be
  returned as the value of the ~save-excursion~ function.  The order
  expressions in the body are evaluated only for their side effects;
  and ~save-excursion~ itself is used only for its side effect (which
  is restoring the position of point).

- In more detail, the template for a ~save-excursion~ expression looks like this:

  #+begin_src emacs-lisp
    (save-excursion
      first-expression-in-body
      secon-expression-in-body
      third-expression-in-body
      ...
      last-expression-in-body)
  #+end_src

- An expression, of course, may be a symbol on its own or a list.

- In Emacs Lisp code, a ~save-excursion~ expression often occurs
  within the body of a ~let~ expression. It looks like this:

  #+begin_src emacs-lisp
    (let varlist
      (save-excursion
        body..))
  #+end_src

** Review

- In the last few chapter we have introduced a macro and a fair number
  of function and special forms.  Here they are describe in brief,
  along with a few similar function that have not been mentioned yet.

- ~eval-last-sexp~

  Evaluates the last symbolic expression before the current location
  of point.  The value is printed in the echo area unless the function
  is invoked with an argument; in the case, the output is printed in
  the current buffer.  This command is normally bound to ~C-x C-e~.

- ~defun~

  Define function.  This macro has up to five parts: /the name/, /a
  template/ for arguments that will be passed to the function,
  /documentation/, an optional /interactive declaration/, and the
  /body/ of the definition.

  For example, in Emacs the function definition of
  ~dired-unmark-all-marks~ is as follows.

  #+begin_src emacs-lisp
    (defun dired-unmark-all-marks ()
      "Remove all marks from all files in the Dired buffer."
      (interactive)
      (dired-unmark-all-files ?\r))
  #+end_src

- ~interactive~

  Declare to the interpreter that the function can be used
  interactively.  This special form my be followed by a string with
  one or more parts that pass in the information to the arguments of
  the function, in sequence.  These parts may be also tell the
  interpreter to prompt for information.  Parts of the string are
  separated by newlines, ~'\n'~.

  Common code characters are:

  - ~b~

     The name of existing buffer

  - ~f~

     The name of existing file

  - ~p~

     The numeric prefix argument. (Note that this ~p~ is lower
    case.)

  - ~r~

    Point and the mark, as two arguments, smallest first.  This is
    the only code letter that specified two successive argument rather
    than one.

- ~let~

  Declare that a list of variables is for use within the body of the
  ~let~ and give them an initial value, either ~nil~ or a specified
  value; then evaluate the rest of the expression in the body of the
  ~let~ and return the value of the last one.  Inside the body of the
  ~let~, the Lisp interpreter does not see the values of the variables
  of the same names that are bound outside of the ~let~.

  For example,

  #+begin_src emacs-lisp
    (let ((foo (buffer-name))
          (bar (buffer-size)))
      (message
       "This buffer is %s and has %d characters."
       foo bar))
  #+end_src

- ~save-excursion~

  Record the values of point and the current buffer before evaluating
  the body of this special form.  Restore the value of point and
  buffer afterward.

  For example,

  #+begin_src emacs-lisp
    (message "We are %d characters into this buffer."
             (- (point)
                (save-excursion
                  (goto-char (point-min)) (point))))
  #+end_src

- ~if~

  Evaluate the first argument to the function; if is true, evaluate
  the second argument; else evaluate the third argument, if there is
  one.

  The ~if~ special form is called a /conditional/.  There are other
  conditional in Emacs Lisp, but ~if~ is perhaps the most commonly
  used.

  for example,

  #+begin_src emacs-lisp
    (if (= 27 emacs-major-version)
        (message "This is version 27 Emacs")
      (message "This is not version 27 Emacs"))
  #+end_src

- ~<~, ~>~, ~<=~, ~>=~

  The ~<~ function test whether its first argument is smaller than its
  second argument.  A corresponding function, ~>~, tests whether the
  first argument is greater than the second.  Likewise ~<=~ test
  whether the first argument is less than or equal to the second and
  ~>=~ test whether the first argument is greater than or equal to the
  second .  In all cases, both arguments must be /numbers/ or
  /markers/ (markers indicate position in buffers).

- ~=~

  The ~=~ function test whether two arguments, both numbers or
  markers, are equal.

- ~equal~, ~eq~

  Test whether two objects are the same. ~equal~ uses one meaning of
  the word "same" and ~eq~ uses another; ~equal~ returns true if the
  two objects have a similar structure and contents, such as two
  copies of the same book.  On the other hand, ~eq~, returns true if
  both arguments are actually the same /object/.

- ~string<~, ~string-lessp~, ~string=~, ~string-equal~

  The ~string-lessp~ function tests whether its first arguments is
  smaller than the second argument.  A shorter, alternative name for
  the same function (a ~defalias~) is ~string<~.

  The arguments to ~string-lessp~ must be /strings/ or /symbols/; the
  ordering is lexicographic, so case is significant.  The print names
  of symbols are used instead of the symbol themselves.

  An empty string, ~""~, a string with no characters in it, is smaller
  than any string of characters.

- ~message~

  Print a message in the echo area. The first argument is string that
  can contain '~%s~', '~$d~', or '~%c~' to print the value of
  arguments that follow the string.  The argument used by '~%s~' must
  be a string or a symbol; the argument '~%d~' must be a number.  The
  argument '~%c~' must be an ASCII code number; it will be printed as
  the character with that ASCII code.  (Various other %-sequence have
  not been mentioned.)

- ~setq~, ~set~

  The ~setq~ special form sets the value of its first argument to the
  value of the second argument.  The first argument is automatically
  quoted by ~setq~.  It does the same for succeeding pairs of
  arguments.  An other function, ~set~, takes only two arguments and
  evaluates both of them before setting the value returned by its
  first argument to the value returned by its second argument.

- ~buffer-name~

  Without an argument, return the name of the buffer, as a string.

- ~buffer-file-name~

  Without an argument, return the name of the buffer, as a string.

- ~current-buffer~

  Return the buffer in which Emacs is active; it may not the buffer is
  visible on the screen

- ~other-buffer~

  Return the most recently selected buffer (other than the buffer
  passed to ~other-buffer~ as an argument and other than the current
  buffer).

- ~switch-buffer~

  Select a buffer for Emacs to be active in and display in the current
  window so users can look at it.  Usually bound to ~C-x C-b~

- ~set-buffer~

  Switch Emacs's attention to a buffer on which programs will run.
  Don't alter what the window is showing.

- ~buffer-size~

  Return the number of character in the current buffer.

- ~point~

  Return the value of the current position of the cursor, as an
  integer counting the number of characters from the beginning of the
  buffer.

- ~point-min~

  Return the minimum permissible value of point in the current buffer.
  This is 1, unless narrowing is in effect.

- ~point-max~

  Return the value of the maximum permissible value of point in the
  current buffer.  This is the end of the buffer, unless narrowing is
  in effect.
