#+TITLE: Summary from An Introduction to Programming in Emacs Lisp by Robert J Chassel
#+AUTHOR: Agung Tuanany
#+EMAIL: agung.tuanany@gmail.com
#+SUBJECT: Emacs, Elisp
#+KEYWORDS: Emacs, Elisp
#+PROPERTY: header-args:emacs-lisp :tangle ./intro_to_programming_in_emacs_lisp-02.el :mkdirp yes
#+OPTIONS: toc:t
#+STARTUP: content indent
#+MACRO: export-date (eval (format-time-string "%F %R %z" (current-time)))
#+MACRO: count-words (eval (count-words (point-min) (point-max)))

#+LATEX_CLASS: org-plain-latex
#+LATEX_CLASS_OPTIONS: [letterpaper]
#+SETUPFILE: ./latex-standard-export.org

#+begin_comment
#+LATEX_CLASS: article

#+SETUPFILE: ~/.emacs.d/modules/prelude-latex.el
#+LATEX_HEADER: \input{latex-standard-setup.tex}
;;;
#+LATEX_HEADER: \input{jake-latex-standard.setup}
#+end_comment

#+STARTUP: latexpreview

+ Created: 2022-02-19
+ Updated: *{{{export-date}}}*.
+ Word count: *{{{count-words}}}* (not a measure of quality, just to offer an
  idea on what to expect)
+ Git repository (part of my dotfiles for GNU/Linux):
  <https://github.com/agungTuanany/intro_to_programming_in_elips.git>

* List Processing
- To the untutored eye, Lisp is a strange programming language.  In
  Lisp code there are /parentheses everywhere/.  Some people even
  claim that the name stand for "Lots of Isolated Silly Parentheses".
  But the claim is unwarratend.

- Lisp stand for Lost processing, and the programming language handle
  /list/ (and list of list) by putting them between parentheses.  The
  parentheses mark the boundaries of the list.  Sometimes a list is
  preceded by an apostrophe '~'~', called a /single-quote/ in Lisp.

- Lists are the basic of lisps.

  - [[Lisp List & Atom][Lisp Lists]]              What are lists?

  - [[Lisp List & Atom][Run A program]]           Any list in Lisp is a program ready to run

  - [[Run A program][Making Errors]]           Generating an error message

  - [[Symbol Names and Function Definition][Names & Definitions]]     Names of symbol and function definitions

  - [[The Lisp Interpreter][Lisp Interpreter]]        What the Lisp interpreter does

  - [[Evaluation][Evaluation]]              Running a program

  - [[Variables][Variables]]               Returning a value from a variable

  - [[Arguments][Arguments]]               Passing information to a function

  - [[Setting the Value of a Variable][set & setq]]              Setting the value of a variable

  - [[Summary][Summary]]                 The major points


** Lisp List & Atom
*** Vocabularies:

- <<<apostrophe>>> : a punctuation mark (') used to indicated either
  possession.

- <<<indivisible>>> : unable to be divided or separated.

- <<<fission>>> : the action of dividing or splitting something into
  two or more parts.

- <<<sloth>>> : laziness; reluctant to work an effort.

- <<<precedes>>> : come before (something) in time.

- <<<deciphering>>> : convert (a text written in code, or coded signal)
  into normal language; decode, translate

- <<<ceases>>> :bring or come to end

*** Notes

- A list in Lisp consist of parentheses surrounding atoms separated by
  whitespace or surrounding other lists or surrounding both atoms and
  other lists.

- An empty list is considered both an atom and a list at the same
  time.

- The printed representation of atoms and list are called /symbolic
  expressions/ or more concisely */s-expressions/*.

- In Lisp, certain kind of atom, such an /array/, can be separated
  into parts; but the mechanism for doing this is different from the
  mechanism for splitting a list.

- As far as a list operation are concerned, the atoms of list are
  unsplittable.

- In Lisp, all of the quoted text including the punctuation mark and
  the blanks spaces is a single atom.  This kind of atom is called a
  /string/ (for "string characters").  Strings are different kind of
  atom than numbers or symbols and are used differently.

- A command to properly indent the code in a region is customarily
  bound to /"M-c\"/.

*** Example

- ex-1:

  #+begin_src emacs-lisp
    ;; try to comment out
    (message '(rose
               violet
               daisy
               buttercup))
  #+end_src

- ex-2:

  #+begin_src emacs-lisp
    '(this list
           looks like this)
  #+end_src

Above list is same as this:

- ex-3:

  #+begin_src emacs-lisp
    '(this list looks like this)
  #+end_src

** Run A program

- A list in Lisp--any list-- is a program ready to run.

- If you run it (for which the Lisp jargon is */evaluate/*), the
  computer will do one of three things:

  -- Do nothing except return you the list itself,

  -- send you an error message,

  -- treat the first symbols in the list as a command to do
  something. (the last of these three things that you really want
  Lisp to expect).

- The single apostrophe, /( ' )/, that put in front of some of the example
  lists in preceding section is called a */quote/*; when it precedes a
  list, it tells Lisp to do nothing with the list, other than take it
  as it is written.  But if there is */no quote/* preceding a list,
  the first item of the list is special: it is a command for the
  computer to obey.

** Generate an Error Message

  #+CAPTION: Error Example
  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function this)
     (this is an unquoted list)
     eval((this is an unquoted list) nil)
     elisp--eval-last-sexp(nil)
     eval-last-sexp(nil)
     funcall-interactively(eval-last-sexp nil)
     call-interactively(eval-last-sexp nil nil)
     command-execute(eval-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
  #+end_src

- We often try o generate error message intentionally.

- We have a jargon, /error message can be informative/.  Instead being
  called /"error"/ messages, they should be called /"help"/ messages.

- deciphering an error mesasge can be hard, but once understood, they
  can be point the way.

- You read the */=*Backtrace*=/* buffer from the *bottom--up*; it
  tells you what Emacs did.
- When you type /C-x C-e/, you made an interactive call to the command
  /eval-last-sexp/.

- /eval/ is an abbrevation for /"evaluate"/ and /sexp/ is an
  abbrevation for /"symbolic expression"/.  The command means
  /"evaluate last symbolic expression"/, which is the expression just
  before your cursor.

- At the top of the =*Backtrace*= buffer, you see the line:

#+BEGIN_CENTER
\begin{verbatim}
        *Debugger entered--Lisp error: (void-function this)*
\end{verbatim}
#+END_CENTER

- The Lisp interpreter tried to evaluate the first atom of the list,
  the word 'this'. It is this action that generated the error message
  'void-function this'.

- The word /'function'/ was mentioned before. It was a very important
  word. For our purposes, we an define it by saying that a /function
  is a set of instructions to the computer that tell the computer to
  do something/.

- Now we can begin to understand the error message: 'void-function
  this'. The function (that is, the word 'this') does not have a
  definition of any set of instructions for the computer to carry out.

- The slightly odd word, *'void-function'*, is designed to cover the
  way Emacs Lisp is implemented, which is that when a symbol does not
  have a function definition attached to it, the place that should
  contain the instruction is void.

- It is possible to prevent Emacs entering the debugger in cases like
  above. We do not explain how to do that here, but we will mention
  what the result looks like, because you may encounter a similar
  situation if there is a bug in some Emacs code that you are using.

- In such cases, you will see only one line of error message; it will
  appear in the echo area and look like this:

#+BEGIN_CENTER
\begin{verbatim}
        Symbol's function definition is void: this
\end{verbatim}
#+END_CENTER

- The message goes away as soon as you type a key, even just to move the cursor.

- We know the meaning of the word 'Symbols'. It refers to the first
  atom of the list, the word 'this'.  The word 'function' refers to
  the instructions that tell the computer what to do. (Technically,
  the symbol tell the computer where to find the instructions, but
  this is a complication we can ignore at the moment.).

- The error message can be understood: 'Symbol's function definition
  is void: this'.  The symbol (that is, the word 'this') lacks
  instructions for the computer to carry out.

** Symbol Names and Function Definition

- In Lisp, one set of instructions can be attached to several
  names. For examples, the computer instructions for adding numbers
  can be linked to the symbol plus as well as the symbol =+= (and are
  in some dialects of Lisp).

- On other hand, a symbol can have only one function attached to it at
  a time. Otherwise, the computer would be confused as to which
  definition to use.

- However, the /function definition/ to which the name refers can be
  *changed* readily.

- Since Emacs Lisp is large, it is customary to name symbols in a way
  that identifies the part of Emacs to which the function belongs.

- Thus all the names for function that deal with /Textinfo/ start with
  /'textinfo-'/, and those for function to deal with /reading mail/
  start with /'mail'/.

** The Lisp Interpreter

- Based on what we have seen, we can now start to figure out what Lisp
  interpreter does when we command it to evaluate a list.

- First, it looks to see whether there is *a quote* before the list;
  /if there is/, the interpreter looks at the first element in the
  list the interpreter just gives us the list.

- Second, if there is *no qoute*, the interpreter looks at the first
  element in the list and sees whether it has a /function
  definition/. If it does, the interpreter carries out the instruction
  in the function definition. Otherwise, the interpreter print an
  error message.

  -- [[Complications][Complications]] Variables, Special forms, list within.

  -- [[Byte Compiling][Byte Compiling]] Special processing code for speed.

*** Complications

- For the *first* - complication, in addition to list, the Lisp
  interpreter can evaluate a symbol that is not quoted and does not
  have parentheses around it.  The Lisp interpreter will attempt to
  determine a symbol's value as */variable/*.  This situation is
  described in the section (see section "Variables")

- the *second* - complication occurs because some functions are
  unusual and do not work in the usual manner.  Those that don't are
  called */special forms/*.  They are used for special jobs, like
  defining a function, and there are not many of them.

- As well as special forms, there are also /"macros"/. A /macro/ is
  construct defined in Lisp, which differs from a function in that it
  translates a Lisp expression into another expression that is to be
  evaluated in place of the original expression (see section "Lisp
  Macro").

- For the purpose of this introduction, you do not need to worry too
  much about whether something is a /special form/, /macro/, or
  /ordinary function/.

- For example, /=if=/ is a special form, but /=when=/ is a macro. In
  earlier versions of Emacs, /=defun=/ was a special form, but it is a
  macro.  It still behave the same way.

- The *final* complication is, if the function that the Lisp
  interpreter is looking at is *not* a special form, and if it is part
  of a list, the Lisp interpreter looks to see whether the list has a
  list inside of it.  If there is an inner list, the Lisp interpreter
  first figures out what it should do with the inside list, and then
  it works on the outside list.  If there is yet another list embedded
  inside inner list, it works that one first, and so on.

- The interpreter works on the innermost list first, to evaluate the
  result of that list.  The result may be used by the enclosing expression.

- Otherwise, the interpreter works */left to right/*, from one
  expression to the next.

*** Byte Compiling

- One other aspect of interpreting: the Lisp interpreter is able to
  interpret two kind of entity: /humanly readable code/, which we will
  focus exclusively, and special processed code, called /byte
  compiled/ code, which is not human readable.  Byte compiled code
  runs faster than humanly readable code.

- You can transform humanly readable code into byte compiled code by
  running one of the compile commands such as *=byte-compile-file=*.
  Byte compiled code is usually in a file that ends with a /=.ec=/
  extension rather than a /=.el=/ extension.

- As practical matter, for most thing you might do to customize or
  extend Emacs, you do not need to byte compile; and I will not
  discuss the topic here. See Section "Byte Compilation" in the /GNU
  Emacs Lisp Reference Manual/, for full description of byte compilation.

** Evaluation

- When the Lisp interpreter works on an expression, the term for the
  activity is called */=evaluation=/*.  We say that the interpreter
  "evaluates the expression".  The word comes from its use in everyday
  language, "to ascertain the value or amount of; to appraise",
  according to /Webster's New Collegiate Dictionary/.

  -- [[How Interpreter acts][How Interpreter acts]]         Returns and Side Effects

  -- [[Evaluating Inner Lists][Evaluating Inner Lists]]       List within lists

*** How Interpreter acts

- After evaluating an expression, the Lisp interpreter will most
  likely return the value that the computer produces by carrying out
  the instructions it found in the /function definition/, or perhaps
  it will give up on that function and produce error message.  Most
  frequently, the interpreter returns a value.

- At the same time the interpreter returns a value, it may do
  something else as well, such as move a cursor or copy a file; this
  other kind of action is called a */side effect/*.  Actions that we
  humans think are important, such as /printing results/, are often
  side effects to the Lisp interpreter.  It fairly easy to learn to
  use side effect.

- In summary, evaluating a symbolic expression most commonly causes
  the Lisp interpreter to return a value and perhaps carry out a side
  effect; or else produce an error.

*** Evaluating Inner Lists

- If evaluation applies to a list that is inside another list, the
  outer list may use the value returned by evaluation as information
  when the outer list is evaluated.  This explains why inner
  expression evaluated first: the values they returns are *used* by
  the outer expressions.

** Variables

- In Emacs Lisp, a symbol can have a /value/ attached to it just as it
  can have a /function definition/ attached to it.  *The two are
  different*.

- The /function definition/ is a set of instruction that a computer will
  obey.

- A /value/, on the other hand, is something, such a number or a name,
  that can vary (which is why such a symbol is called a variable).
  The value of symbol can be any expression in Lisp, such as a symbol,
  number, list, or string.

- A symbol that has a value is often called /variable/.

- A symbol can have both a function definition and a value attached to
  it at the same time. Or it can have just one or the other.  The two
  are separate.

- Another way to think about this is to imagine a symbol as being a
  /chest of drawers/.  The function definition is in one drawer, the
  value in another, and so on.  What is put in the drawer holding the
  value can be changed without affecting the contents of the drawer
  holding the function definition, and vise versa.

*** ~fill-column~ an Example Variable

- The variable /=fill-column=/ illustrate a symbol with a value
  attached to it: in every GNU Emacs buffer, this symbol is set to
  some value.  To find out the value of this symbol, evaluate it by
  itself.

  #+begin_src emacs-lisp
    fill-column     ;; type (C-x C-e) to evaluate the value
  #+end_src

- Notice that the value returned as a variable is printed in exactly
  the same way returned by a function carrying out its instruction.

- From the point of view of the Lisp interpreter, /a value returned is
  a value returned/.  What kind of expression it came from ceases to
  matter once the value is known.

- A symbol can have any value attached to it or, to use the jargon, we
  can *bind the variable to a value*: to a /number/, such as =72=; to
  a /string/, *"=such as this="*; to a /list/, such as *=(spruce pine
  oak)=*; we can bind a variable to a /function definition/.

- A symbol can be bound to a value in several ways, See "Setting the
  Value of a Variable".

*** Error Message for a Symbol Without a Function

- When we evaluated *=fill-column=* to find its value as a variable,
  we did not place parentheses around the word.  This is because we
  did not intend to use it as a /function-name/.

- If *=fill-column=* were the first or only element of a list, the
  Lisp interpreter would attempt to find the function definition
  attached to it. But =fill-column= has no function definition.

  #+begin_src emacs-lisp
    (fill-column)     ;; type (C-x C-e) to evaluate the value
  #+end_src

- You will create a *=*Backtrace*=* buffer that says:

  #+BEGIN_CENTER
  \begin{verbatim}
          * ---------- Buffer: *Backtrace* ----------
          * Debugger entered--Lisp error: (void-function fill-column)
          *   (fill-column)
          *   eval((fill-column) nil)
          *   elisp--eval-last-sexp(nil)
          *   eval-last-sexp(nil)
          *   funcall-interactively(eval-last-sexp nil)
          *   call-interactively(eval-last-sexp nil nil)
          *   command-execute(eval-last-sexp)
          * ---------- Buffer: *Backtrace* ----------
  \end{verbatim}
  #+END_CENTER

*** Error Message for a Symbol without value

- If you attempt to evaluate a symbol that does not have a value bound
  to it, you will receive an error message. You can see this by
  experimenting with 2 plus 2 addition.  In the following expression,
  put your cursor right after the =+=, before first number 2, type /C-x C-e/:

  #+begin_src emacs-lisp
    (+ 2 2)     ;; type (C-x C-e) to evaluate the value
  #+end_src

- You will create a *=*Backtrace*=* buffer that says:

  #+BEGIN_CENTER
 \begin{verbatim}
          * Debugger entered--Lisp error: (void-variable +)
          *   eval(+ nil)
          *   elisp--eval-last-sexp(nil)
          *   eval-last-sexp(nil)
          *   funcall-interactively(eval-last-sexp nil)
          *   call-interactively(eval-last-sexp nil nil)
          *   command-execute(eval-last-sexp)
  \end{verbatim}
  #+END_CENTER

- This backtrace is different from the very first error message we
  saw, which said '~Debugger entered--Lisp error: (void-function
  this)~'.  In this case, the function does not have a value as a
  variable; while in the other error message, the function (the word
  'this') did not have a definition.

  In this experiment with the =+=, what we did was cause the Lisp
  interpreter to evaluate the =+= and look for the value right after
  the symbol rather than after the parenthesis of the enclosing list
  as we did before.  As a consequence, the Lisp interpreter evaluated
  the preceding /s-expression/ (symbol-expression), which in this case
  was =+= by itself.

  Since =+= does not have a value bound to it, just the function
  definition, the error message reported that the symbol's value as a
  variable was void.

** Arguments

- To see how information is passed to functions, let's look again at
  our old standby, the addition of two plus two.  In Lisp, this is
  written as follows:

  #+begin_src emacs-lisp
    (+ 2 2)
  #+end_src

- If you evaluate this expression, the number 4 will appear in your
  echo area.  What the Lisp interpreter does is add the numbers that
  follow the ~+~.

- The numbers added by ~+~ are called the /arguments/ of the function
  ~+~.  These numbers are the information that is given to or /passed/
  to the function.
  follows the ~+~.

- The word "argument" comes from the way it used in mathematics and
  *does not* refer to a disputation between two people; instead it
  refers to the information presented to the function, in this case,
  to the ~+~.

- In Lisp, the arguments to a function are the atoms or lists that
  follow the function.  The values returned by the evaluation of these
  atoms or lists are passed to the function.

- Different function require different numbers of arguments; some
  function require none at all.

  - [[Argument's Data Types][Data Types]]                          Types of data passed to a function

  - [[An Argument as the Value of a Variable or List][Args as Variable or List]]            An arguments can be the value of variable or list

  - [[Variable Number of Arguments][Variable Number of Arguments]]        Some functions may take a variable number of arguments

  - [[Using the Wrong Type Object as an Argument][Wrong Type of Argument]]              Passing an argument of the wrong type to a function

  - [[The ~message~ Function][message]]                    A useful function for sending message

  - [[Argument's Data Types][Argument's Data Types]]               Types data passed to a function


*** Argument's Data Types

- The type of data that should be passed to a function depends in what
  kind of information it uses.  The arguments to a function such as
  ~+~ must have values that are numbers, since ~+~ adds numbers.
  Other function use different kinds of data for their arguments.

- For example, the ~concat~ function links together or unites two or
  more strings of text to produce a string.  The arguments are
  strings.  Concatenating the two character string ~abc~, ~def~
  produces the single string ~abcdef~.  This can be evaluating the
  following:

  #+begin_src emacs-lisp
    (concat "abc" "def")
  #+end_src

  The value produced by evaluating this expression is ~"abcdef"~.

- A function such as ~substring~ uses both a string and numbers as
  arguments.  The function returns as part of the string, a
  /substring/ of the first argument.  This function /takes three
  arguments/.  Its first arguments is the string of characters, the
  second and third arguments are numbers that indicate the beginning
  (inclusive) and end (exclusive) of the substring.  The numbers are a
  count of the number of characters (including spaces and punctuation)
  from the beginning of the string.

- Note that the characters in a string are numbered from zero, not one.

- For example, if you evaluate the following:

  #+begin_src emacs-lisp
(substring "The quick brown fox jumped." 16 19)
  #+end_src

  you will see ~"fox"~ in the echo area.  The arguments are the string
  and the two numbers.

- Note that the string passed to ~subtring~ is a single atom even
  though it is made up of several words separated by spaces.  Lisp
  counts everything between the two quotation marks as a part of the
  string, including the spaces.

- You can think of the ~substring~ function as a kind of atom smasher
  since it takes an otherwise indivisible atoms and extract a part.
  However, ~substring~ is only able to extract a substring from an
  argument that is a string, not from another type of atom such a
  number or symbol.


*** An Argument as the Value of a Variable or List

- An arguments can be a symbol that returns a value when it is
  evaluated.  For example, when the symbol ~fill-column~ by itself is
  evaluated, it returns a number.  This number can be used in an
  addition.

  #+begin_src emacs-lisp
    fill-column         ; Default value is 70

    (+ 2 fill-column)   ; The value become 72

  #+end_src

  The value will be a number two more than what you get by evaluating
  ~fill-column~ alone. For me, this is 72, because my value of
  ~fill-column~ is 72.

- as we have just seen, an arguments can be a symbol that returns a
  value when evaluated.  In addition, an argument can be a list that
  returns a value when it is evaluated. For example, on the following
  expression, the arguments to the function ~concat~ are the strings
  ~"The "~ and ~" red foxes."~ and the list ~(number-to-string (+ 2
  fill-column))~.

  #+begin_src emacs-lisp
    (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
  #+end_src

  If you evaluate this expression--and if, as with Emacs,
  ~fill-column~ evaluates to *70--*~"The 72 red foxes."~ will appear in the echo area.

  - Note that you must put spaces after the word ~"The"~ and before the
   word ~'red'~ so they will appear in the final string.

  - The function ~number-to-string~ converts the integer that the
    addition function returns to a string.

  - ~number-to-string~ is also known as ~int-to-string~.

*** Variable Number of Arguments

- Some functions, such as ~concat~, ~+~, or ~*~, take any number of
  arguments. This can be seen by evaluating each of the following
  expressions in the usual way.  What you will see in the echo area is
  printed in this text after '~=~', which you may read as /"evaluates
  to"/.

- In the first set, the function have no argument:

  #+begin_src emacs-lisp
    (+)       ⇒ 0
    (*)       ⇒ 1
  #+end_src

- In this set, the function have one argument each:

  #+begin_src emacs-lisp
    (+ 3)       ⇒ 3
    (* 3)       ⇒ 3
  #+end_src

- In this set, the function have three arguments each:

  #+begin_src emacs-lisp
    (+ 3 4 5)       ⇒ 12
    (* 3 4 5)       ⇒ 60
  #+end_src

*** Using the Wrong Type Object as an Argument

- When a function is passed an argument of the wrong type, the Lisp
  interpreter produces an error message.  For example, the ~+~
  function expects the values of its arguments to be numbers.  As an
  experiment we can pass it the quoted symbol ~hello~ instead of a number.

  #+begin_src emacs-lisp
    (+ 2 'hello)
  #+end_src

- When you do this you will generate an error message.  What has
  happened is that ~+~ has tried to add the 2 to the value returned by
  ~'hello~, but the value returned by ~'hello~ is the symbol ~hello~,
  not a number.  Only number can be added.  So ~+~ could not carry out
  its addition.

  #+caption: Error Example
  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
    Debugger entered--Lisp error:
    (wrong-type-argument number-or-marker-p hello)
    +(2 hello)
    eval((+ 2 'hello) nil)
    elisp--eval-last-sexp(t)
    eval-last-sexp(nil)
    funcall-interactively(eval-print-last-sexp nil)
    call-interactively(eval-print-last-sexp nil nil)
    command-execute(eval-print-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
 #+end_src

- As usual, the error message tries to be helpful and makes sense
  after you learn how to read it. (~quote-hello)~ is an expansion of
  the abbreviation ~'hello~.

- The first part of the error message is straightforward; it says
  '~wrong-type-argument~'.  Next comes the mysterious jargon word
  '~number-marker-p~'.  This word is trying to tell you what kind of
  argument the ~+~ expected.

- The symbol ~number-or-maker-p~ says that the Lisp interpreter is
  trying to determine whether the information presented (the value of
  the argument) is a number or a marker (a special object representing
  a buffer position).  What it does is test to see whether the ~+~ is
  being given numbers to add.  It also tests to see whether the
  argument is something called a marker, which is a specific feature
  in Emacs Lisp.  In Emacs Lisp, ~+~ can be used to add the numeric
  value of marker position as numbers.

- The ~'p~ of ~number-or-maker-p~ is the embodiment of a practice
  started in the early days of Lisp programming.  The ~p~ stands for
  "*predicate*".

  In the jargon used by the early Lisp researchers a predicate refers
  to a function to determine whether some property is true or false.

  So the '~p~' tells us that ~number-or-marker-p~ is the name of a
  function that determines whether it is true or false that the
  argument supplied is a number or a marker.

  Other Lisp symbol that end in '~p~' include ~zerop~, a function test
  whether its argument has the value of zero; and ~listp~, a function
  that tests whether its argument is a list.

*** The ~message~ Function

- Like ~+~, the ~message~ function takes a variable numbers of
  arguments.  It used to send messages to the user and is so useful
  that we will describe it here.

- A message is printed in the echo area.  For example, you can print a
  message in your echo area by evaluating the following list:

  #+begin_src emacs-lisp
    (message "This message appears in the echo area!")
  #+end_src

- The whole string between double quotation marks is a /single
  argument/ and is printed in /toto/.

  Note that in this example, the message itself will appear in the
  echo area within double quotes; that is because you see the value
  returned by the ~message~ function.  In most uses of ~message~ in
  program that you write, the text will be printed in the echo area as
  a side-effect, without quotes.  See ~multiply-by-seven~ in detail,
  for an example of this.

- However, if there is a '~%s~' in the quoted string of characters,
  the ~message~ function does not print the '~%s~' as such, but looks
  to the argument that follows the string.  It evaluates the second
  argument and prints the value at the location in the string where
  the '~%s~ is.

  #+begin_src emacs-lisp
    (message "The name of this buffer is: %s." (buffer-name))
  #+end_src

- In info, ~"The name of this buffer is: *info*."~ will appear in the
  echo area.  The function ~buffer-name~ returns the name of the
  buffer as a string, which the ~message~ function insert in place of
  ~%s~.

- To print a value as an integer, use '~%d~' in the same way as
  '~%s~'.  For example, to print a message in the echo area that
  states the value of the ~fill-column~, evaluate the following:

  #+begin_src emacs-lisp
(message "The value of fill-column is %d." fill-column)
  #+end_src

- On my system, when I evaluate this list, ~"The value of fill-column
  is 70."~ appears in my echo area. (actually, you can use ~%s~ to
  print a number.  It is non-specific.  ~%d~ prints only the pat of a
  number left of a decimal point, and not anything that is not a
  number.)

- If there is more than one '~%s~' in the quoted string, the value of
  the first argument following the quoted string is printed at the
  location of the first '~%s~' and the value of the second argument is
  printed at the location of the second '~%s~', and so on.

  #+begin_src emacs-lisp
    (message "Tere are %d %s in the office!"
         (- fill-column 14) "pink elephants")
  #+end_src

  a rather whimsical message will appear in your echo area.  On my
  system it says, ~"there are 56 pink elephants in the office!"~.

- The expression ~(- fill-column 14)~ is evaluated and the resulting
  number is inserted in place of the '~%d~'; and the string in double
  quotes, ~"pink elephants"~, is treated as a single argument and
  inserted in place of the '~%s~'.  (That is to say, a string between
  double quotes evaluates itself, like a number.)

- Finally, here is somewhat complex example that not only illustrates
  the computation of a number, but also shows you how you can use an
  expression within an expression to generate the text that is
  substituted for '~%s~':

  #+begin_src emacs-lisp
    (message "He saw %d %s"
             (- fill-column 32)
             (concat "red "
                     (substring
                      "The quick brown foxes jumped." 16 21)
                     " leaping."))
  #+end_src

- In this example, ~message~ has three arguments: the string, ~"He saw
  %d %s"~, the expression, ~(- fill-column 32)~, and the expression
  beginning with the function ~concat~.  The value resulting from
  evaluation of ~(- fill-column 32)~ is inserted in place of the
  '~%d~', and the value returned by the expression beginning with
  ~concat~ is inserted in place of the '~%s~'.

- When your fill column is 70, and you evaluate the expression, the
  message ~"He saw 38 red foxes leaping."~ appears in your echo area.

** Setting the Value of a Variable

- There are several ways by which a variable can be given a value. One
  of the ways is to use either the function ~set~, or the special form
  ~setq~.  Another way is to use ~let~.

- The jargon for this process is to /bind/ a variable to a value.

  - [[Using set][Using set]]                 Setting values.
  - [[Using ~setq~][Using ~setq~]]              Setting a quoted value.
  - [[Counting][Counting]]                  Using ~setq~ to count.

*** Using set

- To set the value of the symbol ~flowers~ to the list ~'(rose violet
  daisy buttercup)~, evaluate the following expression by positioning
  the cursor after the expression and typing ~C-x C-e~.

  #+begin_src emacs-lisp
    (set 'flowers '(rose violet daisy buttercup))
  #+end_src

- When you evaluate ~flowers~, the list ~(rose violet daisy
  buttercup)~ appears in the echo area.

- Incidentally, if you evaluate ~'flowers~, the variable with a quote in
  front of it, what you will see in the echo area is the symbol
  itself, ~flowers~.  Here is the quoted symbol, so you can try this:

  #+begin_src emacs-lisp
    'flowers
  #+end_src

- Note also, that when you use ~set~, you need to *quote both arguments*
  to ~set~.  Unless you want them evaluated.

- Since we do not want either argument evaluated, neither the variable
  ~flowers~ nor the list ~(rose violet daisy buttercup)~, both are
  quoted.

- When you use ~set~ *without quoting* it first argument, the first
  argument is evaluated before anything else is done.  If you did this
  and ~flowers~ did not have a value already, you would get an error
  message that the ~'Symbol's value as variable is void'~; on the
  other hand, if ~flowers~ did return a value after it was evaluated,
  the ~set~ would attempt to set value that was returned.  There are
  situations where this is the right thing for the function to do; but
  such situation are *rare*.

*** Using ~setq~

- As a practical matter, you almost always quote the first argument to
  ~set~.  The combination of ~set~ and a quoted first argument is /so
  common/ that is has its own name: the special form ~setq~.  This
  special form is just like ~set~ except that the first argument is
  *quoted automatically*, so you don't need to type the quote mark
  yourself.

- Also, as an added convenience, ~setq~ permits you to set several
  different variables to different values, all in one expression.

- To set the value of the variable ~carnivores~ to the list ~'(lion
  tiger leopard)~ using ~setq~, the following expression is used

  #+begin_src emacs-lisp
    (setq carnivores '(lion tiger leopard))
  #+end_src

- This is exactly the same as using ~set~ except the first argument is
  automatically quoted by ~setq~

- The '~q~' in ~setq~ means *quote*.

- With ~set~, the expression would look like this:

  #+begin_src emacs-lisp
    (set 'carnivores '(lion tiger leopard))
  #+end_src

- Also, ~setq~ can be used to assign /different values to different
  variables/.  The first argument is bound to the value of the second
  argument, the third argument is bound to the value of the forth
  argument, and so on.

- For example, you could use the following to assign a list of trees to
  the symbol ~trees~ and list of herbivores to the symbol ~herbivores~:

  #+begin_src emacs-lisp
    (setq trees '(pine fir oak maple)
          herbivores '(gazelle antelope zebra))
  #+end_src

- The expression could just as well been on one line, but it might not
  have fit on a page; and humans find it easier to read nicely
  formatted lists.

  Although I have been using the term "*assign*", there is another way
  of thinking about the workings of ~set~ and ~setq~; and that is to
  say that ~set~ and ~setq~ make the symbol /point/ to the list.  This
  latter way of thinking is very common and in forthcoming chapters we
  shall come upon at least one symbol that has "*pointer*" as part of
  its name.  The name is chosen because the symbol has a value,
  specifically a list, attached to it; or, expressed another way, the
  symbol is set to point to the list.

*** Counting

- Here is an example that show how to use ~setq~ in a counter. You might
  use this to count how many times a part of your program repeats
  itself.  First set a variable to zero; then add one to the number
  each time the program repeat itself.  To do this, you need a
  variable that serves as a counter, and two expression; an initial
  ~setq~ expression that sets the counter variable top zero; and a
  second ~setq~ expression that increment the counter each time it is
  evaluated.

  #+begin_src emacs-lisp
    (setq counter 0)              ;; let's call this initializer

    (setq counter (+ counter 1))  ;; This is the increment

    counter                       ;; This is the counter
  #+end_src

- If you evaluate the first of these expression, the initialize,
  ~(setq counter 0)~, and then evaluate the third expression,
  ~counter~, the number ~0~ will appear in the echo area.

  If you then evaluate the second expression, the incremented, ~(setq
  counter (+ counter 1))~, the counter will get the value of ~1~.

  So if you again evaluate ~counter~, the number ~1~ will appear in
  the echo area.

  Each time you evaluate the second expression, the value of the
  counter will be increased.

- When you evaluate the incrementer, ~(setq counter (+ counter 1))~, the
  Lisp interpreter first evaluates the innermost list; this is the
  addition.  In order to evaluates this list, it must evaluates the
  variable ~counter~ and the number ~1~.  When it evaluates the
  variables ~counter~, it receives its current values.  It passes this
  values and the number ~1~ to the ~+~ which adds them together.  The
  sum is then returned as the value of the inner list and passed to
  the ~setq~ which sets the variables ~counter~ to this new values.
  Thus, the value of the variable, ~counter~, is changed.

** Summary

Learning Lisp is like climbing a hill in which the first part is the
steepest.  You have now climbed the most difficult part; what remains
becomes easier as you progress inwards.

- Lisp programs are made up of /expression/, which are /lists/ or
  /single atoms/.

- List are made up of /zero/ or /more atoms/ or /inner list/,
  separated by whitespace and surround by parentheses.  A list can be
  empty.

- Atoms are /multi-character symbols/, like ~forward-paragraph~,
  /single character symbol/ like ~+~, /string of characters/ between
  double quotes marks, or numbers.

- A number evaluates to itself.

- A string between double quotes also evaluates itself.

- When you evaluate a symbol by itself, its value is returned.

- When you evaluate a list, the Lisp interpreter looks at the first
  symbol in the list and then at the function definition bound to that
  symbol.  Then the instruction in the function definition are carried
  out.

- A single-quote *~'~*, tells the Lisp interpreter that it should
  returns the following expression as written, and not evaluate it as
  it would if the quote were not there.

- Arguments are the information passed to a function.  The arguments
  to a function are computed by evaluating the rest of the elements of
  the list of which the function is the first elements.

- A function always returns a value when it is evaluated (unless it
  gets an error); in addition, it may also carry out some action that
  is a /side effect/.

- In many cases, *a function's primary purpose is to create a side effect*.


* Practicing Evaluation

- It is useful to spend a little time evaluating various expression that
  have already written.  Theses expression will be lists with the
  functions as their first (and often only) element.  Since some of the
  *functions associated with buffers* are both simple and interesting,
  we will start with those.

- In this section, we will evaluate a few of these. In another section,
  we will study the code of several other buffer-related function, to
  see how they were written.

 - [[How to Evaluate][How to Evaluate]]         Typing editing or ~C-x C-e~ causes evaluation

 - [[Buffer Names][Buffer Names]]            Buffers and files are different.

 - [[Getting Buffers][Getting Buffers]]         Getting a buffer itself, not merely its name.

 - [[Switching Buffers][Switching Buffers]]       How to change to another Buffer.

 - [[Buffer Size and the location of Point][Buffer Size & Location]]  Where point is located and the size of the buffer

** How to Evaluate

- /Whenever you give an editing command/ to Emacs Lisp, such as the
  command to move the cursor or to scroll the screen, you are
  /evaluating an expression/, he first element of which is a
  function. /This is how Emacs works/.

- When you type keys, you cause the Lisp interpreter to evaluate an
  expression and that is how you get your result.

- Even typing plain text involves evaluating an Emacs Lisp function, in
  this case, one that use ~self-inserted-command~, which simply inserts
  the character you typed.

- The functions you evaluate by typing keystrokes are called
  /interactive/ function, or /commands/; how you make a function
  interactive will be illustrated in the chapter on how to write
  function definitions.

- In addition to typing keyboard commands, we have seen a second way to
  evaluate an expression: by positioning the cursor after a list and
  typing ~C-x C-e~.  This is what we will do in the rest of this
  section.  There are other ways to evaluate an expression as well;
  these will be described as we come to them.

- Beside being used for practicing evaluation, the functions shown in
  the next few section are important in their own right.  A study of
  these functions makes clear the distinction between /buffers/ and
  /files/, how to switch to a buffer, and how to determine a location
  with it.

** Buffer Names

- The two function, ~buffer-name~ and ~buffer-file-name~, show the
  difference between a file and a buffer.  When you evaluate the
  following expression, ~(buffer-name)~, the name of the buffer appears
  in the echo area. When you evaluate ~(buffer-file-name)~, the name of
  the file which the buffer refers appears in the echo area.  Usually,
  the name returned by ~(buffer-name)~ is the same as the name of the
  file to which it refers, and the name returned by ~(buffer-file-name)~
  is the full path-name of the file.

- A file and a buffer are two different entities.  A file is
  information recorded permanently in the computer (unless you delete
  it).

- A buffer, on the other had, is information inside of Emacs that will
  vanish at the end of the editing session (or when you kill the
  buffer).

- Usually a buffer contains information that contains information that
  you have copied from a file; we say that buffer is /visiting/ that
  file.  This copy is what you work on and modify.  Changes to the
  buffer do not change the file, until you save the buffer.  When you
  save the buffer is copied to the file and is thus saved permanently.

  #+begin_src emacs-lisp
    (buffer-name)
    (buffer-file-name)
  #+end_src

- In spite of the distinction between files and buffers, you will often
  find that people refer to a file when they mean a buffer and vice
  versa.  Indeed most say "I am editing a file," rather than saying,
  "I am editing a buffer which I will soon save to a file".  It is
  almost always clear from context what people mean.

  When dealing with computer programs, however, it is important to
  keep the distinction in mind, since the computer is not as smart as
  a person.

- The word "buffer", by the way, comes from the meaning of the word as a
  cushion that deadens the force of a collision.  In early computers,
  a buffer cushioned the interaction between files and computers
  central processing unit.  The drums or tapes that held a file and
  the central processing unit were pieces of equipment that were very
  different from each other, working at their own speed, in spurts.
  The buffer made it possible for them to work together effectively.
  Eventually, the buffer grew from being an intermediary, a temporary
  holding place, to being the place where work is done.  this
  transformation is rather like that of a small seaport that grew into
  a great city; once it was merely the place where cargo was
  warehoused temporarily before being loaded onto ship; then it became
  a business and cultural center in its own right

- Not all buffers are associated with files. For example, a ~*scratch*~
  buffer does not visit any files.  Similarly, a ~*Help*~ buffer is
  not associated with any file.

- In the old days, when you lacked a ~~/.emacs~ file and started an
  Emacs session by typing the command ~emacs~ alone, without naming
  any files, Emacs started with the ~*scratch*~ buffer visible.
  Nowadays, you will see a splash screen.  You can follow one of the
  command suggested on the splash screen, visit a file, or press ~q~
  to quit the splash screen and reach the ~*scratch*~ buffer.

- If you switch to the ~*scratch*~ buffer, type ~(buffer-name)~,
  position the cursor after it, and then type ~C-x C-e~ to evaluate
  the expression. The name ~"*scratch*"~ will returned and will appear
  in echo area.  ~"*scratch*"~ is the name of the buffer.  When you
  type ~(buffer-file-name)~ in the ~*scratch*~ buffer and evaluate
  that, ~nil~ will appear in the echo area, just as it does when you
  evaluate ~(buffer-file-name)~ in Info.

- Incidentally, if you are in the ~*scratch*~ buffer and want the value
  returned by an expression to appear in the ~*scratch*~ buffer itself
  rather than in the echo area, type ~C-u C-x C-e~ instead of ~C-x
  C-e~.  This causes the value returned to appear after the
  expression. The buffer will look like this:

  #+begin_src emacs-lisp
  ;; in *scratch* buffer
    (buffer-name)"*scratch*"
  #+end_src

- You cannot do this in Info since Info is read-only, and it will not
  allow you to change the contents of the buffer.  But you can do this
  in any buffer you can edit; and when you write code for
  documentation (such as this book), this feature is useful.

** Getting Buffers

- The ~buffer-name~ function returns the /name/ of the buffer; to get
  the buffer /itself/, a different function is needed; the
  ~current-buffer~ function.  If you use this function in code, what
  you get is the buffer it self.

- A name and the object or entity to which the name refers are different
  from each other.  The name of the scratch buffer is ~*scratch*~, but
  the name is *not* the buffer.  To get a buffer itself, you need to
  use a function such as ~current-buffer~.

- However, there is a slight complication: if you evaluate
  ~current-buffer~ in an expression on its own, as we will do here,
  what you see is a printed representation of the name of the buffer
  without the contents of the buffer.  Emacs work this way for *two
  reason*:

  -- the buffer may be thousand of line log--too long to be
  conveniently displayed

  -- Another buffer may have the same contents but a different name,
  and it is important to distinguish between them.

- Here is an expression containing the function:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (current-buffer)
  #+end_src

- If you evaluate this expression in ~*scratch*~ buffer in the usual
  way, ~#<buffer *scratch*>~ will appear in the echo area.  The
  special format indicates the buffer itself is being returned, rather
  than just its name.

  Incidentally, while you can type a number or symbol into a program,
  you cannot do that with the printed representation of a buffer; the
  only way.

  A related function is ~other-buffer~.  This returns the most recently
  selected buffer other than one you are in currently, bit a printed
  representation of its name.  If you have recently switched back and
  forth from the ~*scratch*~ buffer, ~other-buffer~ will return that
  buffer.

  You can see this by evaluating the expression:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (other-buffer)
  #+end_src

You should see ~#<buffer *scratch*>~ appear in the echo area, or the
name of whatever other buffer you switched back from most recently.

** Switching Buffers

The ~other-buffer~ function actually provides a buffer when it us used
an argument to a function that requires one.  We can see this by using
~other-buffer- and ~switch-to-buffer~ to switch to a different buffer.

But first, a brief introduction to the ~switch-to-buffer~ function.
When you switched back and forth from Info to the ~*scratch*~ buffer
to evaluate ~(buffer-name)~, you most likely typed ~C-x b~ and then
typed ~*scratch*~ when prompted in the minibuffer for the name of the
buffer to which you wanted to switch.  The keystroke ~C-x b~, cause
the Lisp interpreter to evaluate the interactive function
~switch-to-buffer~.  As we said before, this is how Emacs works:
/different keystrokes call or run different function/.  For example,
~C-f~ calls ~forward-char~, ~M-e~ calls ~forward-sentence~, and so on.


By writing ~switch-to-buffer~ in an expression, and giving it a buffer
to switch to, we can switch buffers just the way ~C-x b~ does:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (switch-to-buffer (other-buffer))
  #+end_src

- The symbol ~switch-to-buffer~ is the first element of the list, so the
  Lisp interpreter will treat it as a function and carry out the
  instruction that are attached to it.  But before doing that, the
  interpreter will note that ~other-buffer- is inside parentheses and
  work on that symbol first.

  ~other-buffer- is the first (and in this case, the only) element of
  the list, so the Lisp interpreter calls or runs the function.  It
  returns another buffer.

  Next the interpreter runs ~switch-to-buffer~, passing to it, as an
  argument, the other buffer, which is what Emacs will switch to. If
  you are reading this in Info, try this now.  Evaluate the
  expression.

- In the programming examples in later section of this document, you
  will see the function ~set-buffer~ more often than
  ~switch-to-buffer~.  This because of a difference between computer
  program and humans: /Humans eyes and expect to see the buffer on
  which they are working on their computer terminals/.  This is so
  obvious, it almost goes without saying.  However program do not have
  eyes.  /When a computer program work on a buffer, that buffer does
  not have to be visible on the screen/.

- ~switch-to-buffer~ is designed for humans and does two different things:

  -- It switches the buffer to which Emacs's attention is directed;

  -- It switches the buffer in the window to the new buffer.

- ~set-buffer~ on other hand does only one thing:

  -- It switches the attention of the computer program to a different
  buffer.  The buffer on screen remain unchanged (of course, normally
  nothing happens there until the command finished running).

- Also, we have just introduced another jargon term, the word
  */call/*.  When you evaluate a list in which the first symbol is a
  function, you are calling that function.  The use of the term comes
  from the notion of the function as an entity that can do something
  for you if you call it--just a plumber is an entity who can fix a
  leak if you call him or her.

** Buffer Size and the location of Point

Finally, let's look at several rather simple function, ~buffer-size~,
~point~, ~point-min~, and ~point~max~.  These give information about
the size of a buffer and the location of point within it.

- The function ~buffer-size~ tells you the size of the current buffer,
  that is, the function returns a count of the number of characters in
  the buffer

  #+begin_src emacs-lisp
    (buffer-size)
  #+end_src

- In Emacs, the */current position of the cursor/* is called
  */point/*.  The expression ~(point)~ returns a number that tells you
  where the cursor is located as a count of the number of characters
  from the beginning of the buffer up to point.

  You can see character count for point in this buffer by evaluating
  the following expression in the usual way:

  #+begin_src emacs-lisp
    (buffer-size)49770 ; C-u C-x C-e
  #+end_src

  As I write this, the value of point is 49770. The ~point~ function is
  frequently used in some of the examples later in this book.

- The value of point depends, of course, on its location within the
  buffer. If you evaluate point in this spot, the number will be
  larger

  #+begin_src emacs-lisp
    (buffer-size)49775  ; C-u C-x C-e
  #+end_src

- For me, the value of point in this location is 49775, which means that
  there 49855 characters (including spaces) between the two
  expression. (Doubtles, you will see different numbers, since I will
  have edited this since I first evaluated point.

  #+begin_src emacs-lisp
    (point-min)1  ; C-u C-x C-e

    (point-max)50296  ; C-u C-x C-e
  #+end_src

- The function ~point-min~ is somewhat similar to ~point~, but it
  returns the value of the /minimum permissible/ value of point in the
  current buffer.  This is the number ~1~ unless /narrowing/ is in
  effect.  (Narrowing is a mechanism whereby you can restrict
  yourself, or a program, to operations on juts a part of a
  buffer. See Narrowing and Widening).

- Likewise, the function ~point-max~ returns the value of the maximum
  permissible value of point in the current buffer.


* How To Write Function Definition

- When the Lisp interpreter evaluates a list, it looks to see whether
  the first symbol on the list has a function definition attached to
  it; or, put another way, whether the symbol points to a function
  definition.  If it does, the computer carries out the instruction in
  the definition.  A symbol that has a function definition is called,
  simply, a function (although, properly speaking, the definition is
  the function and the symbol refers to it).

  - [[An Aside about Primitive Function][Primitive Function]]

  - [[~defun~ Makro][~defun~]]                     The ~defun~ macro.

  - [[Install A Function Definition][install]]                     Install a function definition.

  - [[Make a Function Interactive][Interactive]]                 Making a function interactive.

  - [[Different Options for interactive][Interactive Options]]         Different options for ~interactive~.

  - [[Install Code Permanently][Permanent Installation]]      Installing code permanently.

  - [[let][let]]                         Creating and initializing local variables.

  - [[The ~if~ Special Form][if]]                      What if?

  - [[If-then-else Expression][else]]                        if-then-else expression.

  - [[Truth & Falsehood in Emacs Lisp][Truth & Falsehood]]           What Lisp considered false and true.

  - [[~save-excursion~][~save-excursion~]]            Keeping track of point and buffer.

  - [[Review][Review]]

** An Aside about Primitive Function

- /All function are defined in terms of other functions/,*except* for
  a few */primitive/* functions that are written in the C programming
  language.

- When you write functions' definitions, you will write them in Emacs
  Lisp and use other functions as your building blocks.  Some of the
  function you will use will themselves be written in Emacs Lisp
  (perhaps by you) and some will be primitives written in C.

- When you write code in Emacs Lisp, you d not distinguish between the
  use of function written in C and the use of functions written in
  Emacs Lisp.  The difference is irrelevant.  I mention the
  distinction only because it is interesting to know.  Indeed, unless
  you investigate, you won't know whether an already-written function
  is written in Emacs Lisp or C.

** ~defun~ Makro

- In Lisp, a symbol such as ~mark-whole-buffer~ has code attached to
  it that tells the computer what to do when the function is called.
  This code is called the /function definition/ and is created by
  evaluating a Lisp expression that start with the symbol /defun/
  (which abbreviation for /define function/).

  In Subsequent sections, we will look at function definitions from
  the Emacs source code, such as ~mark-whole-buffer~.  In this
  section, we will describe a simple function definition so you can
  see how it looks.

  This function definition uses arithmetic because it makes for a
  simple example.  Some people dislike example using arithmetic;
  however, if you are such a person, do not despair.  Hardly any of
  the code we will study in the remainder of this introduction
  involves arithmetic or mathematics.  The examples mostly involve
  text in one way or another.

- A function definition has up to *five* parts following the word ~defun~:

  - The name of the symbol to which the function definition should be attached

  - A list of the /arguments/ that will be passed to the function.  If
    no arguments will be passed to the function, this is an empty list
    ~()~

  - Documentation describing the function. (Technically optional, but
    strongly recommended).

  - Optionally, an expression to make the function *interactive* so
    you can use it by typing ~M-x~ and then the name of the function;
    or by typing an appropriate key or key chord.

  - The code that instruct the computer what to do; the /body/ of the
    function definition.

- It is helpful to think of the /five parts/ of a function definition
  as being organized in a template, with slots for each part:

  #+begin_src emacs-lisp
    (defun function-name (arguments...)
      "optional-documentaion.."
      (interactive argument-passing-info)      ; optional
      body..)
  #+end_src

- As an example, here is the code for a function that multiplies its
  arguments by 7. (This example is *not interactive*)

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))
  #+end_src

  - The definition begin with a parenthesis and the symbol ~defun~,
    followed by the name of the function.

  - The name of the function is followed by a list that contains the
    arguments that will be passed to the function.  This list is
    called the /argument list/.  In this example, the list has only
    one element, the symbol, ~number~.  When the function is used, the
    symbol will be bound to the value that is used as argument to the
    function.

  - The argument list is followed by the documentation string that
    describes the function.  This is what you see when you type ~C-h
    f~ and the name of a function.  Incidentally, when you write a
    documentation string like this, you should make the first line a
    complete sentence since some commands, such /apropos/, print only
    the first line of a multi-line documentation string.  Also, you
    should not indent the second line of a documentation string, if
    you have one, because that looks odd when you use ~C-h f
    (describe-function)~.

  - The documentation string is optional, but it is so useful, it
    should be included in almost every function you write.

  - The third line of the example consist of the body of the function
    definition.  In this function, the body is the list, ~(* 7
    number)~, which says to multiply the value of /number/ by 7.

- When you use the ~multiply-by-seven~ function, the argument ~number~
  evaluates to the actual number you want used.  Here is an example
  that shows ~multiply-by-seven~ is used; but don't try to evaluate
  this yet!!.

  #+begin_src emacs-lisp
    (multiply-by-seven 3)
  #+end_src

  - The symbol ~number~, specified in the function in the next
    section, is bound to the value 3 in the actual use of the
    function.

  - Note that although ~number~ was inside parentheses in the function
    definition, the argument passed to the ~multiply-by-seven~ is not
    parentheses.  The parentheses are written in the function
    definition so the computer can figure out where argument list ends
    and the rest of the function definition begins.

- If you evaluate this example, you are likely to get an error
  message.  This is because we have written the function definition,
  but not yet told the computer about the definition--we have *not yet
  loaded the function definition in Emacs*.  Installing a function is
  the process that tells the Lisp interpreter the definition of the
  function.

** Install A Function Definition

- If you are reading this inside Info in Emacs, you can try out the
  ~multiply-by-seven~ function by first evaluating the function
  definition and then evaluating ~(multiply-by-seven 3)~.  A copy of
  the function definition follows.

- Place the cursor after the last parenthesis of the function
  definition and type ~C-x C-e~.  When you do this,
  ~multiply-by-seven~ will appear in the echo area.  (What this means
  is that when a function definition is evaluated, the value it
  returns is the name of the defined function).  At the same time,
  this action installs the function definition.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))
  #+end_src

- By evaluating this ~defun~, you have just *installed*
  ~multiply-by-seven~ in Emacs.  The function is now just as much as
  part of Emacs as ~forward-word~ or any other editing function you
  use.

- ~multiply-by-seven~ will stay installed until you quit Emacs.  To
  reload code automatically whenever you start Emacs, see Installing
  Code Permanently.

  -- [[The effect of installation][Effect of installation]]

  -- [[Change a Function Definition][Change a defun]]             How to change a function definition

*** The effect of installation

- You can see the effect of installing ~multiply-by-seven~ by evaluating
  the following sample.  Place the cursor after the following expression
  and the ~C-x C-e~.  The number 21 will appear in the echo area.

  #+begin_src emacs-lisp
    (multiply-by-seven 3)
  #+end_src

- If you wish, you can read the documentation for the function by
  typing ~C-h f (describe-function)~ and then the name of the
  function, ~multiply-by-seven~.  When you do this, a ~*Help*~ window
  will appear on your screen that says

  #+begin_src emacs-lisp
  multiply-by-seven is a Lisp function.

  (multiply-by-seven NUMBER)

  Multiply NUMBER by seven.
  #+end_src

*** Change a Function Definition

- If you want to change the code in ~multiply-by-seven~, just rewrite
  it.  To install the new version in place of the old one, evaluate
  the function definition again.  This is how you modify code in
  Emacs.  It is very simple.

- As an example, you can change the ~multiply-by-seven~ function to
  add the number to itself seven times instead of multiplying the
  number by seven.  It produces the same answer, but by a different
  path.  At the same time, we will add comment to the code; a comment
  is text that Lisp interpreter ignores, but that a human reader may
  find useful or enlightening.

- The comment is that this is the second version.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)         ; Second version
      "Multiply NUMBER by seven."
      (+ number number number number number number number))
  #+end_src

- The comment follows a semicolon '~;~'.  In Lisp, everything on a
  line that follows a semicolon is a comment.  The end of the line is
  the end of the comment.  To stretch a comment or two or more lines,
  begin each lines with a semicolon.

- See Beginning a .emacs File, and Comments in The GNU Emacs Lisp
  Reference Manual, for more about comments.

- You can install the version of the ~multiply-by-seven~ function by
  evaluating it in the same way you evaluated the first function:
  place the cursor after the last parenthesis and type ~C-x C-e~.

- In summary, this is how you write code in Emacs Lisp: you write a
  function; install it; test it; and then make fixes or enhancements
  and install it again.

** Make a Function Interactive

- You make a function interactive by placing a list that begins with the
  special form ~interactive~ immediately after the documentation.  A
  user can invoke an interactive function by typing ~M-x~ and then the
  name of the function; or by typing the keys to which it is bound;
  for example, by typing ~C-n~ for ~next-line~ or ~C-x h~ for
  ~mark-whole-buffer~.

- Interestingly, when you call an interactive function interactively,
  the value returned is not automatically displayed in the echo area.
  This is because you often call an interactive function for its side
  effects, such as moving forward by a word or line, and /not for the
  value returned/.  If the returned value were displayed in the echo
  area each time you typed a key, it would be very distracting.


  -- [[An Interactive multiply-by-seven, An Overview][ An Interactive multiply-by-seven]]       An overview

  -- [[An Interactive ~multiply-by-seven~][multiply-by-seven in detail]]             The interactive version

*** An Interactive multiply-by-seven, An Overview

- Both the use of the special form ~interactive~ and one way to display
  a value in the echo area can be illustrated by creating an interactive
  version of ~multiply-by-seven~.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)           ; Interactive version
      "Multiply NUMBER by seven."
      (interactive "p")
      (message "the result is %d" (* 7 number)))
  #+end_src

- You can install this code by placing your cursor after it and typing
  ~C-x C-e~. The name of the function will appear in your echo area.
  Then, you can use this code by typing ~C-u~ and a number and then
  typing ~M-x multiply-by-seven~ and pressing ~RET~.  The phrase '~The
  result is ...~' followed by the product will appear in the echo
  area.

- Speaking more generally, you invoke a function like this in either
  of two ways:

  1. By typing a prefix argument that contains the number to be
     passed, and then typing ~M-x~ and the name of the function, as
     which "~C-u 3 M-x forward-sentence~"; or,

  2. By typing whatever key or key chord the function is bound to,
     with ~C-u 3 M-e~.

  - Both the examples just mentioned work identically to move point
    forward three sentences. (Since ~multiply-by-seven~ is not bound
    to any key, it could not be used as an example of key binding.).

- A /prefix argument/ is passed to an interactive function by typing
  the ~META~ key followed by a number, for example, ~M-3 M-e~, or by
  typing ~C-u~ and then a number, for example, ~C-u 3 M-e~ (if you
  type ~C-u~ without a number, it defaults to 4).

*** An Interactive ~multiply-by-seven~

- Let's look at the use of the special from ~interactive~ and then at
  the function ~message~ in the interactive version of
  ~multiply-by-seven~.  You will recall that the function definition looks like this:

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)           ; Interactive version
      "Multiply NUMBER by seven."
      (interactive "p")
      (message "The result is %d" (* 7 number)))
  #+end_src

- In this function, the expression, ~(interactive "p")~, is a list of
  two elements.  The ~"p"~ tells Emacs to pass the prefix argument to
  the function and use its value for the argument of the function.

- The argument will be a number.  This means that the symbol ~number~
  will be bound to a number in the line:

  #+begin_src emacs-lisp
    (message "The result is %d" (* 7 number))
  #+end_src

- For example, if you prefix argument is 5, the Lisp interpreter will
  evaluate the line as if it were:

  #+begin_src emacs-lisp
    (message "The result is %d" (* 7 5))
  #+end_src

- (If you are reading this in GNU Emacs, you can evaluate this
  expression yourself). First, the interpreter will evaluate the inner
  list, which ~(* 7 5)~.  This returns a value of 35.  Next, it will
  evaluate the outer list, passing the values of the second and
  subsequent elements of the list to the function ~message~.

- As we have seen, ~message~ in Emacs Lisp function especially
  designed for sending a one line message to a user.  In summary, the
  ~message~ function prints its first argument in the echo area as is,
  except for occurrences of '~%d~' and '~%s~' (and various other
  %-sequences which we have not mentioned).  When it sees a control
  sequence, the function looks to the second or subsequent arguments
  and prints the value of the argument in the location in the string
  where the control sequence is located.

- In the interactive ~multiply-by-seven~ function, the control string
  is '~%d~', which requires a number, and the value returned by
  evaluating ~(* 7 5)~ is the number 35.  Consequently, the number 35
  is printed in place of the '~%d~' and the message is '~The result is
  35~'.

- Note that when you call the function ~multiply-by-seven~, the
  message is printed without quotes, but when you call ~message~, the
  text is printed in double quotes.  This is because the value
  returned by ~message~ is what appears in the echo area when you
  evaluate an expression whose first element is ~message~; but when
  you embedded in a function, ~message~ prints the text as a /side
  effect/ without quotes.

** Different  Options for interactive

- In the example, ~multiply-by-seven~ used ~"p"~ as the argument to
  ~interactive~.  This argument told Emacs to interpret your typing
  either ~C-u~ followed by number or ~META~ followed by a number as a
  command to pass that number to the function argument.  Emacs has more
  that twenty characters predefined for use with ~interactive~.  In
  almost case, one of these options will enable you to pass the right
  information interactively to a function.  (See Code Characters for
  ~interactive~) in the GNU Emacs Lisp Reference Manual.)

- Consider the function ~zap-to-char~. Its interactive expression is

  #+begin_src emacs-lisp
    (interactive "p/ncZap to char: ")
  #+end_src

  - The first part of the argument to ~interactive~ is '~p~', with
    which you are already familiar.  This argument tells Emacs to
    interpret a prefix, as a number to be passed to a the function.
    You can specify a prefix either by typing ~C-u~ followed by a
    number or by typing ~META~ followed by a number.

  - The prefix is the number of specified characters.  Thus, if your
    prefix is three and the specified character is '~x~', then you
    will delete all the text up to and including the third next '~x~'.
    If you do not set a prefix, then you delete all the text up to an
    including the specified character, but no more.

  - The '~c~' tells the function the name of the character to which to
    delete.

  - More formally, a function with two or more arguments can have
    information passed to each argument by adding parts to the string
    that follows ~interactive~.  When you do this, the information is
    passed to each arguments in the same order it is specified in the
    ~interactive~ list.  In the string, each part is separated from
    the next part by a '~\n~', which is a newline.  For example, you
    can follow '~p~' with a '~/n~' and an '~cZap to char: ~'. This
    causes Emacs to pass the value of the prefix argument (if there is
    one) and the character.

  - In this case, the function definition looks like the following,
    where ~arg~ and ~char~ are the symbol to which ~interactive~ binds
    the prefix argument and the specified character:

    #+begin_src emacs-lisp
      (defun name-of-function (arg char)
        "Documentation..."
        (interactive "p/ncZap to char: ")
        body-of-function...)
    #+end_src

  - (The space after the colon in the prompt makes it look better when
    you are prompted. See The Definition of ~copy-to-buffer~, for an
    example)

  - When a function does not take arguments, ~interactive~ does not
    require any.  Such a function contains the simple expression
    ~(interactive)~.  The ~mark-whole-buffer~ function is like this.

  - Alternatively, if the special letter-codes are not right for your
    application, you can pass your own arguments to ~interactive~ as a list.

  - See The Definition of ~append-to-buffer~, for an example.  See
    Using Interactive in The GNU Emacs Lisp Reference Manual, for a
    more explanation about this technique.

** Install Code Permanently

- When you install a function definition by evaluating it, it will
  stay installed until you quit Emacs.  The next time you start a new
  session of Emacs, the function will not be installed unless you
  evaluate the function definition again.

- At some point, you may want to have code installed automatically
  whenever you start a new session of Emacs.  There are several ways
  of doing this:

  * If you have code that is just for yourself, you can put the code
    for the function definition in your ~.emacs~ initialization file.
    When you start Emacs, your ~.emacs~ file is automatically
    evaluated and all the function definition within it are
    installed. See Your ~.emacs~ File.

  * Alternatively, you can put the function definitions that you want
    installed in one or more files of their own and use the ~load~
    function to cause Emacs to evaluate and thereby install each of
    the function in this files.  See Loading Files.

  * Thirdly, if you have code that your whole site will use, it is
    usual to put it in a file called ~site-init.el~ that is loaded
    when Emacs is built.  This makes the code available to everyone
    who use your machine.  (See the ~INSTALL~ file that is part of the
    Emacs distribution.)

- Finally, if you have a code that everyone who use Emacs may want,
  you can post it on a computer network or send a copy to Free
  Software Foundation.  (When you do this, please license the code and
  its documentation under a license that permit other people to run,
  copy, study, modify, and redistribute the code and which protects
  you from having your work taken from you.)

- If you send a copy of your code to the Free Software Foundation, and
  properly protect yourself and others, it may be included in the next
  release of Emacs. In large part, this is how Emacs has grown over
  the past years, by donations.

** let

- The ~let~ expression is a special form in Lisp that you will need to
  use in most function definitions.

- ~let~ is used to attach or bind a symbol to a value in such a way
  the Lisp interpreter will not confuse the variable with a variable
  of the same name that is not part of the function.

- To understand why the ~let~ special form is necessary, consider the
  situation in which you own a home that you generally refer to as
  "the house", as in the sentence, "The house needs painting."  If you
  are visiting a friend and your host refer to "the house", he is
  likely to be referring to /his/ house, not yours, that is, to a
  different house.

- If your friend is referring to his house and you think he is
  referring to your house, you may be in for some confusion.  The same
  thing could happen in Lisp if a variable that is used inside of one
  function has the same name as a variable that is used of another
  function, and the two are not intended to refer to the same value.
  The ~let~ special form prevents this kind of confusion.

  -- [[~let~ Prevent confusion][Prevent confusion]]

  -- [[The Parts of a ~let~ Expression][Parts of let Expression]]

  -- [[Sample ~let~ Expression][Sample let Expression]]

  -- [[Uninitialized Variables in a ~let~ Statement][Initialized let Variables]]

*** ~let~ Prevent confusion

- The ~let~ special form prevent confusion. ~let~ creates a name for a
  /local variable/ that overshadows any use of the same name outside
  the ~let~ expression.  This is like understanding that whenever your
  host refers to "the house", he means his house, not yours.  (Symbol
  used in argument list work the same way. See The ~defun~ Macro).

- Local variables created by ~let~ expression retain their value
  /only/ within the ~let~ expression itself (and within expression
  called within the ~let~ expression); the local variables have no
  effect outside the ~let~ expression.

- Another way to think about ~let~ is that it is like a ~setq~ that is
  temporary and local.  The value set by ~let~ are automatically
  undone when the ~let~ is finished.  The setting only affects
  expressions that are inside the bounds of the ~let~ expression.

- In computer jargon, we would say the binding of a symbol is visible
  only in functions called in the ~let~ form; in Emacs Lisp, the
  default scoping is dynamic, not lexical. (The non-default lexical
  binding is not discussed in this manual.)

- ~let~ can create more than one variable at once.  Also, ~let~ gives
  each variable it creates an initial value, either a value specified
  by you, or ~nil~.  (In the jargon, this is binding the variable to
  the value.).

- After ~let~ has created and bound the variables, it /executes/ the
  code in the body of the ~let~, and returns the value of the last
  expression in the body, as the value of the whole ~let~ expression.

- "Execute", is a jargon term that means to evaluate a list; it comes
  from the use of the word meaning "to give practical effect to"
  (Oxford English Dictionary).  Since you evaluate an expression to
  perform an action, "execute" has evolved as a synonym to "evaluate".

*** The Parts of a ~let~ Expression

- A ~let~ expression is list of *three parts*.

  - The first part is the symbol ~let~,

  - The second part is a list, called a /varlist/, each element of
    which is either a symbol by itself or two-element list, the first
    element of which is a symbol.

  - The third part is the body of the ~let~.  The body usually
    consists of one or more lists.

- A template for a ~let~ expression looks like this:

  #+begin_src emacs-lisp
    (let varlist body...)
  #+end_src

- If the varlist is composed of two-element lists, as is often the
  case, the template for the ~let~ expression looks like this:

  #+begin_src emacs-lisp
    (let ((varlist value)
          (varlist value)
          ..)
      body...)
  #+end_src

*** Sample ~let~ Expression

- The following expression creates and gives initial value to the two
  variables ~zebra~ and ~tiger~.  The body of the ~let~ expression is
  a list which calls the ~message~ function.

  #+begin_src emacs-lisp
    (let ((zebra "stripes")
          (tiger "fierce"))
      (message "One kind of animal has %s and another is %s."
               zebra tiger))
  #+end_src

- Here, the varlist is ~(zebra "stripes") (tiger "fierce"))~.

- The two variables are ~zebra~ and ~tiger~.  Each variable is the
  first element of a two-element list and each value is the second
  element of its two-element list.

- In the varlist, Emacs binds the variable ~zebra~ to the value
  "~stripes~", and binds the variable ~tiger~ to the value "~fierce~".
  In this example, both values are strings.  The value could just as
  well have been another list or a symbol.

- The body of the ~let~ follows after the list holding the variables.
  In this example, the body is a list that uses the ~message~ function
  to print a string in the echo area.

- You many evaluate the example in the usual way, by placing the
  cursor after the last parenthesis and typing ~C-x C-e~.  When you do
  this, the following will appear in the echo area:

  #+begin_src emacs-lisp
    "One kind of animal has stripes and another is fierce"
  #+end_src

- As we have seen before, the ~message~ function prints its first
  argument, except for '~%s~'.  In this example, the value of the
  variable ~zebra~ is printed at the location of the first '~%s~' and
  the value of the variable ~tiger~ is printed at the location of the
  second '~%s~'.

*** Uninitialized Variables in a ~let~ Statement

- If you do not bind the variables in a ~let~ statement to specific
  initial values, they will automatically be bound to an initial value
  of ~nil~, as the following expression:

  #+begin_src emacs-lisp
    (let ((birch 3)
          pine
          fir
          (oak 'some))
      (message
       "Here are %d variables with %s, %s, and %s value."  birch
       pine fir oak))
  #+end_src

- Here, the varlist is ~(birch 3) pine fir (oak 'some))~.

- If you evaluate this expression in the usual way, the following will
  appear in your echo area:

  #+begin_src emacs-lisp
    "Here are 3 variabels with nil, nil, and some value."
  #+end_src

- In this example, Emacs binds the symbol ~birch~ to the number 3,
  binds the symbol ~pine~ and ~fir~ to ~nil~, and binds the symbol
  ~oak~ to the value ~some~.

- Note that in the first part of the ~let~, the variables ~pine~ and
  ~fir~ stand alone as atoms that are not surrounded by parentheses;
  this is because they are being bound to ~nil~, the empty list.  But
  ~oak~ is bound to ~some~ and so is a part of the list ~(oak 'some)~.
  Similarly, ~birch is bound to the number 3 and so is in a list with
  that number.  (Since a number evaluates to itself, the number does
  not need to be quoted.  Also, the number is printed in the message
  using a '~%d~' rather than a '~%s~'.) The four variables as a group
  into a list to delimit them from the body of the ~let~.

** The ~if~ Special Form

- Another special form is the condition ~if~.  This form is used to
  instruct the computer to make decisions.  You can write function
  definitions without using ~if~, but it is used often enough, and is
  important enough, to be included here.  It is used, for example, in
  the code for the function ~beginning-of-buffer~.

- The basic idea behind and ~if~, is that /if/ a test is *true*,
  /then/ an expression is *evaluated*.  If the test is *not true*, the
  expression is *not evaluated*.  For example, you might make a
  decision such as, "if it is warn and sunny, then go to the beach!"

  - [[~if~ in more detail][~if~ in more detail]]

  - [[The ~type-of-animal~ Function in Detail][~type-of-animal~ in detail]]     An example of an ~if~ expression.

*** ~if~ in more detail

- An ~if~ expression written in Lisp does not use the word "then"; the
  test and the action are the second and third elements of the list
  whose first element is ~if~.  Nonetheless, the test part of an ~if~
  expression is often called the /if-part/ and the second argument is
  often called the /then-part/.

- Also, when an ~if~ expression is written, the true-or-false is
  usually written on the same lines as the symbol ~if~, but the action
  to carry out if the test is true, the then-part, is written on the
  second and subsequent lines.  This makes the ~if~ expression is
  easier to read.

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-test-is-true)
  #+end_src

- The true-or-false test will be an expression that is evaluated by
  the Lisp interpreter.

- Here is an example that you can evaluate in the usual manner.  The
  test is whether the number 5 is greater than the number 4.  Since it
  is, the message "~5 is greater than 4!~' will be printed.

  #+begin_src emacs-lisp
    (if (> 5 4)                                 ; if-part
        (message "5 is greater than 4!"))       ; then-part
  #+end_src

  - The function ~>~ test whether its first argument is greater than
    its second argument and returns true if it is.

- Of course, in actual use, the test in an ~if~ expression will not be
  fixed for all time as it is by the expression ~(< 5 4)~.  Instead,
  at least one of the variables used in the test will be bound to a
  value that is not known ahead of time.  (If the value were known
  ahead of time, we would not need to run the test!)

- For example, the value may be bound to an argument of a function
  definition.  In the following function definition, the character of
  the animal is a value that is passed to the function. If the value
  bound to ~characteristic~ is "~fierce~", then the message, '~it is a
  tiger!~' will printed; otherwise, ~nil~ will be returned.

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)
      "Print message in echo area depending on CHARACTERISTIC.
        If the CHARACTERISTIC is the string \"fierce\",
    then warn of a tiger"
      (if (equal characteristic "fierce")
          (message "It is a tiger!")))
  #+end_src

- If you are reading this inside of GNU Emacs, you can evaluate the
  function definition in the usual way to install it in Emacs, and
  then you can evaluate the following two expression to see the
  results:

  #+begin_src emacs-lisp
    (type-of-animal "fierce")

    (type-of-animal "striped")
  #+end_src

- When you evaluate ~(type-of-animal "fierce")~, you will see the
  following message printed in the echo area: ~"it is a tiger!"~; and
  when you evalute ~(type-of-animal "stripe")~ you will see ~nil~
  printed in the echo area.

*** The ~type-of-animal~ Function in Detail

- Let's looks at the ~type-of-animal~ function in detail.

- The function definition for ~type-of-animal~ was written by filling
  the slots of two templates, one for a function definition as a
  whole, and a second for an ~if~ expression.

- The template for every function that is not /interactive/ is:

  #+begin_src emacs-lisp
    (defun name-of-function (argument-list)
      "documentation.."
      body..)
  #+end_src

- The part of the function that match this templates look like this:

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)
      "Print message in echo area depending on CHARACTERISTIC.
        If the CHARACTERISTIC is the string \"fierce\",
    then warn of a tiger."
      body: the if expression)
  #+end_src

- The name of function is ~type-of-animal~; it is passed the value of
  one argument.  The argument list is followed by a multi-line
  documentation string.  The documentation string is included in the
  example because it is a good habit to write documentation string for
  every function definition.  The body of the function definition
  consists of the if~ expression.

- The template for an ~if~ expression looks like this:

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-the-test-returns-true)
  #+end_src

- In the ~type-of-animal~ function, the code for the ~if~ looks like this:

  #+begin_src emacs-lisp
    (if (equal characteristic  "fierce")
        (message "It is a tiger!"))
  #+end_src

- Here, the true-or-false-test is the expression:

  #+begin_src emacs-lisp
    (equal characteristic "fierce")
  #+end_src

- In Lisp, ~equal~ is a function that determines whether its first
  argument is equal to its second argument.  The second argument is
  the string ~"fierce"~ and the first argument is the value of the
  symbol ~characteristic~--in other words, the argument passed to this
  function.

- In the first exercise of ~type-of-animal~, the argument ~"fierce"~
  is passed to ~type-of-animal~.  Since ~"fierce"~ is equal to
  ~"fierce"~, the expression, ~(equal characteristic "fierce")~,
  returns a value of /true/.  When this happens, the ~if~ evaluates
  the second argument or then-part of the ~if~: ~(message "It is a
  tiger!")~.

- On the other hand, in the second exercise of the ~type-of-animal~,
  the arguments ~"striped"~ is passed to
  ~type-of-animal"~. ~"striped"~ is not equal to ~"fierce"~, so the
  then-part is not evaluated and ~nil~ is returned by the ~if-
  expression.

** If-then-else Expression

- An ~if~ expression may have an optional third argument, called the
  /else-part/, for the case when the true-or-false-test returns false.
  When this happens, the second argument or then-part of the overall
  ~if~ expression is /not/ evaluated, but the third or else-part /is/
  evaluated.  You might think of this as cloudy day alternative for
  the decision "if it warn and sunny, then go to the beach, else read
  a book!".

- The word "else" is not written in the Lisp code; the else-part of an
  ~if~ expression comes after the then-part.  In the written Lisp, the
  else-part is usually written to start on a line of its own and is
  indented less than the then-part:

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-the-test-returns-true
      action-to-carry-out-if-the-test-returns-false)
  #+end_src

- For example, the following ~If~ expression prints the message ~"4
  not greater than 5!"~ when you evaluate it in the usual way:

  #+begin_src emacs-lisp
    (if (> 4 5)                                 ; if-part
        (message "4 falsely greater than 5!")   ; then-part
      (message "4 is not greater than 5!"))     ; else-part
  #+end_src

- Note that the /different levels of indentation/ make it easy to
  distinguish the then-part from the else-part.

- We can extend the ~type-of-animal~ function t include an else-part by
  simply incorporating an additional part of the ~if~ expression.

- You can see the consequences of doing this if you evaluate the
  following version of the ~type-animal- function to install it and
  then evaluate the two subsequent expression to pass different
  argument to the function.

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)              ; Second version
      "Print message in echo area depending on CHARACTERISTIC.
              If the CHARACTERISTIC is the string \"fierce\",
              then warn of a tiger; else say it is not fierce."
      (if (equal characteristic "fierce")
      (message "It is a tiger!")
      (message "It is not fierce!")))
  #+end_src

  #+begin_src emacs-lisp
    (type-of-animal "fierce")

    (type-of-animal "striped")
  #+end_src

- When you evaluate ~(type-of-animal "fierce")~, you will see the
  following message printed in the echo area: ~"It is a tiger!"~; but
  when you evaluate ~(type-of-animal "stripes")~, you will see ~"It is
  not fierce!"~.

- Of course, i the /characteristic/ were ~"ferocious"~, the message
  ~"It is not fierce!"~ would be printed; and it would be misleading!
  When you write code, you need to take into account the possibility
  that some such argument will be tested by the ~if~ and write your
  program accordingly

** Truth & Falsehood in Emacs Lisp

- There is an important aspect to the truth test in an ~if~
  expression.  So far, we have spoken if "true" and "false" as values
  of predicates as if they were new kinds of Emacs of Emacs Lisp
  objects.  In fact, "false" is just our old friend ~nil~.  Anything
  else--anything at all--is "true".

- The expression that test for truth is interpreted as /true/ if the
  result of evaluating it is a value that is not ~nil~.  In other
  words, the result of the test is considered true if the value
  returned is a /number/ such as 47, a /string/ such as ~"hello"~, or
  a /symbol/ (other than ~nil~) such as ~flowers~, or a /list/ (so
  long as it is not empty) or even a /buffer/!.

  - [[An explanation of ~nil~][nil explained]]        ~nil~ has two meaning

*** An explanation of ~nil~

- Before illustrating a test for truth, we need an explanation of
  ~nil~.

- In Emacs Lisp, the symbol ~nil~ has two meanings. First, it means
  the empty list.  Second, it means false and is the value returned
  when a true-or-false-test tests false.  ~nil~ can be written as an
  empty list, ~()~, or as ~nil~.  As far as the Lisp interpreter is
  concerned, ~()~ and ~nil~ are the same.  Humans, however, tend to
  use ~nil~ for false and ~()~ for the empty list,

- In the first example, the number 4 is evaluated as the test in the
  ~if~ expression and returns itself; consequently, the then-part of
  the expression is evaluated and returned: ~'true'~ appears in the
  echo area.  In the second example, the ~nil~ indicates false,
  consequently, the else-part of the expression is evaluated and
  returned: ~'false'~ appears in the echo area.

  #+begin_src emacs-lisp
    (if 4
        'true
      'false)

    (if nil
        'true
      'false)
  #+end_src

- Incidentally, if some other useful value is not available for a test
  that returns true, then the Lisp interpreter will return the symbol
  ~t~ for true.  For example, the expression ~(> 5 4)~ returns ~t~
  when evaluated, as you can see by evaluating it in the usual way:

  #+begin_src emacs-lisp
    (> 5 4)
  #+end_src

  on the other hand, this function ~nil~ if the else is false.

  #+begin_src emacs-lisp
    (> 4 5)
  #+end_src

** ~save-excursion~

- The ~save-excursion~ function is the final special form that we will
  discuss in this chapter.

- In Emacs Lisp programs used for editing, the ~save-excursion~
  function is very common.  It saves the location of point, executes
  the body of the function, and the restores point to its previous
  position if its location was changed.  It primary purpose is to keep
  the user being surprised and disturbed by unexpected movement of
  point.

  -- [[Point and Mark][Point and Mark]]

  -- [[Template for a ~save-excursion~ Expression][Template for ~save-excursion]]

*** Point and Mark

- Before discussing ~save-excursion~, however, it may be useful first
  to review what point and mark are in GNU Emacs.  /Point/ is the
  *current location of the cursor*.  Whenever the cursor is, that is
  point.  More precisely, on terminals where the cursor appears to be
  on top of a character, point is immediately before the character.
  In Emacs Lisp, point is an *integer*.  The first character in a
  buffer is number one, the second is number two, and so on.  The
  function ~point~ returns the current position of the cursor as a
  number.  Each buffer has its own value for point.

- The /mark/ is another position in the *buffer*; its value can be set
  with a command such as ~C-SPC (set-mark-command)~.  If a mark has
  been set, you can use the command ~C-x C-x
  (exchange-point-and-mark)~ to cause the cursor to jump to the mark
  and set the mark to be the previous position of point.  In addition,
  if you set another mark, the position of the previous mark is saved
  in the mark ring.  Many mark positions can be saved this way.  You
  can jump the cursor to a saved mark by typing ~(C-u C-SPC)~ one or
  more times.

- The part of the buffer between point and mark is called /the
  region/.  Numerous commands work on the region, including
  ~center-region~, ~count-lines-region~, ~kill-region~, and
  ~print-region~.

- The ~save-excursion~ special form saves the location point and
  restore this point and restore this position after the code within
  the body of the special form is evaluated by the Lisp interpreter.
  Thus if point were in the beginning of a piece of text and some code
  moved point to the he end of the buffer, the ~save-excursion~ would
  put point back to where it was before, after the expression in the
  body of the function were evaluated.

- In Emacs, a function frequently moves point as part of its internal
  workings even though a user would not expect this.  For example,
  ~count-lines-region~ moves point.  To prevent the user from being
  bothered by jumps that are both unexpected and (from the user's
  point of view) unnecessary, ~save-excursion~ is often used to keep
  point in the location expected by the user.  The use of
  ~save-excursion- is *good housekeeping*.

- To make sure the house stays clean, ~save-excursion~ restores the
  value of point even if something goes wrong in the code inside of it
  (or, to be more precise and to use the proper jargon, "in case of
  abnormal exit").  This is feature is very helpful.

- In addition to recording the value of point, ~save-excursion~ keeps
  track of the current buffer, and restore it, too.  This means you
  can write code that will change the buffer and have ~save-excursion~
  switch you back to the original buffer.  This is how
  ~save-excursion~ is used in ~append-to-buffer~.  (See The Definition
  of ~append-to-buffer~).

*** Template for a ~save-excursion~ Expression

- The template for a ~save-excursion~ is simple:

  #+begin_src emacs-lisp
    (save-excursion
      body...)
  #+end_src

- The body of the function is one or more expressions that will be
  evaluated in sequence by the Lisp interpreter.  If there is more
  than one expression in the body, the value of the last one will be
  returned as the value of the ~save-excursion~ function.  The order
  expressions in the body are evaluated only for their side effects;
  and ~save-excursion~ itself is used only for its side effect (which
  is restoring the position of point).

- In more detail, the template for a ~save-excursion~ expression looks like this:

  #+begin_src emacs-lisp
    (save-excursion
      first-expression-in-body
      secon-expression-in-body
      third-expression-in-body
      ...
      last-expression-in-body)
  #+end_src

- An expression, of course, may be a symbol on its own or a list.

- In Emacs Lisp code, a ~save-excursion~ expression often occurs
  within the body of a ~let~ expression. It looks like this:

  #+begin_src emacs-lisp
    (let varlist
      (save-excursion
        body..))
  #+end_src

** Review

- In the last few chapter we have introduced a macro and a fair number
  of function and special forms.  Here they are describe in brief,
  along with a few similar function that have not been mentioned yet.

- ~eval-last-sexp~

  Evaluates the last symbolic expression before the current location
  of point.  The value is printed in the echo area unless the function
  is invoked with an argument; in the case, the output is printed in
  the current buffer.  This command is normally bound to ~C-x C-e~.

- ~defun~

  Define function.  This macro has up to five parts: /the name/, /a
  template/ for arguments that will be passed to the function,
  /documentation/, an optional /interactive declaration/, and the
  /body/ of the definition.

  For example, in Emacs the function definition of
  ~dired-unmark-all-marks~ is as follows.

  #+begin_src emacs-lisp
    (defun dired-unmark-all-marks ()
      "Remove all marks from all files in the Dired buffer."
      (interactive)
      (dired-unmark-all-files ?\r))
  #+end_src

- ~interactive~

  Declare to the interpreter that the function can be used
  interactively.  This special form my be followed by a string with
  one or more parts that pass in the information to the arguments of
  the function, in sequence.  These parts may be also tell the
  interpreter to prompt for information.  Parts of the string are
  separated by newlines, ~'\n'~.

  Common code characters are:

  - ~b~

     The name of existing buffer

  - ~f~

     The name of existing file

  - ~p~

     The numeric prefix argument. (Note that this ~p~ is lower
    case.)

  - ~r~

    Point and the mark, as two arguments, smallest first.  This is
    the only code letter that specified two successive argument rather
    than one.

- ~let~

  Declare that a list of variables is for use within the body of the
  ~let~ and give them an initial value, either ~nil~ or a specified
  value; then evaluate the rest of the expression in the body of the
  ~let~ and return the value of the last one.  Inside the body of the
  ~let~, the Lisp interpreter does not see the values of the variables
  of the same names that are bound outside of the ~let~.

  For example,

  #+begin_src emacs-lisp
    (let ((foo (buffer-name))
          (bar (buffer-size)))
      (message
       "This buffer is %s and has %d characters."
       foo bar))
  #+end_src

- ~save-excursion~

  Record the values of point and the current buffer before evaluating
  the body of this special form.  Restore the value of point and
  buffer afterward.

  For example,

  #+begin_src emacs-lisp
    (message "We are %d characters into this buffer."
             (- (point)
                (save-excursion
                  (goto-char (point-min)) (point))))
  #+end_src

- ~if~

  Evaluate the first argument to the function; if is true, evaluate
  the second argument; else evaluate the third argument, if there is
  one.

  The ~if~ special form is called a /conditional/.  There are other
  conditional in Emacs Lisp, but ~if~ is perhaps the most commonly
  used.

  for example,

  #+begin_src emacs-lisp
    (if (= 27 emacs-major-version)
        (message "This is version 27 Emacs")
      (message "This is not version 27 Emacs"))
  #+end_src

- ~<~, ~>~, ~<=~, ~>=~

  The ~<~ function test whether its first argument is smaller than its
  second argument.  A corresponding function, ~>~, tests whether the
  first argument is greater than the second.  Likewise ~<=~ test
  whether the first argument is less than or equal to the second and
  ~>=~ test whether the first argument is greater than or equal to the
  second .  In all cases, both arguments must be /numbers/ or
  /markers/ (markers indicate position in buffers).

- ~=~

  The ~=~ function test whether two arguments, both numbers or
  markers, are equal.

- ~equal~, ~eq~

  Test whether two objects are the same. ~equal~ uses one meaning of
  the word "same" and ~eq~ uses another; ~equal~ returns true if the
  two objects have a similar structure and contents, such as two
  copies of the same book.  On the other hand, ~eq~, returns true if
  both arguments are actually the same /object/.

- ~string<~, ~string-lessp~, ~string=~, ~string-equal~

  The ~string-lessp~ function tests whether its first arguments is
  smaller than the second argument.  A shorter, alternative name for
  the same function (a ~defalias~) is ~string<~.

  The arguments to ~string-lessp~ must be /strings/ or /symbols/; the
  ordering is lexicographic, so case is significant.  The print names
  of symbols are used instead of the symbol themselves.

  An empty string, ~""~, a string with no characters in it, is smaller
  than any string of characters.

- ~message~

  Print a message in the echo area. The first argument is string that
  can contain '~%s~', '~$d~', or '~%c~' to print the value of
  arguments that follow the string.  The argument used by '~%s~' must
  be a string or a symbol; the argument '~%d~' must be a number.  The
  argument '~%c~' must be an ASCII code number; it will be printed as
  the character with that ASCII code.  (Various other %-sequence have
  not been mentioned.)

- ~setq~, ~set~

  The ~setq~ special form sets the value of its first argument to the
  value of the second argument.  The first argument is automatically
  quoted by ~setq~.  It does the same for succeeding pairs of
  arguments.  An other function, ~set~, takes only two arguments and
  evaluates both of them before setting the value returned by its
  first argument to the value returned by its second argument.

- ~buffer-name~

  Without an argument, return the name of the buffer, as a string.

- ~buffer-file-name~

  Without an argument, return the name of the buffer, as a string.

- ~current-buffer~

  Return the buffer in which Emacs is active; it may not the buffer is
  visible on the screen

- ~other-buffer~

  Return the most recently selected buffer (other than the buffer
  passed to ~other-buffer~ as an argument and other than the current
  buffer).

- ~switch-buffer~

  Select a buffer for Emacs to be active in and display in the current
  window so users can look at it.  Usually bound to ~C-x C-b~

- ~set-buffer~

  Switch Emacs's attention to a buffer on which programs will run.
  Don't alter what the window is showing.

- ~buffer-size~

  Return the number of character in the current buffer.

- ~point~

  Return the value of the current position of the cursor, as an
  integer counting the number of characters from the beginning of the
  buffer.

- ~point-min~

  Return the minimum permissible value of point in the current buffer.
  This is 1, unless narrowing is in effect.

- ~point-max~

  Return the value of the maximum permissible value of point in the
  current buffer.  This is the end of the buffer, unless narrowing is
  in effect.


* A few Buffer-Related Functions

- In This chapter we study in detail several of the function used in
  GNU Emacs.  This is called a "walk-through".  These functions are
  used as example of Lisp code, but are not imaginary examples; with
  the exception of the first, simplified function definition, these
  functions show the actual code used in GNU Emacs.  You can learn a
  great deal from these definitions.

- These function described here are all related to *buffers*. Later,
  we will study other function.

  - [[Finding More Information][Finding More]]        How to find more information.

  - [[A Simplified ~beginning-of-buffer~ Definition][simplified-beginning-of-buffer]]        Show ~goto-char~, ~point-min~,and ~push-mark~.

  - [[The Definition of ~mark-whole-buffer~][mark-whole-buffer]]             Almost the same as ~beginning-of-buffer~.

  - [[the definition of ~append-to-buffer~][append-to-buffer]]              Uses ~save-excursion~ and ~insert-buffer-substring~.

  -[[Review][Buffer Related Review]]  Review

** Finding More Information

- In this walk-through, I will describe each new function as we come
  to it, sometimes in detail and sometimes briefly.  If you are
  interested, you can get the full documentation of any Emacs Lisp
  function at any time by typing ~C-h f~ and then the name of the
  function (and then ~RET~).  Similarly, you can get the full
  documentation for a variable by typing ~C-h v~ and then the name of
  the variable (and then ~RET~).

- Also, ~describe-function~ will tell you the location of the function location.

- Put point into the name of the file that contains the function and
  press the ~RET~ key.  In this case, ~RET~ means ~push-button~ rather
  than "return" or "enter".  Emacs will take you directly to the
  function definition.

- More generally, if you want to see a function in it s original
  source file, you can use the ~xref-find-definitions~ function to
  jump to it.  ~xref-find-definition~ works with a wide variety of
  languages, not just Lisp, and C, and it works with non-programming
  text as well.  For example, ~xref-find-definitions~ will jump to the
  various nodes in the Tex info source file f this document (provided
  that you've run the ~etags~ utility to record all the nodes in the
  manual that come with Emacs; see Create Tags Table in the GNU Emacs
  Manual).

- To use the ~xref-find-definitions~ command, type ~M-.~ (i.e., press
  the period key while holding down the ~META~ key, or else type the
  ~ESC~ key and then type the period key), and then, at the prompt,
  type in the name of the function whose source you want to see, such
  as ~mark-whole-buffer~, and then type ~RET~.  (If the command
  doesn't prompt, invoke it with an argument: ~C-u M-.~; see
  Interactive Options.)

  Emacs will switch buffers and display the source code for the
  function on your screen (If instead of showing the source code for a
  Lisp function, Emacs ask you which tags table to visit, invoke ~M-.~
  from a buffer whose major mode is Emacs Lisp or Lisp interaction.).

  To switch back to your current buffer, type ~M-~, or ~C-c b RET~.
  (On some keyboards, the ~META~ key is labeled ~ALT~.).

- Incidentally, the files that contain Lisp code are conventionally
  called /libraries/.  The metaphor is derived from that if
  specialized library, such as a law library or an engineering
  library, rather than a general library.

  Each library, or file, contains functions that relate to a
  particular topic or activity, such as ~abbrev.el~ for handling
  abbreviations and other typing shortcuts, and ~help.el~ for help.
  (Sometimes several libraries provide code for a single activity, as
  the various ~remail...~ files provide code for reading electronic
  mail.)  In the GNU Emacs Manual, you will see sentences such as "The
  ~C-h p~ commands lets you search the standard Emacs Lisp libraries
  by topic keywords."

** A Simplified ~beginning-of-buffer~ Definition

- The ~beginning-of-buffer~ command is a good function to start with
  since you are likely to be familiar with it and it is easy to
  understand.  Used as an interactive command, ~beginning-of-buffer~
  moves the cursor to the beginning of he buffer command is a good
  function to start with since you are likely to be familiar with it
  and it is easy to understand.  Used as an interactive command,
  ~beginning-of-buffer~ moves the cursor to the beginning of the
  buffer, leaving the mark at the previous position.  It is generally
  bound to ~M-<~.

- In this section, we will discuss a shortened version of the function
  that shows how it is most frequently used.  This shortened function
  work as written, but it does not contain the code for a complex
  option.  In another section, we will describe the entire
  function. (See Complete Definition of ~beginning-of-buffer~)

- Before looking at the code, let's consider what the function
  definition has to contain: it must include an expression that makes
  the function interactive so it can be called by typing ~M-x
  beginning-of-buffer~ or by typing a coached such as ~M-<~; it must
  include code to leave a mark at the original position in the buffer,
  and it must include code to move the cursor to the beginning of the
  buffer.

- Here is the complete text of the shortened version of the function

  #+begin_src emacs-lisp
    (defun simplified-beginning-of-buffer ()
      "Move point to the beginning of the buffer;
              leave mark at previous position."
      (interactive)
      (push-mark)
      (goto-char (point-min)))
  #+end_src

  - Like all the function definitions, this definition has /five/ parts following the macro ~defun~:

    - The name: in this example, ~simplified-beginning-of-buffer~.

    - A list of arguments; in this example, an empty list, ~()~,

    - The documentation string.

    - The interactive expression

    - The body

- In this function definition, the argument list is empty; this means
  that this function does not require any arguments.  (When we look at
  the definition for the complete function, we will see that it may be
  passed an optional argument.)

- The body of the function consist of the two lines:

  #+begin_src emacs-lisp
    (push-mark)
    (goto-char (point-min))
  #+end_src

  - The first of these line is the expression, ~(push-mark)~.  When
    this expression is evaluated by the Lisp interpreter, it sets a
    mark at the current position of the cursor, wherever that may be.
    The position of this mark is saved in the mark ring.

  - The next line is ~(goto-char (point-min))~.  This expression jumps
    the cursor to the minimum point in the buffer, that is, to the
    beginning of the buffer (or to the beginning of accessible portion
    of the buffer if it is narrowed.  See Narrowing and Widening.)

  - The ~push-mak~ command sets a mark at the place where the cursor
    was located before it was moved to the beginning of the buffer by
    the ~(goto-char (point-min))~ expression.  Consequently, you can,
    if you wish, go back to where you were originally by typing ~C-x
    C-x~.

  - That is all there is to the function definition!.

- When you are reading code such as this and come upon an unfamiliar
  function, such as ~goto-char~, you can find out what it does by
  using the ~describe-function~ command.  To use this command, type
  ~C-h f~ and then type in the name of the function and press ~RET~.
  The ~describe-function~ command will print the function's
  documentation string in a ~*Help*~ window.  For example, the
  documentation for ~goto-char~ is:

  #+begin_src emacs-lisp
    Set point to Position, a number or marker.
    Beginning of buffer is position (Point-min), end is (point-max).
  #+end_src

  - The function's one argument is the desired position.

- The prompt for ~describe-function~ will offer you the symbol under
  or preceding the cursor, so you can typing by positioning the cursor
  right after the function and then type ~C-h f RET~.

- The ~end-of-buffer~ function definition is written in the same way
  as the ~beginning-of-buffer~ definition except that the body of the
  function contains the expression ~(goto-char (point-max))~ in place
  of ~(goto-char (point-min))~.
** The Definition of ~mark-whole-buffer~

- The ~mark-whole-buffer~ function is no harder to understand than the
  ~simplified-beginning-of-buffer~ function.  In this case, however,
  we will look at the complete function, not a shortened version.

- The ~mark-whole-buffer~ function is not as commonly used as the
  ~beginning-of-buffer~ function, but is useful nonetheless; it marks
  whole buffer as a region by putting at the beginning and a mark at
  the end of the buffer. It is generally bound to ~C-x h~.

  - [[An overview of ~mark-whole-buffer~][mark-whole-buffer-overview]]

  - [[Body of ~mark-whole-buffer~][Body of mark-whole-buffer]]

*** An overview of ~mark-whole-buffer~

- In GNU Emacs 22, the code for the complete function looks like this:

  #+begin_src emacs-lisp
    (defun mark-whole-buffer ()
      "Put point at the beginning and mark at end of buffer.
    You probably should not use this function in Lisp programs;
    it is usually a mistake for a Lisp function touse any subroutine
    that mark uses or sets the mark."
      (interactive)
      (push-mark (point))
      (push-mark (point-max) nil t)
      (goto-char (point-min)))
  #+end_src

- Like other functions, the ~mark-whole-buffer~ function fits into the
  template of a function definition. The template looks like this:

  #+begin_src emacs-lisp
    (defun name-of-function (argument-list)
      "documentation..."
      (interactive-expression...)
      body)
  #+end_src

- Here is how the function works: the name of the function is
  ~mark-whole-buffer~; it is followed by an empty argument list,
  '~()~', which means that the function does not require
  arguments. The documentation comes next.

- The next line is an ~(interactive)~ expression that tells Emacs that
  the function will be used interactively.  These details are similar
  to the ~simplified-begining-of-buffer~ function described in the
  previous section.

*** Body of ~mark-whole-buffer~

- The body of the ~mark-whole-buffer~ function consist of three lines of code:

  #+begin_src emacs-lisp
    (push-mark (point))
    (push-mark (point-max) nil t)
    (goto-char (point-min))
  #+end_src

- The first of these line is the expression, ~(push-mark (point))~.

- The line does not exactly the same job as the first line of the body
  of the ~simplified-beginning-of-buffer~ function, which is written
  ~(push-mark)~.  In both cases, the Lisp interpreter sets a /mark/ at
  the current position of the cursor.

- I don't know why the expression in ~mark-whole-buffer~ is written
  ~(push-mark (point))~ and the expression in ~beginning-of-buffer~ is
  written ~(push-mark)~.  Perhaps whoever wrote the code did not know
  that the argument for ~push-mark~ are optional and that if
  ~push-mark~ is not passed an argument, the function automatically
  sets mark at the location of point by default.  Or perhaps the
  expression was written so as to parallel the structure of the next
  line.  In any case, the line cause Emacs to determine the position
  of point and set a mark there.

- In earlier version of GNU Emacs, the next line of
  ~mark-whole-buffer~ was ~(push-mark (point-max))~.  This expression
  sets a mark at the point in the buffer that has the highest number.
  This will be the end of the buffer (or, if the buffer is narrowed,
  the end of the accessible portion of the buffer. See Narrowing and
  Widening, for more about narrowing.).  After this mark has been set,
  the previous mark, the one set at point, is no longer set, but Emacs
  remembers its position, just all other recent marks are always
  remembered.  This means that you can, if you wish, go back to that
  position by typing ~C-u C-SPC~ twice.

 - In GNU Emacs 22, the ~(point-max)~ is slightly more
   complicated. The line reads

   #+begin_src emacs-lisp
     (push-mark (point-max) nil t)
   #+end_src

- The expression works nearly the same as before.  It sets a mark at
  the highest numbered place in the buffer that it can.  However, in
  this version, ~push-mark~ has two additional arguments.  The second
  argument to ~push-mark~ is ~nil~.  This tells the function it
  /should/ display a message that says "Mark set" when it pushes the
  mark.  The third arguments is ~t~.  This tells ~push-mark~ to
  activate the mark when Transient Mark mode is turned on.  Transient
  Mode highlights the currently active region.  It is often turned
  off.

- Finally, the last line of the function ~(goto-char (point-min))~.
  This written exactly the same way as it is written in
  ~beginning-of-buffer~.  The expression moves the cursor to the
  minimum point in the buffer, that is, to the beginning of the buffer
  (or to the beginning of the accessible portion of the buffer).  As a
  result of this, point is placed at the beginning of the buffer and
  mark is set at the end of the buffer.  The whole buffer is,
  therefore, the region.

** the definition of ~append-to-buffer~

- The ~append-to-buffer~ command is more complex than the
  ~mark-whole-buffer~ command.  What it does is copy the region (that
  is, the part of the buffer between point and mark) from the current
  to a specified buffer.

  - [[An overview of ~append-to-buffer~][append-to-buffer overview]]

  - [[The ~append-to-buffer~ Interactive Expression][append interactive]]            A two part interactive expression

  - [[The Body of ~append-to-buffer~][append-to-buffer body]]     Incorporates a ~let~ expression

  - [[~save-excursion~ in ~append_to-buffer~][append save-excursion]]     How the ~save-excursion~ works

*** An overview of ~append-to-buffer~

- The ~append-to-buffer~ commands uses the ~insert-buffer-substring~
  function to copy the region.  ~insert-buffer-substring~ is described
  by its name: it takes substring from a buffer, and insert it into
  another buffer.

- Most of ~append-to-buffer~ is concerned with setting up the
  conditions for ~insert-buffer-inserting~ to work: the code must
  specify both the buffer to which the text will go, the window it
  comes from and goes to, and the region that will be copied.

- Here is the complete text of the function

  #+begin_src emacs-lisp
    (defun append-to-buffer (buffer start end)
      "Append to specified buffer the text of the region.
    It is inserted into that buffer before its point.

    When calling from a program, give three argument:
    BUFFER (or buffer name), START and END.
    START and END specify the portion of the current buffer to be copied."
      (interactive
       (list (read-buffer "Append to buffer: " (other-buffer
                                                (current-buffer) t))
             (region-beginning) (region-end)))
       (let (oldbuf (current-buffer)))
       (save-excursion
         (let* (append-to (get-buffer-create buffer))
           (windows (get-buffer-window-list append-to t t))
           point)

         (set-buffer append-to)
         (setq point (point))
         (barf-is-buffer-read-only)
         (insert-buffer-substring oldbuf start end)
         (dolist (window windows)
           (when (= (window-point window) point)
                (set-window-point window (point))))))
  #+end_src

- The function can be understood by looking at it as a series
  filled-in templates.

- The outermost template is for the function.  In this function, it
  looks like this (which several slots filled in):

  #+begin_src emacs-lisp
    (defun append-to-buffer (buffer start end)
      "documentation..."
      (interactive ...)
      body...)
  #+end_src

- The first line of the function includes its name and three
  arguments.  The arguments are the ~buffer~ to which the text will be
  copied, and the ~start~ and ~end~ of the region in the current
  buffer that will be copied.

- The next part of the function is the documentation, which is clear
  and complete.  As is conventional, the three argument are written in
  /upper case/ so you will notice them easily.  Even better, they are
  described in the same order as in argument list.

- Note that the documentation distinguishes between a buffer and its
  name.  (The function can be handler either.)

*** The ~append-to-buffer~ Interactive Expression

- Since the ~append-to-buffer~ function will be used interactively,
  the function must have an ~interactive~ expression.  (For a review
  ~interactive~. see Making Function Interactive.)  The expression
  reads as follows:

  #+begin_src emacs-lisp
    (interactive
     (list (read-buffer
            "Append to buffer: "
            (other-buffer (current-buffer) t))
           (region-beginning)
           (region-end)))
  #+end_src

- This expression is not one with letters standing fort parts, as
  described earlier.  Instead, it starts a list with these parts:

- The first part of the list is an expression to read the name of the
  buffer and return it as a string.  That is ~read-buffer~.  The
  function requires a prompt as its first argument, '~"Append to
  buffer: "~'.  It second argument tells the command what value to
  provide if you don't specific anything.

- In this case that second argument is an expression containing the
  function ~other-buffer~, an exception, and a '~t~', standing for
  true.

- The fist argument to ~other-buffer~, the exception, is yet another
  function, ~current-buffer~.  That is not going to be returned.  The
  second argument is the symbol for true, ~t~.  That tells
  ~other-buffer~ that it may show visible buffers (except in this
  case, it will not show the current buffer, which makes sense).

- The expression looks like this:

  #+begin_src emacs-lisp
    (other-buffer (current-buffer) t)
  #+end_src

- The second and third argument to the ~list~ expression are
  ~(region-beginning)~ and ~(region-end)~.  These two functions
  specify the beginning and end of the text to be appended.

- Originally, the command used the letters '~B~', and '~r~'. The whole
  ~interactive~ expression looked like this:

  #+begin_src emacs-lisp
    (interactive "BAppend to buffer: \nr")
  #+end_src

- But when that was done, the default value of the buffer switched to
  was invisible.  That was not wanted.

- The prompt was separated from the second argument wit a newline,
  '~\n~'.  It was followed by an '~r~' that told Emacs to bind the two
  arguments that follow the symbol ~buffer~ in the function's argument
  list (that is, ~start~ and ~end~) to the values of /point/ and
  /mark/.  That argument work fine.

*** The Body of ~append-to-buffer~

- The body of the ~append-to-buffer~ function begin with ~let~.

- As we have seen before (see ~let~), the purpose of a ~let~
  expression is to create and give initial value to one or more
  variables that will only be used within the body of the ~let~.  This
  meas that such a variable will not be confused with any variable of
  the same time outside the ~let~ expression.

- We can see how the ~let~ expression fits into the function as a
  whole by showing a template for ~append-to-buffer~ with the ~let~
  expression in outline:

  #+begin_src emacs-lisp
    (defun append-to-buffer (buffer start end)
      "documentaion..."
      (interactive ...)
      (let ((variable value))
        body...)
  #+end_src

- The ~let~ expression has three elements:

  1. The symbol ~let~;

  2. A varlist containing, in this case, a single two-element list,
     ~(variable value)~;

  3. The body of the ~let~ expression.

- In the ~append-to-buffer~ function, the varlist looks like this:

  #+begin_src emacs-lisp
    (oldbuf (current-buffer))
  #+end_src

- In this part of the ~let~ expression, he one variable, ~oldbuf~, is
  bound to the value returned by the ~(current-buffer)~ expression.
  The variable, ~oldbuf~, is used to keep track of the buffer in which
  you are working and from which you will copy.

- The element or elements of a varlist are surround by a set of
  parentheses so the Lisp interpreter can distinguish the varlist from
  the body of the ~let~.  As a consequence, the two-element list
  within the varlist is surround by a circumscribing set of
  parentheses.  The line looks like this:

  #+begin_src emacs-lisp
    (let ((oldbuf (current-buffer)))
      ... )
  #+end_src

- The two parentheses before ~oldbuf~ might surprise you if you did
  not realize that the first parenthesis before ~oldbuf~ marks the
  boundary of the varlist and the second parenthesis mark the
  beginning if the two-element list, ~(oldbuf (current-buffer))~
*** ~save-excursion~ in ~append_to-buffer~

- The body of the ~let~ expression in ~append-to-buffer~ consist of a
  ~save-excursion~ expression.

- The ~save-excursion~ function saves the location point, and restores
  it to that position after the expression in the body of the
  ~save-excursion~ complete execution.  In addition, ~save-excursion~
  keeps track of the original buffer, and restore it. This is how
  ~save-excursion~ is *used* in ~append-to-buffer~.

- Incidentally, it is worth noting here that a Lisp function is
  normally formatted so that everything that is enclosed in a
  multi-line spread is indented more to the right than the first
  symbol.  In this function definition, the ~let~ is indented more
  than the ~defun~, and the ~save-excursion~ is indented more than the
  ~let~, like this:

  #+begin_src emacs-lisp
    (defun ...
      ...
      ...
      (let ...
        (save-excursion
          ...
  #+end_src

- This formatting convention makes it easy to see that the lines in
  the body of the ~save-excursion~ are enclosed by the parentheses
  associated with ~save-excursion~, just as the ~save-excursion~
  itself is enclosed by the parentheses associated with the ~let~:

  #+begin_src emacs-lisp
    (let ((oldbuf (current-buffer)))
      (save-excursion
        ...
        (set-buffer ...)
        (insert-buffer-substring oldbuf start end)
        ..))
  #+end_src

- The use of the ~save-excursion~ function can be viewed as process of
  filling in the slots of a template:

  #+begin_src emacs-lisp
    (save-excursion
      first-expression-in-body
      second-expression-in-body
      ...
      last-expression-in-body)
  #+end_src

- In this function, the body of ~save-excursion~ contains only one
  expression, the ~let*~ expression.  You know about a ~let~ function.
  The ~let*~ function is different.  It has '~*~' in its name.  It
  enables Emacs to set each variable in its varlist in *sequence*, one
  after another.

- Its critical feature is that variables later in the varlist can make
  use the value to which Emacs set variables earlier in the
  varlist. See [[][The ~let~ expression]].

- In the old days, the ~set-buffer~ expression was simply

  #+begin_src emacs-lisp
    (set-buffer (get-buffer-create buffer))
  #+end_src

  but now it is

  #+begin_src emacs-lisp
    (set-buffer append-to)
  #+end_src

- ~append-to~ is bound to ~(get-buffer-create buffer)~ earlier on in
  the ~let*~ expression.  That extra binding would not be necessary
  expect for that ~append-to~ is used later in the varlist as an
  argument to ~get-buffer-window-list~.

- The ~append-to-buffer~ function definition inserts text from the
  buffer in which you are currently to a named buffer.  It happens
  that ~insert-buffer-substrig~ does just the reverse--it copies text
  form another buffer to the current buffer-that is why the
  ~append-to-buffer~ definition start out with a ~let~ that binds the
  local symbol ~oldbuf~ to the value returned by ~current-buffer~.

- The ~insert-buffer-substring~ expression looks like this:

  #+begin_src emacs-lisp
    (let (bind-oldbuf-to-value-of-current-buffer)
      (save-excursion                   ; Keep track of buffer
        change-buffer
        insert-substring-from-oldbuf-into-buffer)

      change-back-to-original-buffer-when-finished
      let-the-loca-meaning-of-oldbuf-disappear-when-finshed

  #+end_src

- In summary, ~append-to-buffer~ works as follow: it saves the value
  of the current buffer in the variable called ~oldbuf~.  It gets the
  new buffer (creating one if need be) and switches Emacs's attention
  to it.  Using the value of ~oldbuf~, it inserts the region of text
  from the old buffer into the new buffer: and then using
  ~save-excursion~, it brings you back to your original buffer.

- In looking at ~append-to-buffer~, you can have explored a fairly
  complex function.  It show how to use ~let~ and ~save-excursion~,
  and how to change to and come back from another buffer.  Many
  function definition use ~let~, ~save-excursion~, and ~set-buffer~
  this way.

** Review

Here is a brief summary of the various functions discussed in this chapter.

- ~describe-function~, ~describe-variable~

  Print the documentation for a function or variable. Conventionally
  bound to ~C-h f~ and ~C-h v~:w

- ~xref-find-definition~

  Find the file containing the source for a function or variable and
  switch buffer to it, positioning point at the beginning of the item.
  Conventionally bound to ~M-.~ (that's a period following the ~META~
  key).

- ~save-excursion~

  Save the location of point, and restore its value after the
  arguments to ~save-excursion~ have been evaluated.  Also, remember
  the current buffer and return to it.

- ~push-mark~

  Set mark at a location and record the value of the previous mark on
  the /mark ring/.  The mark is a location in the buffer that will
  keeps its relative position even if text is added to or removed from
  the buffer.

- ~goto-char~

  Set point to the location specified by the value of the argument,
  which can be a number, a marker, or an expression that returns the
  number of a position, such as ~(point-min)~.

- ~insert-buffer-substring~

  Copy a region of text from buffer that is passed to the function as
  an argument and insert the region into the current buffer.

- ~mark-whole-buffer~

  Mark the whole buffer as a region. Normally bound to ~C-x h~

- ~set-buffer~ Switch the attention of Emacs to another buffer, but do
  not change the window being displayed.  Used when the program rather
  than a human is to work on a different buffer.

- ~get-buffer-create~, ~get-buffer~ Find a named buffer or create one
  if a buffer of that name does not exist.  The ~get-buffer~ function
  returns ~nil~ if the named buffer does not exists.


* A Few More Complex Functions

- In this chapter, we build on what we have learned in previous
  chapters by looking at more complex functions.  The ~copy-to-buffer~
  function illustrates use of two ~save-excursion~ expressions in one
  definition, while the ~insert-buffer~ function illustrates use of an
  asterisk in an ~interactive~ expression, use of ~or~, and the
  important distinction between a name and the object to which the
  name refers,

    - [[The Definition of ~copy-to-buffer~][copy-to-buffer]]             With ~set-buffer~, ~get-buffer-create~.

    - [[The definition of ~insert-buffer~][insert-buffer]]               Read-only, and with ~or~.

    - [[Complete Definition of ~beginning-of-buffer~][beginning-of-buffer]]   Shows ~goto-char~, ~point-min~, and ~Push-mark~.

    - [[Review][Second buffer Related Review]]

** The Definition of ~copy-to-buffer~

- After understanding how ~append-to-buffer~ to works, it easy to
  understand ~copy-to-buffer~.  This function copies text into a
  buffer, but instead of adding to the second buffer, it replaces all
  the previous text in the second buffer.

- The body of ~copy-to-buffer~ looks like this,

  #+begin_src emacs-lisp
    ...
    (interactive "BCopy to buffer: \nr")
    (let (oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (barf-if-buffer-read-only)
      (erase-buffer)
      (save-excursion
        (insert-buffer-substrinh oldbuf start end)))
  #+end_src

  - The ~copy-to-buffer~ function has a simpler ~interactive~
    expression than ~append-to-buffer~.

  - The definition then says

    #+begin_src emacs-lisp
      (with-current-buffer (get-buffser-create buffer) ...
    #+end_src

   - First, look at the earliest inner expression; that is evaluated
     first. That expression start with ~get-buffer-create buffer~.
     The function tells computer to use the buffer with the name
     specified as the one to which you are copying, or if such a
     buffer does not exist, to create it.  Then, the
     ~with-current-buffer~ function evaluates its body with that
     buffer temporarily current.

   - This demonstrates another way to shift the computer's attention
     but not the user's.  The ~append-to-buffer~ function showed how
     to do the same with ~save-excursion~ and ~set-buffer~,
     ~with-current~buffer~ is a newer, and arguably easier, mechanism.

   - The ~barf-if-buffer-read-only~ function sends you an error
     message saying the buffer is read-only if you cannot modify it.

   - The next line has the ~erase-buffer~ function as its sole
     contents.  That function erase the buffer.

   - Finally, the last tow line contain the ~save-excursion~
     expression with ~insert-buffer-substring~ as its body.  The
     ~insert-buffer-substring~ expression copies the text from the
     buffer you are in (and you have not seen the computer shift its
     attention, so you don't know that the buffer is now called
     ~oldbuf~).

   - Incidentally, this is what is meant by "replacement".  To replace
     text, Emacs erase the previous text and insert new text.

   - In outline, the body of ~copy-to-buffer~ looks like this:

     #+begin_src emacs-lisp
       (let (bind-oldbuf-to-value-of-current-buffer)
         (with-the-buffer-you-are-copying-to
          (but-do-not-erase-or-copy-to-a-read-only-buffer)
          (erase-buffer)
          (save-excursion
            insert-substring-from-oldbuf-into-buffer)
     #+end_src

** The definition of ~insert-buffer~

- ~insert-buffer~ is yet another /buffer-related function/.  This
  command copies another buffer /into/ the current buffer.  It is the
  /reverse/ of ~append-to-buffer~ or ~copy-to-buffer~, since they copy
  a region of text /from/ the current buffer to another buffer.

- Here is discussion based on the original code.  The code was
  simplified in 2003 and is harder to understand.

- See [[][New Body for ~insert-buffer~]], to see a discussion of the
  new body.

- In addition, this code illustrates the use of ~interactive~ with a
  buffer that might be /read-only/ and the important distinction
  between the name of an object and the object actually referred to.

- [[The Code for ~insert-code~][insert-buffer code]]

- [[The Interactive Expression in ~insert-buffer~][insert-buffer interactive]]              When you can read, but not write.

- [[The Body of the ~insert~buffer~ Function][insert-buffer body]]      The body has an ~or~ and a ~let~.

- [[~insert-buffer- with an ~if~ Instead of an ~or~][if & or]]                    Using an ~if~ instead of an ~or~.

- [[The ~or~ in the Body][Insert or]]                          How the ~or~ expression works.

- [[The ~let~ Expression in ~insert-buffer~][Insert let]]     Two ~save-excursion~ expression.

- [[New Body for ~insert-buffer][New insert-buffer]]

*** The Code for ~insert-code~

- Here is the earlier code:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "Insert after point the contents of Buffer.
        Puts mark after the inserted text.
        BUFFER may be a buffer or a buffer name."
      (interactive "*bInsert buffer: ")

      (or (bufferp buffer)
          (setq buffer (get-buffer buffer)))
      (let (start end newmark)
        (save-excursion
          (save-excursion
            (set-buffer buffer)
            (setq start (point-min) end (point-max)))
          (insert-buffer-substring buffer start end)
          (setq newwark (point)))
        (push-mark newmark)))
  #+end_src

- As with other function definitions, you can use a template to see an
  outline of the function:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "documentation.."
      (interactive "*bInsert buffer: ")
      body..)
  #+end_src

*** The Interactive Expression in ~insert-buffer~

- In ~insert-buffer~, the argument to the ~interactive~ declaration
  has two parts, an asterisk, '~*~', and '~bInsert buffer: "~'.

  - [[A Read-only Buffer][Read-only buffer]]         When a buffer cannot be modified.

  - [['~b~' in an Interactive Expression][b for interactive]]     An existing buffer or else its name.

**** A Read-only Buffer

- The asterisk is for the situation when the current buffer is
  read-only buffer--a buffer that cannot be modified.  If
  ~insert-buffer~ is called when the current buffer is read-only, a
  message to this effect is printed in the echo area and the terminal
  may beep or blink at you; you will not be permitted to insert
  anything into current buffer.  The asterisk does not need to be
  followed by a newline to separate it from the next argument.

**** '~b~' in an Interactive Expression

- The body of the ~insert-buffer~ function has two major parts: an
  ~or~ expression and a ~let~ expression.  The purpose of the ~or~
  expression is to ensure that the argument ~buffer~ is bound to a
  buffer and not just the name of a buffer.  The body of the ~let~
  expression contains the code which copies the other buffer into the
  current buffer.

- In outline, the two expressions fit into the ~insert-buffer~
  function like this:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "documentation.."
      (interactive "*bInsert buffer: ")
      (or ...
          ...
          (let (varlist)
            body-of-let... )
  #+end_src

- To understand how the ~or~ expression ensures that the argument
  ~buffer~ is bound to a buffer and not then name of a buffer, it
  first necessary to understand the ~or~ function.

- Before doing this, let me rewrite this part of the function using
  ~if~ so that you can see what is done in a manner that will be
  familiar.

*** The Body of the ~insert~buffer~ Function

- The body of the ~insert-buffer~ function has two major parts: an
  ~or~ and a ~let~ expression.  The purpose of the ~or~ expression is
  to unsure that the argument ~buffer~ is bound to a buffer and not
  just the name of the buffer.  The body of the ~let~ expression
  contains the code which copies the other buffer into the current
  buffer.

- In outline, the two expression fit into the ~insert-buffer~ function like this:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "documentation..."
      (interactive "*bInsert buffer: ")
      (or ...
          ...
          (let (varlist)
            body-of-let...)
  #+end_src

- To understand how the ~or~ expression ensures that the argument
  ~buffer~ is bound to a buffer and not the name of a buffer, it is
  first necessary to understand the ~or~ function.

- Before doing this, let me rewrite Thai part of the function using
  ~if~ so that oi can see what is done in a manner that will be
  familiar.

*** ~insert-buffer- with an ~if~ Instead of an ~or~

- The job to be done is to make sure the value of ~buffer~ is a buffer
  itself and not the name of a buffer.  If the value is the name, then
  the buffer itself must be got.A

- You can imagine yourself at a conference where an /usher/ is
  wandering around holding a list with your name on it and looking for
  you: the usher is bound to your name, not to you; but when the usher
  finds you and takes your arm, the usher becomes bound to you.

- In Lisp, you might describe this situation like this:

  #+begin_src emacs-lisp
    (if (not (holding-on-to-guest))
        (find-and-take-arm-of-guest))
  #+end_src

- We want to do the same thing with a buffer--if we do not have the
  buffer itself, we want to get it,

- Using a predicate called ~bufferp~ that tells us whether we have a
  buffer (rather than its name), we can write the code like this:

  #+begin_src emacs-lisp
    (if (not (bufferp buffer))                         ; if-part
        (setq buffer buffer (get-buffer buffer)))       ; then-part
  #+end_src

- Here, the true-or-false-test of the ~if~ expression is ~(mot
  (bufferp buffer))~; and the then-part is the expression ~(setq
  buffer (get-buffer buffer))~

- In the test, the function ~bufferp~ returns true if its argument is
  a buffer--but if its argument is the name of the buffer.  (The last
  character of the function name ~bufferp~ is the character '~p~', as
  we saw earlier, such use of '~p~' is a convention that indicates the
  function is a /predicate/, which is a term that means that the
  function will determine whether some property is true or false.  See
  [Using the Wrong Type Object as an Argument].

- The function ~not~ precedes the expression ~(bufferp buffer)~, so
  the true-or-false-test looks like this:

  #+begin_src emacs-lisp
    (not (bufferp buffer))
  #+end_src

- ~not~ is a function that returns true if its argument is false and
  false if its argument is true.  So if ~(bufferp buffer)~ returns
  true, the ~not~ expression returns false and vice versa.

- Using this test, the ~if~ expression works as follows: when the
  value of the variable ~buffer~ is actually a buffer than its name,
  the true~-or-false-test returns false and the ~if~ expression does
  not evaluate the then-part.  This is fine, since we do not need to
  do anything to the variable ~buffer~ if it really is a buffer.

- On the other hand, when the value of ~buffer~ is not a buffer
  itself, but the name of a buffer, the true-or-false-test returns
  true, and the then-part of the expression is evaluated.  In this
  case, the then-part is ~(setq buffer (get-buffer buffer))~.  This
  expression uses the ~get-buffer~ function to return an actual buffer
  itself, given its name.  The ~setq~ then sets the variable ~buffer~
  to the value of the buffer itself, replacing its previous value
  (which was the name of the buffer).

*** The ~or~ in the Body

- The purpose of the ~or~ expression in the ~insert-buffer~ function
  is to ensure that the argument ~buffer~ is bound to a buffer and not
  just to the name of a buffer.  The previous section shows how the
  job could have been done using ~if~ expression.  However, the
  ~insert-buffer~ function actually use ~or~.  To understand this, it
  is necessary to understand how ~or~ works.

- The ~or~ expression looks like this:

  #+begin_src emacs-lisp
    (or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
  #+end_src

- The first argument to ~or~ is the expression ~(bufferp buffer)~.
  This expression returns true (a non-~nil~ value) if the buffer is
  actually a buffer, and not just the name of a buffer.  In the ~or~
  expression returns this true value and does not evaluate the
  expression--and this is fine with use since we do not want to do
  anything to the value f ~buffer~ if it really is a buffer.

- On the other hand, if the value of ~(bufferp buffer)~ is ~nil~,
  which it will be if the value of ~buffer~ is the name of a buffer,
  the Lisp interpreter evaluates the next element of the ~or~
  expression.  This is the expression ~(setq buffer (get-buffer
  buffer))~.  This expression returns a non-~nil~ value, which is the
  value to which it sets the variable ~buffer~--and this value is a
  buffer itself, not the name of a buffer.

- The result of all this is that the symbol ~buffer~ is always bound
  to a buffer itself rather than to the name of a buffer.  All this is
  necessary because the ~set-buffer~ function in a following line
  only works with a buffer itself, not with the name to a buffer.

- Incidentally, using ~or~, the situation with the usher would be
  written like this:

 #+begin_src emacs-lisp
   (or (holding-on-to-guest) (find-and-take-arm-of-guest))
 #+end_src

*** The ~let~ Expression in ~insert-buffer~

- After ensuring that the variable ~buffer~ refers to a buffer itself
  and not just to the name of a buffer, the ~insert-buffer~ function
  continuous with a ~let~ expression.  This specifies three local
  variables of the same name in Emacs until the end of the ~let~.

- The body of the ~let~ contains two ~save-excursion~ expressions.
  First we will look at the inner ~save-excursion~ expression in
  detail.  The expression looks like this:

  #+begin_src emacs-lisp
    (save-excursion
      (inner-save-excursion-expression
       (go-to-new-buffer-and-set-start-and-end)
       (insert-buffer-substring buffer start end)
       (setq newmark (point)))
  #+end_src

- The ~insert-buffer-substring~ function copies the text /into/ the
  current buffer /from/ the region indicated by ~start~ and ~end~ in
  ~buffer~.  Since the whole of the second buffer lies between ~start~
  and ~end~, the whole of the second buffer is copied into the buffer
  you are editing.  Next, the value of point, which will be at the end
  of the inserted text, is recorded in the variable ~newmark~.

- After the body of the outer ~save-excursion~ is evaluated, point is
  relocated to its original place.

- However, it is convenient to locate a mark at the end of the newly
  inserted text and locate point at the beginning.  The ~newmar~
  variable records the end of the inserted text.  In the last line of
  the ~let~ expression, the ~(push-mark newmark)~ expression function
  sets a mark to this location.  (The previous location of the mark is
  still accessible; it is recorded on the mark ring, and you can go
  back to it with ~C-u SPC~.)  Meanwhile, point is located at the
  beginning of the inserted text, which is where it was before you
  called the insert function, the position of which was saved by the
  first ~save-excursion~.

- The whole ~let~ expression look like this:
  #+begin_src emacs-lisp
    (let (start end newmark)
      (save-excursion
        (save-excursion
          (set-buffer buffer)
          (setq start (point-min) end (point-max)))
        (insert-buffer-substring buffer start end)
        (setq newmark (point)))
      (push-mark newmark))
  #+end_src

- Like the ~append-to-buffer~ function, the ~insert-buffer~ function
  uses ~let~, ~save-excursion~ and ~set-buffer~.  In addition, the
  function illustrates one way to use ~or~.  All the function are
  building blocks that we will find and use again and again.

*** New Body for ~insert-buffer

- The body in the GNU Emacs 22 version is more confusing that the
  original.

-It consist of two expressions,

  #+begin_src emacs-lisp
    (push-mark
     (save-excursion
       (insert-buffer-substring (get-buffer buffer))
       (point)))

    nil
  #+end_src

  except, and this is what confuses novices, very important work is
  done inside the ~push-mark~ expression.

- The ~get-buffer~ function returns a buffer with the name provided.
  You will note that the function is /not/ called ~get-buffer-create~;
  it does not create a buffer if one does not already exist.  The
  buffer returned by ~get-buffer~, an existing buffer, is passed to
  ~insert-buffer-substring~, which inserts the whole of the buffer
  (since you did not specify anything else).

- The location into which the buffer is inserted is recorded by
  ~push-mark~.  Then the function returns ~nil~, the value of its last
  command.  Put another way, the ~insert-buffer~ function exists only
  to produce a side effect, inserting another buffer, not return any
  value.

** Complete Definition of ~beginning-of-buffer~

- The basic structure of the ~beginning-of-buffer~ function has
  already been discussed.  (See [[A Simplified ~beginning-of-buffer~
  Definiton]].)  This section describes the complex part of the
  definition.

- As previous described, when invoked without an argument,
  ~beginning-of-buffer~ moves the cursor to the beginning of the
  buffer (in truth, the beginning of the accessible portion of the
  buffer), leaving the mark at the previous position.  However, when
  the command is invoked with a number between one and ten, the
  function considered that number to be a fraction of the length of
  the buffer, measured in tenths and Emacs moves the cursor that
  fraction of the way from the beginning of the buffer.  Thus, you can
  either call this function with the key command ~M-<~, which will
  move the cursor to the beginning of the buffer, or with a key
  command such as ~C-u 7 M-<~ which will move the cursor at a point
  70% of the way through the buffer.  If a number bigger than then us
  used for the argument, it moves to the end of the buffer.

- The ~beginning-of-buffer~ function can be called with or without an
  argument.  The use of the argument is /optional/.

  - [[Optional Arguments][Optional Arguments]]

  - [[~beginning-of-buffer~ with an Argument][beginning-of-buffer opt arg]]       Example with optional argument.

  - [[][beginning-of-buffer complete]]

*** Optional Arguments

- Unless told otherwise, Lisp expects that a function an argument in
  its function definition will be called with a value for that
  argument.  If that does not happen, you get error and a message that
  says '~Wrong number of arguments~'.

- However, optional arguments are feature of Lisp: a particular
  /keyword/ is used to tell the Lisp interpreter that an argument is
  optional.  The keyword is ~&optional~.  (The '~&~' in front of
  '~optional~' is part of the keyword.)  In a function definition, if
  an argument follows the keyword ~&optional~, no value need be passed
  to that argument when the function is called.

- The first line of the function definition of ~beginning-of-buffer~
  therefore looks like this:

  #+begin_src emacs-lisp
- - (defun beginning-of-buffer (&optional arg)
  #+end_src

- In outline, the whole function looks like this:

  #+begin_src emacs-lisp
    (defun beginning-of-buffer (&optional arg)
      "documentation..."
      (interactive "P")
      (or (is-the-argument-a-cons-cell arg)
          (and are-both-transient-mark-mode-and-mark-active-true)
          (push-mark))
      (let (deterimine-size-and-set-it)
        (goto-char
         (if-there-is-an-agument
          figure-out-where-to-go
          else-go-told
          (point-min))))
      do-nicety
  #+end_src

- The function is similar to the ~simplified-beginning-of-buffer~
  function except that the ~interactive~ expression has "~p~" as an
  argument and the ~goto-char~ function is followed by an if-then-else
  expression that figure out where to put the cursor if there is an
  argument that is not a cons cell.

- The ~"P"~ in the ~interactive~ expression tells Emacs to pass a
  /prefix argument/, if there is one, to then function in raw from.  A
  prefix argument is made by typing the ~META~ key followed by a
  number, or by typing ~C-u~ and then a number.  (If you type don't
  type a number, ~C-u~ defaults to a cons cell with a 4.  A lowercase
  ~"p" in the ~interactive~ expression causes the function to convert
  a prefix arg to number.)

- The true-or-false-test of the ~if~ expression looks complex, but it
  is not; it checks whether ~arg~ has a value that is not ~nil~ and
  whether it is a cons sell.  (That is what ~constp~ does; it checks
  whether its argument is a cons cell.)  If ~arg~ has a value that is
  not ~nil~ (and is not a cons cell), which will be the case if
  ~beginning-of-buffer~ is called with a numeric argument, then this
  true-or-false-test will return true and then-part of the ~if~
  expression will be evaluated.  On the other had, if
  ~beginning-of-buffer~ is not called with an argument, the value
  ~arg~ will be ~nil~ and the else-part of the ~if~ expression will be
  evaluated.  The else-part is simply ~point-min~, and when this is
  the outcome, the whole ~goto-char~ expression is ~(goto-char
  (point-min))~, which is how we the ~beginning-of-buffer~ function in
  its simplified form.

*** ~beginning-of-buffer~ with an Argument

- When ~beginning-of-buffer~ is called with an argument, an expression
  is evaluated which calculates what value to pass to ~goto-char~.
  This expression is rather complicated at first sight.  It includes
  an inner ~if~ expression and much arithmetic.  It look like this:

  #+begin_src emacs-lisp
    (if (> (buffer-size) 10000)
        ;; Avoid overflow for large buffer sizes!
        (* (prefix-numeric-value arg)
           (/ size 10)
           (/
            (+ 100%
               (* size (prefix-numeric-value arg))) 10)))
  #+end_src

  - [[Disentangle ~beginning-of-buffer~][Disentangle beginning-of-buffer]]

  - [[What happen in a large buffer][Large buffer case]]

  - [[What happen in a small buffer][Small buffer case]]

**** Disentangle ~beginning-of-buffer~

- Like other complex-looking expression, the conditional expression
  within ~beginning-of-buffer~ can be disentangled by looking at it as
  parts of a template, in this case, the template for an if-then-else
  expression.  In skeletal form, the expression looks like this:

  #+begin_src emacs-lisp
    (if (buffer-is-large
         divide-buffer-size-by-10-and-multiply-by-arg
      else-use-alternate-calculation
  #+end_src

- The true-or-false-test of this inner ~if~ expression checks the size
  of the buffer.  The reason for this is that the old version 18 Emacs
  used numbers that are no bigger than eighth million or so and in the
  computation that followed, the programmer feared that Emacs might
  try to use over-large numbers if the buffer were large.  The term
  "overflow", mentioned in the comment, means numbers that are over
  large.  More recent version of Emacs use large numbers, but this
  code has not been touched, if only because people now look at buffer
  that are far, far larger than ever before.

- there are two cases: if the buffer is large and if it is not.

**** What happen in a large buffer

- In ~beginning-of-buffer~, the inner ~if~ expression test whether the
  size of the buffer is greater than 10,000 characters.  To do this,
  it uses the ~>~ function and the computation of ~size~ that comes
  from the let expression.

- In the old days, the function ~buffer-size~ was used.  Not only was
  the function called several times, it gave the size of the whole
  buffer, not the accessible part.  The computation makes much more
  sense when it handles just the accessible part.  (See [[][Narrowing
  and Widening]], for more information on focusing attention to an
  accessible part.)

- the line looks like this:
  #+begin_src emacs-lisp
    (if (> size 10000)
  #+end_src

- When the buffer is large is large, the then-part of the ~if~
  expression is evaluated.  It reads like this (after formatting for
  easy reading):

  #+begin_src emacs-lisp
    (*
     (prefix-numeric-value arg)
     (/ size 10))
  #+end_src

  this expression is multiplication, which with two arguments to the
  function ~*~

- The first argument is ~(prefix-numeric-value arg)~.  When ~"p"~ is
  used as the argument for ~interactive~, the value passed to the
  function as its argument is passed a ~raw prefix argument~, and not
  a number.  (It is a number list.) To perform the arithmetic, the
  conversion is necessary, and ~prefix-numeric-value~ does the job.

- The second argument is ~(/ size 10)~.  This expression divides the
  numeric value by ten--the numeric value of the size of the
  accessible portion of the buffer.  This produces a number that tells
  how many characters make up one tenth of the buffer size.  (in Lisp,
  ~/~ is used for division, just as ~*~ is used for multiplication.)

- In the multiplication expression as a whole, this amount is
  multiplied by the value of the prefix argument--the multiplication
  looks like this:

  #+begin_src emacs-lisp
    (* numeric-value-of-prefix-arg
       number-of-characters-in-one-tenth-of-the-accessible-buffer)
  #+end_src

- If, for example, the prefix argument is ~'7~', the one-tenth value
  will be multiplied by 7 to give a position 70% of the way through.

- The result of all this is that the accessible portion of the buffer
  is large, the ~goto-char~ reads like this:

  #+begin_src emacs-lisp
    (goto-char (* (prefix-numeric-value arg)
                  (/ size 10)))
  #+end_src

  This put the cursor where we want it.

**** What happen in a small buffer

- Here  is the complete text of the ~beginning-of-buffer~ function:


  #+begin_src emacs-lisp
    (defun beginning-of-buffer (&optional arg)
      "Move point to the beginning of the buffer;
    leave mark atprevious position.
    with \\[universal-argument] prefix,
    do not set mark at previous position.  With numeric org N,
    put point N/10 of the way from the beginning

    If the buffer is narrowed,
    this command uses the beginning and
    size of the accessible part of the buffer.

    Don't use tis command in Lisp program!
    \(go-char (point-min)) is faster
    and avoids clobbering the mark."
      (interactive "P")
      (or (consp arg)
          (and transient-mark-mode-mark-active)
          (push-mark))
      (let ((size (- (point-max) (point-min)))
            (goto-char (if (and arg (not (consp arg)))
                           (+ (point-min)
                              (if (> size 10000)
                                  ;; avoid oveflow for large buffer sizes!
                                  (* (prefix-numeric-value-org)
                                     (/ size 10))
                                (/ (+ 10 (* size (prefix-numeric-value arg)))
                                   10)))
                         (point-min))))
        (if (and arg (not (consp arg))) (forward-line 1)))
    #+end_src

- Except for two small points, the previous discussion shows how this
  function works.  The first point deals with a detail in the
  documentation string, and the second point concerns the last line of
  the function.

- In the documentation string, there is reference to an expression:

  #+begin_src emacs-lisp
    \\[universal argument]
  #+end_src

- A '~\\~\ is used before the first square bracket of this expression.
  This '~\\~' tells the lisp Interpreter to substitute whatever key is
  currently bound to the '~[...]~'.  In this case of
  ~universal-argument~, that is usually ~C-u~, but it might be
  different.  (See [[][Tips for Documentation Strings]] in the GNU
  Emacs Lisp Reference Manual, for more information.)

- Finally, the last line of the ~beginning-of-buffer~ commands says to
  move point to the beginning of the next line if the command is
  invoked with an argument:

  #+begin_src emacs-lisp
    (if (and arg (not (consp arg))) (forward-line 1))
  #+end_src

- This puts the cursor at the beginning of the first line after the
  appropriate tenths position in the buffer.  This is flourish that
  means that the cursor is always located /at least/ the requested
  tenths of the way through the buffer, which is a nicety that is,
  perhaps, not necessary, but which, if it did not occur, would be
  sure to draw complaints.  (The ~(not (consp arg))~ portion is so
  that if you specify the command with a ~C-u~, but without a number,
  that is to say, if the raw prefix argument is simply, a cons cell,
  the command does not put your at the beginning of the second line.)

** Review

- ~or~

  evaluates each argument in sequence, and return the value of the
  first argument that is nor ~nil~; if none return a value that is not
  ~nil~, return ~nil~.  In brief, return the first value of the
  arguments; return a true value of one ~or~ any of the others are
  true.

- ~and~

  Evaluate each argument in sequence, and if any are ~nil~, return
  ~nil~; if none are ~nil~, return the value of the last argument.  In
  brief, return a true value only if all the arguments are true;
  return a true value if one ~nad~ of the others is true.

- ~&optional~

  A keyword used to indicated that an argument to a function
  definitions is optional; this meas that the function can be
  evaluated without the argument, if desired.

- ~prefix-numeric-value~

  Convert the raw prefix argument produced by ~(interactive "P")~ to a numeric value.

- ~forward-line~

  Move point forward to the beginning of the next line, or if the
  argument is greater than one, forward that many lines.  If it can't
  move as far forward as it supposed to, ~forward-line~ goes forward
  as far it can and then returns a count of the number of additional
  lines it was supposed to move but couldn't.

- ~erase-buffer~

  Delete the entire contents of the current buffer.

- ~bufferp~

  Returns ~t~ if its argument is a buffer; otherwise return ~nil~.


* The Advantage of Narrowing

- Narrowing is a feature of Emacs that makes it possible for you to
  focus on a specific part of buffer, and work without accidentally
  changing other parts.  Narrowing is normally disabled since it can
  confuse novices.

  - [[The Advantages of Narrowing][Narrowing advantages]]                     The advantages of narrowing.

  - [[The ~save-restriction~ Special Form][save-restriction]]       The ~save-restriction~ special form.

  - [[~what-line~][what-line]]                                The number of the line that point is on.

** The Advantages of Narrowing

- With narrowing, the rest of a buffer is made invisible, as if
  weren't there.  This is an advantage if, for example, you want to
  replace a word in one part of a buffer but not in another; you
  narrow to the part you want and the replacement is carried out only
  in that section, not in the rest of the buffer.  Searches will only
  work within a narrowed region, not outside of one, so if you are
  fixing a part of a document, you can keep yourself from accidentally
  finding parts you do not need to fix by narrowing just to the region
  you want. (the key binding for ~narrow-to-region~ is ~C-x n n~.)

- However, narrowing does make the rest of the buffer invisible, which
  can scare people who inadvertently invoke narrowing and think they
  deleted a part of their file.  Moreover, the ~undo~ command (which
  is usually bound to ~C-x u) does not turn off narrowing (nor should
  it), so people can become desperate if they do not know that they
  can return the rest of a buffer to visibility with the ~widen~
  command.  (The key binding for ~widen~ is ~C-x n w~.)

- Narrowing is just as useful to the lisp interpreter as to human.
  Often, an Emacs Lisp function is designed to work on just part of a
  buffer, it has any narrowing and when it has finished its job,
  restores the narrowing to what it was. On the other hand, the
  ~count-lines~ function uses narrowing to restrict uses narrowing to
  restrict it self to just that portion of the buffer in which it is
  interested and then restores the previous situation.

** The ~save-restriction~ Special Form

- In Emacs Lisp, you can use the ~save-restriction~, special form to
  keep track whatever narrowing is in effect, if any.  When the Lisp
  interpreter meets with ~save-restriction~, it executes the code in
  the body of the ~save-restriction~ expression, and then undoes any
  changes to narrowing that the code caused.  If, for example, the
  buffer is narrowed and the code that follows ~save-restriction~ gets
  rid of the narrowing, ~save-restriction~ gets rid of the narrowing,
  ~save-restriction~ return the buffer to its narrowed region
  afterwards.  In the ~what-line~ command, any narrowing the buffer
  may have is undone by the ~widen~ command that immediately follows
  the ~save-restriction~ command.  Any original narrowing is restored
  just before the completion of the function.

- The template for a ~save-restriction~ expression is simple:

  #+begin_src emacs-lisp
    (save-restriction
      body...)
  #+end_src

- The body of the ~save-restriction~ is one or more expression that
  will be evaluated in sequence by the Lisp interpreter.

- Finally, a point to note: when you use both ~save-excursion~ and
  ~save-restriction~, one right after the other, you should use
  ~save-excursion~ outermost.  If you write them in reverse order, you
  may fail to record narrowing in the buffer to which Emacs switches
  after calling ~save-excursion~.  Thus, when written together,
  ~save-excursion~ and ~save-restriction~ should be written like this:

  #+begin_src emacs-lisp
    (save-excursion
      (save-restriction
        body...))
  #+end_src

- In other circumstances, when not to written together, the
  ~save-excursion~ and ~save-restriction~ special form must be written
  in the order appropriate to the function.

- For example,

  #+begin_src emacs-lisp
    (save-restriction
      (widen)
      (save-excursion
        body..))
  #+end_src
** ~what-line~

- The ~what-line~ command tells you the number of the line in which
  the cursor is located.  The function illustrate the use of the
  ~save-restriction~ and ~save-excursion~ commands. Here is the
  original text of the function:

  #+begin_src emacs-lisp
    (defun what-line ()
      "Print the current line number (in the buffer) of point."
      (interative)
      (save-excursion
        (beginning-of-line)
        (message "Line %d"
                 (1+ (count-lines 1 (point)))))
  #+end_src

- (In recent version of GNU Emacs, the ~what-line~ function has been
  to tell you your line number in a narrowed buffer as well as your
  line in a widened buffer.  The recent version is more complex than
  version shown here.  If you fell adventurous, you might to look it
  after figuring out how this version works.  You will probably need
  to use ~C-h f (describe-function)~.  The newer version uses a
  conditional to determine the buffer has been narrowed.

- (Also, it uses ~line-number-at-pos~, which among other simple
  expressions, such as ~(goto-char (point-min))~, moves point to the
  beginning of the current line with ~(forward-line 0)~, rather than
  ~beginning-of-line~.)

- The ~what-line~ function as shown here has a documentation line and
  is interactive, as you would expect.  The next two lines use the
  function ~save-restriction~ and ~widen~.

- The ~save-restriction~ special form notes whatever narrowing is an
  effect, if any, in the current buffer and restores that narrowing
  after code in the body of the ~save-restriction~ has been evaluated.

- The call to ~widen~ is followed by ~save-excursion~, which saves the
  location of the cursor (i.e of point(, and restores it after the
  code in the body of the ~save-excursion~ uses the
  ~beginning-of-line~ function to move point.

- (Note that the ~(widen)~ expression comes between the
  ~save-restriction~ and ~save-excursion~ special forms.  When you
  write the two ~save- ...~ expression in sequence, write
  ~save-excursion~ outermost.)

- The last two lines of the ~what-line~ function are functions to
  count the number of lines in the buffer and then print the number in
  the echo area.

  #+begin_src emacs-lisp
    (message "Line %d"
             (1+ (count-lines 1 (point)))))
    #+end_src

- The ~message~ function prints a one-line message at the bottom of
  the Emacs screen.  The first argument is inside of quotation marks
  and id printed as a string of characters.  However, it may contain a
  '~%d~' prints the argument. '~%d~' prints as a decimal, so the
  message will say something such as ~'line 243'~.

- The number that is printed in place of the '~%d~' is computed by the
  last line of the function:

  #+begin_src emacs-lisp
    (1 + (count-lines 11 (point)))
  #+end_src

- What this does count is count the lines from the first position of
  the buffer, indicated by the ~1~, up to ~(point)~, and then add one
  to that number.  (The ~1+~ function adds one to its argument.) We
  add one to it because line 2 has only one line before it, and
  ~count-lines~ counts only the lines /before/ the current line.

- After ~count-lines~ has done its job, and the message has been
  printed in the echo area, the ~save-excursion~ restore point to its
  original position; and ~save-restriction~ restores the original
  narrowing, if any.
