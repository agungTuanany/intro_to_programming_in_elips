#+TITLE: Summary from An Introduction to Programming in Emacs Lisp by Robert J Chassel
#+AUTHOR: Agung Tuanany
#+EMAIL: agung.tuanany@gmail.com
#+SUBJECT: Emacs, Elisp
#+KEYWORDS: Emacs, Elisp
#+PROPERTY: header-args:emacs-lisp :tangle ./intro_to_programming_in_emacs_lisp-02.el :mkdirp yes
#+OPTIONS: toc:t
#+STARTUP: content indent
#+MACRO: export-date (eval (format-time-string "%F %R %z" (current-time)))
#+MACRO: count-words (eval (count-words (point-min) (point-max)))

#+LATEX_CLASS: org-plain-latex
#+LATEX_CLASS_OPTIONS: [letterpaper]
#+SETUPFILE: ./latex-standard-export.org

#+begin_comment
#+LATEX_CLASS: article

#+SETUPFILE: ~/.emacs.d/modules/prelude-latex.el
#+LATEX_HEADER: \input{latex-standard-setup.tex}
;;;
#+LATEX_HEADER: \input{jake-latex-standard.setup}
#+end_comment

#+STARTUP: latexpreview

+ Created: 2022-02-19
+ Updated: *{{{export-date}}}*.
+ Word count: *{{{count-words}}}* (not a measure of quality, just to offer an
  idea on what to expect)
+ Git repository (part of my dotfiles for GNU/Linux):
  <https://github.com/agungTuanany/intro_to_programming_in_elips.git>

* List Processing
- To the untutored eye, Lisp is a strange programming language.  In
  Lisp code there are /parentheses everywhere/.  Some people even
  claim that the name stand for "Lots of Isolated Silly Parentheses".
  But the claim is unwarratend.

- Lisp stand for Lost processing, and the programming language handle
  /list/ (and list of list) by putting them between parentheses.  The
  parentheses mark the boundaries of the list.  Sometimes a list is
  preceded by an apostrophe '~'~', called a /single-quote/ in Lisp.

- Lists are the basic of lisps.

  - [[Lisp List & Atom][Lisp Lists]]              What are lists?

  - [[Lisp List & Atom][Run A program]]           Any list in Lisp is a program ready to run

  - [[Run A program][Making Errors]]           Generating an error message

  - [[Symbol Names and Function Definition][Names & Definitions]]     Names of symbol and function definitions

  - [[The Lisp Interpreter][Lisp Interpreter]]        What the Lisp interpreter does

  - [[Evaluation][Evaluation]]              Running a program

  - [[Variables][Variables]]               Returning a value from a variable

  - [[Arguments][Arguments]]               Passing information to a function

  - [[Setting the Value of a Variable][set & setq]]              Setting the value of a variable

  - [[Summary][Summary]]                 The major points


** Lisp List & Atom
*** Vocabularies:

- <<<apostrophe>>> : a punctuation mark (') used to indicated either
  possession.

- <<<indivisible>>> : unable to be divided or separated.

- <<<fission>>> : the action of dividing or splitting something into
  two or more parts.

- <<<sloth>>> : laziness; reluctant to work an effort.

- <<<precedes>>> : come before (something) in time.

- <<<deciphering>>> : convert (a text written in code, or coded signal)
  into normal language; decode, translate

- <<<ceases>>> :bring or come to end

- <<<esoteric>>> : intended for or likely to be understood by only a
  small of people with specialized knowledge or interest.

- <<<digression>>> : a temporary departure from which the main subject
  in speech or writing; synonyms: apostrophe, divagation

*** Notes

- A list in Lisp consist of parentheses surrounding atoms separated by
  whitespace or surrounding other lists or surrounding both atoms and
  other lists.

- An empty list is considered both an atom and a list at the same
  time.

- The printed representation of atoms and list are called /symbolic
  expressions/ or more concisely */s-expressions/*.

- In Lisp, certain kind of atom, such an /array/, can be separated
  into parts; but the mechanism for doing this is different from the
  mechanism for splitting a list.

- As far as a list operation are concerned, the atoms of list are
  unsplittable.

- In Lisp, all of the quoted text including the punctuation mark and
  the blanks spaces is a single atom.  This kind of atom is called a
  /string/ (for "string characters").  Strings are different kind of
  atom than numbers or symbols and are used differently.

- A command to properly indent the code in a region is customarily
  bound to /"M-c\"/.

*** Example

- ex-1:

  #+begin_src emacs-lisp
    ;; try to comment out
    (message '(rose
               violet
               daisy
               buttercup))
  #+end_src

- ex-2:

  #+begin_src emacs-lisp
    '(this list
           looks like this)
  #+end_src

Above list is same as this:

- ex-3:

  #+begin_src emacs-lisp
    '(this list looks like this)
  #+end_src

** Run A program

- A list in Lisp--any list-- is a program ready to run.

- If you run it (for which the Lisp jargon is */evaluate/*), the
  computer will do one of three things:

  -- Do nothing except return you the list itself,

  -- send you an error message,

  -- treat the first symbols in the list as a command to do
  something. (the last of these three things that you really want
  Lisp to expect).

- The single apostrophe, /( ' )/, that put in front of some of the example
  lists in preceding section is called a */quote/*; when it precedes a
  list, it tells Lisp to do nothing with the list, other than take it
  as it is written.  But if there is */no quote/* preceding a list,
  the first item of the list is special: it is a command for the
  computer to obey.

** Generate an Error Message

  #+CAPTION: Error Example
  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function this)
     (this is an unquoted list)
     eval((this is an unquoted list) nil)
     elisp--eval-last-sexp(nil)
     eval-last-sexp(nil)
     funcall-interactively(eval-last-sexp nil)
     call-interactively(eval-last-sexp nil nil)
     command-execute(eval-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
  #+end_src

- We often try o generate error message intentionally.

- We have a jargon, /error message can be informative/.  Instead being
  called /"error"/ messages, they should be called /"help"/ messages.

- deciphering an error mesasge can be hard, but once understood, they
  can be point the way.

- You read the */=*Backtrace*=/* buffer from the *bottom--up*; it
  tells you what Emacs did.
- When you type /C-x C-e/, you made an interactive call to the command
  /eval-last-sexp/.

- /eval/ is an abbrevation for /"evaluate"/ and /sexp/ is an
  abbrevation for /"symbolic expression"/.  The command means
  /"evaluate last symbolic expression"/, which is the expression just
  before your cursor.

- At the top of the =*Backtrace*= buffer, you see the line:

#+begin_src emacs-lisp
\begin{verbatim}
        *Debugger entered--Lisp error: (void-function this)*
\end{verbatim}
#+end_src

- The Lisp interpreter tried to evaluate the first atom of the list,
  the word 'this'. It is this action that generated the error message
  'void-function this'.

- The word /'function'/ was mentioned before. It was a very important
  word. For our purposes, we an define it by saying that a /function
  is a set of instructions to the computer that tell the computer to
  do something/.

- Now we can begin to understand the error message: 'void-function
  this'. The function (that is, the word 'this') does not have a
  definition of any set of instructions for the computer to carry out.

- The slightly odd word, *'void-function'*, is designed to cover the
  way Emacs Lisp is implemented, which is that when a symbol does not
  have a function definition attached to it, the place that should
  contain the instruction is void.

- It is possible to prevent Emacs entering the debugger in cases like
  above. We do not explain how to do that here, but we will mention
  what the result looks like, because you may encounter a similar
  situation if there is a bug in some Emacs code that you are using.

- In such cases, you will see only one line of error message; it will
  appear in the echo area and look like this:

#+begin_src emacs-lisp
  Symbol's function definition is void: this
#+end_src

- The message goes away as soon as you type a key, even just to move
  the cursor.

- We know the meaning of the word 'Symbols'. It refers to the first
  atom of the list, the word 'this'.  The word 'function' refers to
  the instructions that tell the computer what to do. (Technically,
  the symbol tell the computer where to find the instructions, but
  this is a complication we can ignore at the moment.).

- The error message can be understood: 'Symbol's function definition
  is void: this'.  The symbol (that is, the word 'this') lacks
  instructions for the computer to carry out.

** Symbol Names and Function Definition

- In Lisp, one set of instructions can be attached to several
  names. For examples, the computer instructions for adding numbers
  can be linked to the symbol plus as well as the symbol =+= (and are
  in some dialects of Lisp).

- On other hand, a symbol can have only one function attached to it at
  a time. Otherwise, the computer would be confused as to which
  definition to use.

- However, the /function definition/ to which the name refers can be
  *changed* readily.

- Since Emacs Lisp is large, it is customary to name symbols in a way
  that identifies the part of Emacs to which the function belongs.

- Thus all the names for function that deal with /Textinfo/ start with
  /'textinfo-'/, and those for function to deal with /reading mail/
  start with /'mail'/.

** The Lisp Interpreter

- Based on what we have seen, we can now start to figure out what Lisp
  interpreter does when we command it to evaluate a list.

- First, it looks to see whether there is *a quote* before the list;
  /if there is/, the interpreter looks at the first element in the
  list the interpreter just gives us the list.

- Second, if there is *no qoute*, the interpreter looks at the first
  element in the list and sees whether it has a /function
  definition/. If it does, the interpreter carries out the instruction
  in the function definition. Otherwise, the interpreter print an
  error message.

  -- [[Complications][Complications]] Variables, Special forms, list within.

  -- [[Byte Compiling][Byte Compiling]] Special processing code for speed.

*** Complications

- For the *first* - complication, in addition to list, the Lisp
  interpreter can evaluate a symbol that is not quoted and does not
  have parentheses around it.  The Lisp interpreter will attempt to
  determine a symbol's value as */variable/*.  This situation is
  described in the section (see section "Variables")

- the *second* - complication occurs because some functions are
  unusual and do not work in the usual manner.  Those that don't are
  called */special forms/*.  They are used for special jobs, like
  defining a function, and there are not many of them.

- As well as special forms, there are also /"macros"/. A /macro/ is
  construct defined in Lisp, which differs from a function in that it
  translates a Lisp expression into another expression that is to be
  evaluated in place of the original expression (see section "Lisp
  Macro").

- For the purpose of this introduction, you do not need to worry too
  much about whether something is a /special form/, /macro/, or
  /ordinary function/.

- For example, /=if=/ is a special form, but /=when=/ is a macro. In
  earlier versions of Emacs, /=defun=/ was a special form, but it is a
  macro.  It still behave the same way.

- The *final* complication is, if the function that the Lisp
  interpreter is looking at is *not* a special form, and if it is part
  of a list, the Lisp interpreter looks to see whether the list has a
  list inside of it.  If there is an inner list, the Lisp interpreter
  first figures out what it should do with the inside list, and then
  it works on the outside list.  If there is yet another list embedded
  inside inner list, it works that one first, and so on.

- The interpreter works on the innermost list first, to evaluate the
  result of that list.  The result may be used by the enclosing expression.

- Otherwise, the interpreter works */left to right/*, from one
  expression to the next.

*** Byte Compiling

- One other aspect of interpreting: the Lisp interpreter is able to
  interpret two kind of entity: /humanly readable code/, which we will
  focus exclusively, and special processed code, called /byte
  compiled/ code, which is not human readable.  Byte compiled code
  runs faster than humanly readable code.

- You can transform humanly readable code into byte compiled code by
  running one of the compile commands such as *=byte-compile-file=*.
  Byte compiled code is usually in a file that ends with a /=.ec=/
  extension rather than a /=.el=/ extension.

- As practical matter, for most thing you might do to customize or
  extend Emacs, you do not need to byte compile; and I will not
  discuss the topic here. See Section "Byte Compilation" in the /GNU
  Emacs Lisp Reference Manual/, for full description of byte compilation.

** Evaluation

- When the Lisp interpreter works on an expression, the term for the
  activity is called */=evaluation=/*.  We say that the interpreter
  "evaluates the expression".  The word comes from its use in everyday
  language, "to ascertain the value or amount of; to appraise",
  according to /Webster's New Collegiate Dictionary/.

  -- [[How Interpreter acts][How Interpreter acts]]         Returns and Side Effects

  -- [[Evaluating Inner Lists][Evaluating Inner Lists]]       List within lists

*** How Interpreter acts

- After evaluating an expression, the Lisp interpreter will most
  likely return the value that the computer produces by carrying out
  the instructions it found in the /function definition/, or perhaps
  it will give up on that function and produce error message.  Most
  frequently, the interpreter returns a value.

- At the same time the interpreter returns a value, it may do
  something else as well, such as move a cursor or copy a file; this
  other kind of action is called a */side effect/*.  Actions that we
  humans think are important, such as /printing results/, are often
  side effects to the Lisp interpreter.  It fairly easy to learn to
  use side effect.

- In summary, evaluating a symbolic expression most commonly causes
  the Lisp interpreter to return a value and perhaps carry out a side
  effect; or else produce an error.

*** Evaluating Inner Lists

- If evaluation applies to a list that is inside another list, the
  outer list may use the value returned by evaluation as information
  when the outer list is evaluated.  This explains why inner
  expression evaluated first: the values they returns are *used* by
  the outer expressions.

** Variables

- In Emacs Lisp, a symbol can have a /value/ attached to it just as it
  can have a /function definition/ attached to it.  *The two are
  different*.

- The /function definition/ is a set of instruction that a computer will
  obey.

- A /value/, on the other hand, is something, such a number or a name,
  that can vary (which is why such a symbol is called a variable).
  The value of symbol can be any expression in Lisp, such as a symbol,
  number, list, or string.

- A symbol that has a value is often called /variable/.

- A symbol can have both a function definition and a value attached to
  it at the same time. Or it can have just one or the other.  The two
  are separate.

- Another way to think about this is to imagine a symbol as being a
  /chest of drawers/.  The function definition is in one drawer, the
  value in another, and so on.  What is put in the drawer holding the
  value can be changed without affecting the contents of the drawer
  holding the function definition, and vise versa.

*** ~fill-column~ an Example Variable

- The variable /=fill-column=/ illustrate a symbol with a value
  attached to it: in every GNU Emacs buffer, this symbol is set to
  some value.  To find out the value of this symbol, evaluate it by
  itself.

  #+begin_src emacs-lisp
    fill-column     ;; type (C-x C-e) to evaluate the value
  #+end_src

- Notice that the value returned as a variable is printed in exactly
  the same way returned by a function carrying out its instruction.

- From the point of view of the Lisp interpreter, /a value returned is
  a value returned/.  What kind of expression it came from ceases to
  matter once the value is known.

- A symbol can have any value attached to it or, to use the jargon, we
  can *bind the variable to a value*: to a /number/, such as =72=; to
  a /string/, *"=such as this="*; to a /list/, such as *=(spruce pine
  oak)=*; we can bind a variable to a /function definition/.

- A symbol can be bound to a value in several ways, See "Setting the
  Value of a Variable".

*** Error Message for a Symbol Without a Function

- When we evaluated *=fill-column=* to find its value as a variable,
  we did not place parentheses around the word.  This is because we
  did not intend to use it as a /function-name/.

- If *=fill-column=* were the first or only element of a list, the
  Lisp interpreter would attempt to find the function definition
  attached to it. But =fill-column= has no function definition.

  #+begin_src emacs-lisp
    (fill-column)     ;; type (C-x C-e) to evaluate the value
  #+end_src

- You will create a *=*Backtrace*=* buffer that says:

  #+begin_src emacs-lisp
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function fill-column)
       (fill-column)
       eval((fill-column) nil)
       elisp--eval-last-sexp(nil)
       eval-last-sexp(nil)
       funcall-interactively(eval-last-sexp nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
  #+end_src

*** Error Message for a Symbol without value

- If you attempt to evaluate a symbol that does not have a value bound
  to it, you will receive an error message. You can see this by
  experimenting with 2 plus 2 addition.  In the following expression,
  put your cursor right after the =+=, before first number 2, type /C-x C-e/:

  #+begin_src emacs-lisp
    (+ 2 2)     ;; type (C-x C-e) to evaluate the value
  #+end_src

- You will create a *=*Backtrace*=* buffer that says:

  #+begin_src emacs-lisp
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-variable +)
       eval(+ nil)
       elisp--eval-last-sexp(nil)
       eval-last-sexp(nil)
       funcall-interactively(eval-last-sexp nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
  #+end_src

- This backtrace is different from the very first error message we
  saw, which said '~Debugger entered--Lisp error: (void-function
  this)~'.  In this case, the function does not have a value as a
  variable; while in the other error message, the function (the word
  'this') did not have a definition.

  In this experiment with the =+=, what we did was cause the Lisp
  interpreter to evaluate the =+= and look for the value right after
  the symbol rather than after the parenthesis of the enclosing list
  as we did before.  As a consequence, the Lisp interpreter evaluated
  the preceding /s-expression/ (symbol-expression), which in this case
  was =+= by itself.

  Since =+= does not have a value bound to it, just the function
  definition, the error message reported that the symbol's value as a
  variable was void.

** Arguments

- To see how information is passed to functions, let's look again at
  our old standby, the addition of two plus two.  In Lisp, this is
  written as follows:

  #+begin_src emacs-lisp
    (+ 2 2)
  #+end_src

- If you evaluate this expression, the number 4 will appear in your
  echo area.  What the Lisp interpreter does is add the numbers that
  follow the ~+~.

- The numbers added by ~+~ are called the /arguments/ of the function
  ~+~.  These numbers are the information that is given to or /passed/
  to the function.
  follows the ~+~.

- The word "argument" comes from the way it used in mathematics and
  *does not* refer to a disputation between two people; instead it
  refers to the information presented to the function, in this case,
  to the ~+~.

- In Lisp, the arguments to a function are the atoms or lists that
  follow the function.  The values returned by the evaluation of these
  atoms or lists are passed to the function.

- Different function require different numbers of arguments; some
  function require none at all.

  - [[Argument's Data Types][Data Types]]                          Types of data passed to a function

  - [[An Argument as the Value of a Variable or List][Args as Variable or List]]            An arguments can be the value of variable or list

  - [[Variable Number of Arguments][Variable Number of Arguments]]        Some functions may take a variable number of arguments

  - [[Using the Wrong Type Object as an Argument][Wrong Type of Argument]]              Passing an argument of the wrong type to a function

  - [[The ~message~ Function][message]]                    A useful function for sending message

  - [[Argument's Data Types][Argument's Data Types]]               Types data passed to a function

*** Argument's Data Types

- The type of data that should be passed to a function depends in what
  kind of information it uses.  The arguments to a function such as
  ~+~ must have values that are numbers, since ~+~ adds numbers.
  Other function use different kinds of data for their arguments.

- For example, the ~concat~ function links together or unites two or
  more strings of text to produce a string.  The arguments are
  strings.  Concatenating the two character string ~abc~, ~def~
  produces the single string ~abcdef~.  This can be evaluating the
  following:

  #+begin_src emacs-lisp
    (concat "abc" "def")
  #+end_src

  The value produced by evaluating this expression is ~"abcdef"~.

- A function such as ~substring~ uses both a string and numbers as
  arguments.  The function returns as part of the string, a
  /substring/ of the first argument.  This function /takes three
  arguments/.  Its first arguments is the string of characters, the
  second and third arguments are numbers that indicate the beginning
  (inclusive) and end (exclusive) of the substring.  The numbers are a
  count of the number of characters (including spaces and punctuation)
  from the beginning of the string.

- Note that the characters in a string are numbered from zero, not one.

- For example, if you evaluate the following:

  #+begin_src emacs-lisp
(substring "The quick brown fox jumped." 16 19)
  #+end_src

  you will see ~"fox"~ in the echo area.  The arguments are the string
  and the two numbers.

- Note that the string passed to ~subtring~ is a single atom even
  though it is made up of several words separated by spaces.  Lisp
  counts everything between the two quotation marks as a part of the
  string, including the spaces.

- You can think of the ~substring~ function as a kind of atom smasher
  since it takes an otherwise indivisible atoms and extract a part.
  However, ~substring~ is only able to extract a substring from an
  argument that is a string, not from another type of atom such a
  number or symbol.

*** An Argument as the Value of a Variable or List

- An arguments can be a symbol that returns a value when it is
  evaluated.  For example, when the symbol ~fill-column~ by itself is
  evaluated, it returns a number.  This number can be used in an
  addition.

  #+begin_src emacs-lisp
    fill-column         ; Default value is 70

    (+ 2 fill-column)   ; The value become 72

  #+end_src

  The value will be a number two more than what you get by evaluating
  ~fill-column~ alone. For me, this is 72, because my value of
  ~fill-column~ is 72.

- as we have just seen, an arguments can be a symbol that returns a
  value when evaluated.  In addition, an argument can be a list that
  returns a value when it is evaluated. For example, on the following
  expression, the arguments to the function ~concat~ are the strings
  ~"The "~ and ~" red foxes."~ and the list ~(number-to-string (+ 2
  fill-column))~.

  #+begin_src emacs-lisp
    (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
  #+end_src

  If you evaluate this expression--and if, as with Emacs,
  ~fill-column~ evaluates to *70--*~"The 72 red foxes."~ will appear in the echo area.

  - Note that you must put spaces after the word ~"The"~ and before the
   word ~'red'~ so they will appear in the final string.

  - The function ~number-to-string~ converts the integer that the
    addition function returns to a string.

  - ~number-to-string~ is also known as ~int-to-string~.

*** Variable Number of Arguments

- Some functions, such as ~concat~, ~+~, or ~*~, take any number of
  arguments. This can be seen by evaluating each of the following
  expressions in the usual way.  What you will see in the echo area is
  printed in this text after '~=~', which you may read as /"evaluates
  to"/.

- In the first set, the function have no argument:

  #+begin_src emacs-lisp
    (+)       ⇒ 0
    (*)       ⇒ 1
  #+end_src

- In this set, the function have one argument each:

  #+begin_src emacs-lisp
    (+ 3)       ⇒ 3
    (* 3)       ⇒ 3
  #+end_src

- In this set, the function have three arguments each:

  #+begin_src emacs-lisp
    (+ 3 4 5)       ⇒ 12
    (* 3 4 5)       ⇒ 60
  #+end_src

*** Using the Wrong Type Object as an Argument

- When a function is passed an argument of the wrong type, the Lisp
  interpreter produces an error message.  For example, the ~+~
  function expects the values of its arguments to be numbers.  As an
  experiment we can pass it the quoted symbol ~hello~ instead of a number.

  #+begin_src emacs-lisp
    (+ 2 'hello)
  #+end_src

- When you do this you will generate an error message.  What has
  happened is that ~+~ has tried to add the 2 to the value returned by
  ~'hello~, but the value returned by ~'hello~ is the symbol ~hello~,
  not a number.  Only number can be added.  So ~+~ could not carry out
  its addition.

  #+caption: Error Example
  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
    Debugger entered--Lisp error:
    (wrong-type-argument number-or-marker-p hello)
    +(2 hello)
    eval((+ 2 'hello) nil)
    elisp--eval-last-sexp(t)
    eval-last-sexp(nil)
    funcall-interactively(eval-print-last-sexp nil)
    call-interactively(eval-print-last-sexp nil nil)
    command-execute(eval-print-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
 #+end_src

- As usual, the error message tries to be helpful and makes sense
  after you learn how to read it. (~quote-hello)~ is an expansion of
  the abbreviation ~'hello~.

- The first part of the error message is straightforward; it says
  '~wrong-type-argument~'.  Next comes the mysterious jargon word
  '~number-marker-p~'.  This word is trying to tell you what kind of
  argument the ~+~ expected.

- The symbol ~number-or-maker-p~ says that the Lisp interpreter is
  trying to determine whether the information presented (the value of
  the argument) is a number or a marker (a special object representing
  a buffer position).  What it does is test to see whether the ~+~ is
  being given numbers to add.  It also tests to see whether the
  argument is something called a marker, which is a specific feature
  in Emacs Lisp.  In Emacs Lisp, ~+~ can be used to add the numeric
  value of marker position as numbers.

- The ~'p~ of ~number-or-maker-p~ is the embodiment of a practice
  started in the early days of Lisp programming.  The ~p~ stands for
  "*predicate*".

  In the jargon used by the early Lisp researchers a predicate refers
  to a function to determine whether some property is true or false.

  So the '~p~' tells us that ~number-or-marker-p~ is the name of a
  function that determines whether it is true or false that the
  argument supplied is a number or a marker.

  Other Lisp symbol that end in '~p~' include ~zerop~, a function test
  whether its argument has the value of zero; and ~listp~, a function
  that tests whether its argument is a list.

*** The ~message~ Function

- Like ~+~, the ~message~ function takes a variable numbers of
  arguments.  It used to send messages to the user and is so useful
  that we will describe it here.

- A message is printed in the echo area.  For example, you can print a
  message in your echo area by evaluating the following list:

  #+begin_src emacs-lisp
    (message "This message appears in the echo area!")
  #+end_src

- The whole string between double quotation marks is a /single
  argument/ and is printed in /toto/.

  Note that in this example, the message itself will appear in the
  echo area within double quotes; that is because you see the value
  returned by the ~message~ function.  In most uses of ~message~ in
  program that you write, the text will be printed in the echo area as
  a side-effect, without quotes.  See ~multiply-by-seven~ in detail,
  for an example of this.

- However, if there is a '~%s~' in the quoted string of characters,
  the ~message~ function does not print the '~%s~' as such, but looks
  to the argument that follows the string.  It evaluates the second
  argument and prints the value at the location in the string where
  the '~%s~ is.

  #+begin_src emacs-lisp
    (message "The name of this buffer is: %s." (buffer-name))
  #+end_src

- In info, ~"The name of this buffer is: *info*."~ will appear in the
  echo area.  The function ~buffer-name~ returns the name of the
  buffer as a string, which the ~message~ function insert in place of
  ~%s~.

- To print a value as an integer, use '~%d~' in the same way as
  '~%s~'.  For example, to print a message in the echo area that
  states the value of the ~fill-column~, evaluate the following:

  #+begin_src emacs-lisp
(message "The value of fill-column is %d." fill-column)
  #+end_src

- On my system, when I evaluate this list, ~"The value of fill-column
  is 70."~ appears in my echo area. (actually, you can use ~%s~ to
  print a number.  It is non-specific.  ~%d~ prints only the pat of a
  number left of a decimal point, and not anything that is not a
  number.)

- If there is more than one '~%s~' in the quoted string, the value of
  the first argument following the quoted string is printed at the
  location of the first '~%s~' and the value of the second argument is
  printed at the location of the second '~%s~', and so on.

  #+begin_src emacs-lisp
    (message "Tere are %d %s in the office!"
         (- fill-column 14) "pink elephants")
  #+end_src

  a rather whimsical message will appear in your echo area.  On my
  system it says, ~"there are 56 pink elephants in the office!"~.

- The expression ~(- fill-column 14)~ is evaluated and the resulting
  number is inserted in place of the '~%d~'; and the string in double
  quotes, ~"pink elephants"~, is treated as a single argument and
  inserted in place of the '~%s~'.  (That is to say, a string between
  double quotes evaluates itself, like a number.)

- Finally, here is somewhat complex example that not only illustrates
  the computation of a number, but also shows you how you can use an
  expression within an expression to generate the text that is
  substituted for '~%s~':

  #+begin_src emacs-lisp
    (message "He saw %d %s"
             (- fill-column 32)
             (concat "red "
                     (substring
                      "The quick brown foxes jumped." 16 21)
                     " leaping."))
  #+end_src

- In this example, ~message~ has three arguments: the string, ~"He saw
  %d %s"~, the expression, ~(- fill-column 32)~, and the expression
  beginning with the function ~concat~.  The value resulting from
  evaluation of ~(- fill-column 32)~ is inserted in place of the
  '~%d~', and the value returned by the expression beginning with
  ~concat~ is inserted in place of the '~%s~'.

- When your fill column is 70, and you evaluate the expression, the
  message ~"He saw 38 red foxes leaping."~ appears in your echo area.

** Setting the Value of a Variable

- There are several ways by which a variable can be given a value. One
  of the ways is to use either the function ~set~, or the special form
  ~setq~.  Another way is to use ~let~.

- The jargon for this process is to /bind/ a variable to a value.

  - [[Using set][Using set]]                 Setting values.
  - [[Using ~setq~][Using ~setq~]]              Setting a quoted value.
  - [[Counting][Counting]]                  Using ~setq~ to count.

*** Using set

- To set the value of the symbol ~flowers~ to the list ~'(rose violet
  daisy buttercup)~, evaluate the following expression by positioning
  the cursor after the expression and typing ~C-x C-e~.

  #+begin_src emacs-lisp
    (set 'flowers '(rose violet daisy buttercup))
  #+end_src

- When you evaluate ~flowers~, the list ~(rose violet daisy
  buttercup)~ appears in the echo area.

- Incidentally, if you evaluate ~'flowers~, the variable with a quote in
  front of it, what you will see in the echo area is the symbol
  itself, ~flowers~.  Here is the quoted symbol, so you can try this:

  #+begin_src emacs-lisp
    'flowers
  #+end_src

- Note also, that when you use ~set~, you need to *quote both arguments*
  to ~set~.  Unless you want them evaluated.

- Since we do not want either argument evaluated, neither the variable
  ~flowers~ nor the list ~(rose violet daisy buttercup)~, both are
  quoted.

- When you use ~set~ *without quoting* it first argument, the first
  argument is evaluated before anything else is done.  If you did this
  and ~flowers~ did not have a value already, you would get an error
  message that the ~'Symbol's value as variable is void'~; on the
  other hand, if ~flowers~ did return a value after it was evaluated,
  the ~set~ would attempt to set value that was returned.  There are
  situations where this is the right thing for the function to do; but
  such situation are *rare*.

*** Using ~setq~

- As a practical matter, you almost always quote the first argument to
  ~set~.  The combination of ~set~ and a quoted first argument is /so
  common/ that is has its own name: the special form ~setq~.  This
  special form is just like ~set~ except that the first argument is
  *quoted automatically*, so you don't need to type the quote mark
  yourself.

- Also, as an added convenience, ~setq~ permits you to set several
  different variables to different values, all in one expression.

- To set the value of the variable ~carnivores~ to the list ~'(lion
  tiger leopard)~ using ~setq~, the following expression is used

  #+begin_src emacs-lisp
    (setq carnivores '(lion tiger leopard))
  #+end_src

- This is exactly the same as using ~set~ except the first argument is
  automatically quoted by ~setq~

- The '~q~' in ~setq~ means *quote*.

- With ~set~, the expression would look like this:

  #+begin_src emacs-lisp
    (set 'carnivores '(lion tiger leopard))
  #+end_src

- Also, ~setq~ can be used to assign /different values to different
  variables/.  The first argument is bound to the value of the second
  argument, the third argument is bound to the value of the forth
  argument, and so on.

- For example, you could use the following to assign a list of trees to
  the symbol ~trees~ and list of herbivores to the symbol ~herbivores~:

  #+begin_src emacs-lisp
    (setq trees '(pine fir oak maple)
          herbivores '(gazelle antelope zebra))
  #+end_src

- The expression could just as well been on one line, but it might not
  have fit on a page; and humans find it easier to read nicely
  formatted lists.

  Although I have been using the term "*assign*", there is another way
  of thinking about the workings of ~set~ and ~setq~; and that is to
  say that ~set~ and ~setq~ make the symbol /point/ to the list.  This
  latter way of thinking is very common and in forthcoming chapters we
  shall come upon at least one symbol that has "*pointer*" as part of
  its name.  The name is chosen because the symbol has a value,
  specifically a list, attached to it; or, expressed another way, the
  symbol is set to point to the list.

*** Counting

- Here is an example that show how to use ~setq~ in a counter. You might
  use this to count how many times a part of your program repeats
  itself.  First set a variable to zero; then add one to the number
  each time the program repeat itself.  To do this, you need a
  variable that serves as a counter, and two expression; an initial
  ~setq~ expression that sets the counter variable top zero; and a
  second ~setq~ expression that increment the counter each time it is
  evaluated.

  #+begin_src emacs-lisp
    (setq counter 0)              ;; let's call this initializer

    (setq counter (+ counter 1))  ;; This is the increment

    counter                       ;; This is the counter
  #+end_src

- If you evaluate the first of these expression, the initialize,
  ~(setq counter 0)~, and then evaluate the third expression,
  ~counter~, the number ~0~ will appear in the echo area.

  If you then evaluate the second expression, the incremented, ~(setq
  counter (+ counter 1))~, the counter will get the value of ~1~.

  So if you again evaluate ~counter~, the number ~1~ will appear in
  the echo area.

  Each time you evaluate the second expression, the value of the
  counter will be increased.

- When you evaluate the incrementer, ~(setq counter (+ counter 1))~, the
  Lisp interpreter first evaluates the innermost list; this is the
  addition.  In order to evaluates this list, it must evaluates the
  variable ~counter~ and the number ~1~.  When it evaluates the
  variables ~counter~, it receives its current values.  It passes this
  values and the number ~1~ to the ~+~ which adds them together.  The
  sum is then returned as the value of the inner list and passed to
  the ~setq~ which sets the variables ~counter~ to this new values.
  Thus, the value of the variable, ~counter~, is changed.

** Summary

Learning Lisp is like climbing a hill in which the first part is the
steepest.  You have now climbed the most difficult part; what remains
becomes easier as you progress inwards.

- Lisp programs are made up of /expression/, which are /lists/ or
  /single atoms/.

- List are made up of /zero/ or /more atoms/ or /inner list/,
  separated by whitespace and surround by parentheses.  A list can be
  empty.

- Atoms are /multi-character symbols/, like ~forward-paragraph~,
  /single character symbol/ like ~+~, /string of characters/ between
  double quotes marks, or numbers.

- A number evaluates to itself.

- A string between double quotes also evaluates itself.

- When you evaluate a symbol by itself, its value is returned.

- When you evaluate a list, the Lisp interpreter looks at the first
  symbol in the list and then at the function definition bound to that
  symbol.  Then the instruction in the function definition are carried
  out.

- A single-quote *~'~*, tells the Lisp interpreter that it should
  returns the following expression as written, and not evaluate it as
  it would if the quote were not there.

- Arguments are the information passed to a function.  The arguments
  to a function are computed by evaluating the rest of the elements of
  the list of which the function is the first elements.

- A function always returns a value when it is evaluated (unless it
  gets an error); in addition, it may also carry out some action that
  is a /side effect/.

- In many cases, *a function's primary purpose is to create a side effect*.


* Practicing Evaluation

- It is useful to spend a little time evaluating various expression that
  have already written.  Theses expression will be lists with the
  functions as their first (and often only) element.  Since some of the
  *functions associated with buffers* are both simple and interesting,
  we will start with those.

- In this section, we will evaluate a few of these. In another section,
  we will study the code of several other buffer-related function, to
  see how they were written.

 - [[How to Evaluate][How to Evaluate]]         Typing editing or ~C-x C-e~ causes evaluation

 - [[Buffer Names][Buffer Names]]            Buffers and files are different.

 - [[Getting Buffers][Getting Buffers]]         Getting a buffer itself, not merely its name.

 - [[Switching Buffers][Switching Buffers]]       How to change to another Buffer.

 - [[Buffer Size and the location of Point][Buffer Size & Location]]  Where point is located and the size of the buffer

** How to Evaluate

- /Whenever you give an editing command/ to Emacs Lisp, such as the
  command to move the cursor or to scroll the screen, you are
  /evaluating an expression/, he first element of which is a
  function. /This is how Emacs works/.

- When you type keys, you cause the Lisp interpreter to evaluate an
  expression and that is how you get your result.

- Even typing plain text involves evaluating an Emacs Lisp function, in
  this case, one that use ~self-inserted-command~, which simply inserts
  the character you typed.

- The functions you evaluate by typing keystrokes are called
  /interactive/ function, or /commands/; how you make a function
  interactive will be illustrated in the chapter on how to write
  function definitions.

- In addition to typing keyboard commands, we have seen a second way to
  evaluate an expression: by positioning the cursor after a list and
  typing ~C-x C-e~.  This is what we will do in the rest of this
  section.  There are other ways to evaluate an expression as well;
  these will be described as we come to them.

- Beside being used for practicing evaluation, the functions shown in
  the next few section are important in their own right.  A study of
  these functions makes clear the distinction between /buffers/ and
  /files/, how to switch to a buffer, and how to determine a location
  with it.

** Buffer Names

- The two function, ~buffer-name~ and ~buffer-file-name~, show the
  difference between a file and a buffer.  When you evaluate the
  following expression, ~(buffer-name)~, the name of the buffer appears
  in the echo area. When you evaluate ~(buffer-file-name)~, the name of
  the file which the buffer refers appears in the echo area.  Usually,
  the name returned by ~(buffer-name)~ is the same as the name of the
  file to which it refers, and the name returned by ~(buffer-file-name)~
  is the full path-name of the file.

- A file and a buffer are two different entities.  A file is
  information recorded permanently in the computer (unless you delete
  it).

- A buffer, on the other had, is information inside of Emacs that will
  vanish at the end of the editing session (or when you kill the
  buffer).

- Usually a buffer contains information that contains information that
  you have copied from a file; we say that buffer is /visiting/ that
  file.  This copy is what you work on and modify.  Changes to the
  buffer do not change the file, until you save the buffer.  When you
  save the buffer is copied to the file and is thus saved permanently.

  #+begin_src emacs-lisp
    (buffer-name)
    (buffer-file-name)
  #+end_src

- In spite of the distinction between files and buffers, you will often
  find that people refer to a file when they mean a buffer and vice
  versa.  Indeed most say "I am editing a file," rather than saying,
  "I am editing a buffer which I will soon save to a file".  It is
  almost always clear from context what people mean.

  When dealing with computer programs, however, it is important to
  keep the distinction in mind, since the computer is not as smart as
  a person.

- The word "buffer", by the way, comes from the meaning of the word as a
  cushion that deadens the force of a collision.  In early computers,
  a buffer cushioned the interaction between files and computers
  central processing unit.  The drums or tapes that held a file and
  the central processing unit were pieces of equipment that were very
  different from each other, working at their own speed, in spurts.
  The buffer made it possible for them to work together effectively.
  Eventually, the buffer grew from being an intermediary, a temporary
  holding place, to being the place where work is done.  this
  transformation is rather like that of a small seaport that grew into
  a great city; once it was merely the place where cargo was
  warehoused temporarily before being loaded onto ship; then it became
  a business and cultural center in its own right

- Not all buffers are associated with files. For example, a ~*scratch*~
  buffer does not visit any files.  Similarly, a ~*Help*~ buffer is
  not associated with any file.

- In the old days, when you lacked a ~~/.emacs~ file and started an
  Emacs session by typing the command ~emacs~ alone, without naming
  any files, Emacs started with the ~*scratch*~ buffer visible.
  Nowadays, you will see a splash screen.  You can follow one of the
  command suggested on the splash screen, visit a file, or press ~q~
  to quit the splash screen and reach the ~*scratch*~ buffer.

- If you switch to the ~*scratch*~ buffer, type ~(buffer-name)~,
  position the cursor after it, and then type ~C-x C-e~ to evaluate
  the expression. The name ~"*scratch*"~ will returned and will appear
  in echo area.  ~"*scratch*"~ is the name of the buffer.  When you
  type ~(buffer-file-name)~ in the ~*scratch*~ buffer and evaluate
  that, ~nil~ will appear in the echo area, just as it does when you
  evaluate ~(buffer-file-name)~ in Info.

- Incidentally, if you are in the ~*scratch*~ buffer and want the value
  returned by an expression to appear in the ~*scratch*~ buffer itself
  rather than in the echo area, type ~C-u C-x C-e~ instead of ~C-x
  C-e~.  This causes the value returned to appear after the
  expression. The buffer will look like this:

  #+begin_src emacs-lisp
  ;; in *scratch* buffer
    (buffer-name)"*scratch*"
  #+end_src

- You cannot do this in Info since Info is read-only, and it will not
  allow you to change the contents of the buffer.  But you can do this
  in any buffer you can edit; and when you write code for
  documentation (such as this book), this feature is useful.

** Getting Buffers

- The ~buffer-name~ function returns the /name/ of the buffer; to get
  the buffer /itself/, a different function is needed; the
  ~current-buffer~ function.  If you use this function in code, what
  you get is the buffer it self.

- A name and the object or entity to which the name refers are different
  from each other.  The name of the scratch buffer is ~*scratch*~, but
  the name is *not* the buffer.  To get a buffer itself, you need to
  use a function such as ~current-buffer~.

- However, there is a slight complication: if you evaluate
  ~current-buffer~ in an expression on its own, as we will do here,
  what you see is a printed representation of the name of the buffer
  without the contents of the buffer.  Emacs work this way for *two
  reason*:

  -- the buffer may be thousand of line log--too long to be
  conveniently displayed

  -- Another buffer may have the same contents but a different name,
  and it is important to distinguish between them.

- Here is an expression containing the function:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (current-buffer)
  #+end_src

- If you evaluate this expression in ~*scratch*~ buffer in the usual
  way, ~#<buffer *scratch*>~ will appear in the echo area.  The
  special format indicates the buffer itself is being returned, rather
  than just its name.

  Incidentally, while you can type a number or symbol into a program,
  you cannot do that with the printed representation of a buffer; the
  only way.

  A related function is ~other-buffer~.  This returns the most recently
  selected buffer other than one you are in currently, bit a printed
  representation of its name.  If you have recently switched back and
  forth from the ~*scratch*~ buffer, ~other-buffer~ will return that
  buffer.

  You can see this by evaluating the expression:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (other-buffer)
  #+end_src

You should see ~#<buffer *scratch*>~ appear in the echo area, or the
name of whatever other buffer you switched back from most recently.

** Switching Buffers

The ~other-buffer~ function actually provides a buffer when it us used
an argument to a function that requires one.  We can see this by using
~other-buffer- and ~switch-to-buffer~ to switch to a different buffer.

But first, a brief introduction to the ~switch-to-buffer~ function.
When you switched back and forth from Info to the ~*scratch*~ buffer
to evaluate ~(buffer-name)~, you most likely typed ~C-x b~ and then
typed ~*scratch*~ when prompted in the minibuffer for the name of the
buffer to which you wanted to switch.  The keystroke ~C-x b~, cause
the Lisp interpreter to evaluate the interactive function
~switch-to-buffer~.  As we said before, this is how Emacs works:
/different keystrokes call or run different function/.  For example,
~C-f~ calls ~forward-char~, ~M-e~ calls ~forward-sentence~, and so on.


By writing ~switch-to-buffer~ in an expression, and giving it a buffer
to switch to, we can switch buffers just the way ~C-x b~ does:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (switch-to-buffer (other-buffer))
  #+end_src

- The symbol ~switch-to-buffer~ is the first element of the list, so the
  Lisp interpreter will treat it as a function and carry out the
  instruction that are attached to it.  But before doing that, the
  interpreter will note that ~other-buffer- is inside parentheses and
  work on that symbol first.

  ~other-buffer- is the first (and in this case, the only) element of
  the list, so the Lisp interpreter calls or runs the function.  It
  returns another buffer.

  Next the interpreter runs ~switch-to-buffer~, passing to it, as an
  argument, the other buffer, which is what Emacs will switch to. If
  you are reading this in Info, try this now.  Evaluate the
  expression.

- In the programming examples in later section of this document, you
  will see the function ~set-buffer~ more often than
  ~switch-to-buffer~.  This because of a difference between computer
  program and humans: /Humans eyes and expect to see the buffer on
  which they are working on their computer terminals/.  This is so
  obvious, it almost goes without saying.  However program do not have
  eyes.  /When a computer program work on a buffer, that buffer does
  not have to be visible on the screen/.

- ~switch-to-buffer~ is designed for humans and does two different things:

  -- It switches the buffer to which Emacs's attention is directed;

  -- It switches the buffer in the window to the new buffer.

- ~set-buffer~ on other hand does only one thing:

  -- It switches the attention of the computer program to a different
  buffer.  The buffer on screen remain unchanged (of course, normally
  nothing happens there until the command finished running).

- Also, we have just introduced another jargon term, the word
  */call/*.  When you evaluate a list in which the first symbol is a
  function, you are calling that function.  The use of the term comes
  from the notion of the function as an entity that can do something
  for you if you call it--just a plumber is an entity who can fix a
  leak if you call him or her.

** Buffer Size and the location of Point

Finally, let's look at several rather simple function, ~buffer-size~,
~point~, ~point-min~, and ~point~max~.  These give information about
the size of a buffer and the location of point within it.

- The function ~buffer-size~ tells you the size of the current buffer,
  that is, the function returns a count of the number of characters in
  the buffer

  #+begin_src emacs-lisp
    (buffer-size)
  #+end_src

- In Emacs, the */current position of the cursor/* is called
  */point/*.  The expression ~(point)~ returns a number that tells you
  where the cursor is located as a count of the number of characters
  from the beginning of the buffer up to point.

  You can see character count for point in this buffer by evaluating
  the following expression in the usual way:

  #+begin_src emacs-lisp
    (buffer-size)49770 ; C-u C-x C-e
  #+end_src

  As I write this, the value of point is 49770. The ~point~ function is
  frequently used in some of the examples later in this book.

- The value of point depends, of course, on its location within the
  buffer. If you evaluate point in this spot, the number will be
  larger

  #+begin_src emacs-lisp
    (buffer-size)49775  ; C-u C-x C-e
  #+end_src

- For me, the value of point in this location is 49775, which means that
  there 49855 characters (including spaces) between the two
  expression. (Doubtles, you will see different numbers, since I will
  have edited this since I first evaluated point.

  #+begin_src emacs-lisp
    (point-min)1  ; C-u C-x C-e

    (point-max)50296  ; C-u C-x C-e
  #+end_src

- The function ~point-min~ is somewhat similar to ~point~, but it
  returns the value of the /minimum permissible/ value of point in the
  current buffer.  This is the number ~1~ unless /narrowing/ is in
  effect.  (Narrowing is a mechanism whereby you can restrict
  yourself, or a program, to operations on juts a part of a
  buffer. See Narrowing and Widening).

- Likewise, the function ~point-max~ returns the value of the maximum
  permissible value of point in the current buffer.


* How To Write Function Definition

- When the Lisp interpreter evaluates a list, it looks to see whether
  the first symbol on the list has a function definition attached to
  it; or, put another way, whether the symbol points to a function
  definition.  If it does, the computer carries out the instruction in
  the definition.  A symbol that has a function definition is called,
  simply, a function (although, properly speaking, the definition is
  the function and the symbol refers to it).

  - [[An Aside about Primitive Function][Primitive Function]]

  - [[The ~defun~ Macro][~defun~]]              The ~defun~ macro.

  - [[Install A Function Definition][install]]                     Install a function definition.

  - [[Make a Function Interactive][Interactive]]                 Making a function interactive.

  - [[Different Options for interactive][Interactive Options]]         Different options for ~interactive~.

  - [[Install Code Permanently][Permanent Installation]]      Installing code permanently.

  - [[let][let]]                         Creating and initializing local variables.

  - [[The ~if~ Special Form][if]]                      What if?

  - [[If-then-else Expression][else]]                        if-then-else expression.

  - [[Truth & Falsehood in Emacs Lisp][Truth & Falsehood]]           What Lisp considered false and true.

  - [[~save-excursion~][~save-excursion~]]            Keeping track of point and buffer.

  - [[Review][Review]]

** An Aside about Primitive Function

- /All function are defined in terms of other functions/,*except* for
  a few */primitive/* functions that are written in the C programming
  language.

- When you write functions' definitions, you will write them in Emacs
  Lisp and use other functions as your building blocks.  Some of the
  function you will use will themselves be written in Emacs Lisp
  (perhaps by you) and some will be primitives written in C.

- When you write code in Emacs Lisp, you d not distinguish between the
  use of function written in C and the use of functions written in
  Emacs Lisp.  The difference is irrelevant.  I mention the
  distinction only because it is interesting to know.  Indeed, unless
  you investigate, you won't know whether an already-written function
  is written in Emacs Lisp or C.

** The ~defun~ Macro

- In Lisp, a symbol such as ~mark-whole-buffer~ has code attached to
  it that tells the computer what to do when the function is called.
  This code is called the /function definition/ and is created by
  evaluating a Lisp expression that start with the symbol /defun/
  (which abbreviation for /define function/).

  In Subsequent sections, we will look at function definitions from
  the Emacs source code, such as ~mark-whole-buffer~.  In this
  section, we will describe a simple function definition so you can
  see how it looks.

  This function definition uses arithmetic because it makes for a
  simple example.  Some people dislike example using arithmetic;
  however, if you are such a person, do not despair.  Hardly any of
  the code we will study in the remainder of this introduction
  involves arithmetic or mathematics.  The examples mostly involve
  text in one way or another.

- A function definition has up to *five* parts following the word ~defun~:

  - The name of the symbol to which the function definition should be attached

  - A list of the /arguments/ that will be passed to the function.  If
    no arguments will be passed to the function, this is an empty list
    ~()~

  - Documentation describing the function. (Technically optional, but
    strongly recommended).

  - Optionally, an expression to make the function *interactive* so
    you can use it by typing ~M-x~ and then the name of the function;
    or by typing an appropriate key or key chord.

  - The code that instruct the computer what to do; the /body/ of the
    function definition.

- It is helpful to think of the /five parts/ of a function definition
  as being organized in a template, with slots for each part:

  #+begin_src emacs-lisp
    (defun function-name (arguments...)
      "optional-documentaion.."
      (interactive argument-passing-info)      ; optional
      body..)
  #+end_src

- As an example, here is the code for a function that multiplies its
  arguments by 7. (This example is *not interactive*)

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))
  #+end_src

  - The definition begin with a parenthesis and the symbol ~defun~,
    followed by the name of the function.

  - The name of the function is followed by a list that contains the
    arguments that will be passed to the function.  This list is
    called the /argument list/.  In this example, the list has only
    one element, the symbol, ~number~.  When the function is used, the
    symbol will be bound to the value that is used as argument to the
    function.

  - The argument list is followed by the documentation string that
    describes the function.  This is what you see when you type ~C-h
    f~ and the name of a function.  Incidentally, when you write a
    documentation string like this, you should make the first line a
    complete sentence since some commands, such /apropos/, print only
    the first line of a multi-line documentation string.  Also, you
    should not indent the second line of a documentation string, if
    you have one, because that looks odd when you use ~C-h f
    (describe-function)~.

  - The documentation string is optional, but it is so useful, it
    should be included in almost every function you write.

  - The third line of the example consist of the body of the function
    definition.  In this function, the body is the list, ~(* 7
    number)~, which says to multiply the value of /number/ by 7.

- When you use the ~multiply-by-seven~ function, the argument ~number~
  evaluates to the actual number you want used.  Here is an example
  that shows ~multiply-by-seven~ is used; but don't try to evaluate
  this yet!!.

  #+begin_src emacs-lisp
    (multiply-by-seven 3)
  #+end_src

  - The symbol ~number~, specified in the function in the next
    section, is bound to the value 3 in the actual use of the
    function.

  - Note that although ~number~ was inside parentheses in the function
    definition, the argument passed to the ~multiply-by-seven~ is not
    parentheses.  The parentheses are written in the function
    definition so the computer can figure out where argument list ends
    and the rest of the function definition begins.

- If you evaluate this example, you are likely to get an error
  message.  This is because we have written the function definition,
  but not yet told the computer about the definition--we have *not yet
  loaded the function definition in Emacs*.  Installing a function is
  the process that tells the Lisp interpreter the definition of the
  function.

** Install A Function Definition

- If you are reading this inside Info in Emacs, you can try out the
  ~multiply-by-seven~ function by first evaluating the function
  definition and then evaluating ~(multiply-by-seven 3)~.  A copy of
  the function definition follows.

- Place the cursor after the last parenthesis of the function
  definition and type ~C-x C-e~.  When you do this,
  ~multiply-by-seven~ will appear in the echo area.  (What this means
  is that when a function definition is evaluated, the value it
  returns is the name of the defined function).  At the same time,
  this action installs the function definition.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))
  #+end_src

- By evaluating this ~defun~, you have just *installed*
  ~multiply-by-seven~ in Emacs.  The function is now just as much as
  part of Emacs as ~forward-word~ or any other editing function you
  use.

- ~multiply-by-seven~ will stay installed until you quit Emacs.  To
  reload code automatically whenever you start Emacs, see Installing
  Code Permanently.

  -- [[The effect of installation][Effect of installation]]

  -- [[Change a Function Definition][Change a defun]]             How to change a function definition

*** The effect of installation

- You can see the effect of installing ~multiply-by-seven~ by evaluating
  the following sample.  Place the cursor after the following expression
  and the ~C-x C-e~.  The number 21 will appear in the echo area.

  #+begin_src emacs-lisp
    (multiply-by-seven 3)
  #+end_src

- If you wish, you can read the documentation for the function by
  typing ~C-h f (describe-function)~ and then the name of the
  function, ~multiply-by-seven~.  When you do this, a ~*Help*~ window
  will appear on your screen that says

  #+begin_src emacs-lisp
  multiply-by-seven is a Lisp function.

  (multiply-by-seven NUMBER)

  Multiply NUMBER by seven.
  #+end_src

*** Change a Function Definition

- If you want to change the code in ~multiply-by-seven~, just rewrite
  it.  To install the new version in place of the old one, evaluate
  the function definition again.  This is how you modify code in
  Emacs.  It is very simple.

- As an example, you can change the ~multiply-by-seven~ function to
  add the number to itself seven times instead of multiplying the
  number by seven.  It produces the same answer, but by a different
  path.  At the same time, we will add comment to the code; a comment
  is text that Lisp interpreter ignores, but that a human reader may
  find useful or enlightening.

- The comment is that this is the second version.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)         ; Second version
      "Multiply NUMBER by seven."
      (+ number number number number number number number))
  #+end_src

- The comment follows a semicolon '~;~'.  In Lisp, everything on a
  line that follows a semicolon is a comment.  The end of the line is
  the end of the comment.  To stretch a comment or two or more lines,
  begin each lines with a semicolon.

- See Beginning a .emacs File, and Comments in The GNU Emacs Lisp
  Reference Manual, for more about comments.

- You can install the version of the ~multiply-by-seven~ function by
  evaluating it in the same way you evaluated the first function:
  place the cursor after the last parenthesis and type ~C-x C-e~.

- In summary, this is how you write code in Emacs Lisp: you write a
  function; install it; test it; and then make fixes or enhancements
  and install it again.

** Make a Function Interactive

- You make a function interactive by placing a list that begins with the
  special form ~interactive~ immediately after the documentation.  A
  user can invoke an interactive function by typing ~M-x~ and then the
  name of the function; or by typing the keys to which it is bound;
  for example, by typing ~C-n~ for ~next-line~ or ~C-x h~ for
  ~mark-whole-buffer~.

- Interestingly, when you call an interactive function interactively,
  the value returned is not automatically displayed in the echo area.
  This is because you often call an interactive function for its side
  effects, such as moving forward by a word or line, and /not for the
  value returned/.  If the returned value were displayed in the echo
  area each time you typed a key, it would be very distracting.


  -- [[An Interactive multiply-by-seven, An Overview][ An Interactive multiply-by-seven]]       An overview

  -- [[An Interactive ~multiply-by-seven~][multiply-by-seven in detail]]             The interactive version

*** An Interactive multiply-by-seven, An Overview

- Both the use of the special form ~interactive~ and one way to display
  a value in the echo area can be illustrated by creating an interactive
  version of ~multiply-by-seven~.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)           ; Interactive version
      "Multiply NUMBER by seven."
      (interactive "p")
      (message "the result is %d" (* 7 number)))
  #+end_src

- You can install this code by placing your cursor after it and typing
  ~C-x C-e~. The name of the function will appear in your echo area.
  Then, you can use this code by typing ~C-u~ and a number and then
  typing ~M-x multiply-by-seven~ and pressing ~RET~.  The phrase '~The
  result is ...~' followed by the product will appear in the echo
  area.

- Speaking more generally, you invoke a function like this in either
  of two ways:

  1. By typing a prefix argument that contains the number to be
     passed, and then typing ~M-x~ and the name of the function, as
     which "~C-u 3 M-x forward-sentence~"; or,

  2. By typing whatever key or key chord the function is bound to,
     with ~C-u 3 M-e~.

  - Both the examples just mentioned work identically to move point
    forward three sentences. (Since ~multiply-by-seven~ is not bound
    to any key, it could not be used as an example of key binding.).

- A /prefix argument/ is passed to an interactive function by typing
  the ~META~ key followed by a number, for example, ~M-3 M-e~, or by
  typing ~C-u~ and then a number, for example, ~C-u 3 M-e~ (if you
  type ~C-u~ without a number, it defaults to 4).

*** An Interactive ~multiply-by-seven~

- Let's look at the use of the special from ~interactive~ and then at
  the function ~message~ in the interactive version of
  ~multiply-by-seven~.  You will recall that the function definition looks like this:

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)           ; Interactive version
      "Multiply NUMBER by seven."
      (interactive "p")
      (message "The result is %d" (* 7 number)))
  #+end_src

- In this function, the expression, ~(interactive "p")~, is a list of
  two elements.  The ~"p"~ tells Emacs to pass the prefix argument to
  the function and use its value for the argument of the function.

- The argument will be a number.  This means that the symbol ~number~
  will be bound to a number in the line:

  #+begin_src emacs-lisp
    (message "The result is %d" (* 7 number))
  #+end_src

- For example, if you prefix argument is 5, the Lisp interpreter will
  evaluate the line as if it were:

  #+begin_src emacs-lisp
    (message "The result is %d" (* 7 5))
  #+end_src

- (If you are reading this in GNU Emacs, you can evaluate this
  expression yourself). First, the interpreter will evaluate the inner
  list, which ~(* 7 5)~.  This returns a value of 35.  Next, it will
  evaluate the outer list, passing the values of the second and
  subsequent elements of the list to the function ~message~.

- As we have seen, ~message~ in Emacs Lisp function especially
  designed for sending a one line message to a user.  In summary, the
  ~message~ function prints its first argument in the echo area as is,
  except for occurrences of '~%d~' and '~%s~' (and various other
  %-sequences which we have not mentioned).  When it sees a control
  sequence, the function looks to the second or subsequent arguments
  and prints the value of the argument in the location in the string
  where the control sequence is located.

- In the interactive ~multiply-by-seven~ function, the control string
  is '~%d~', which requires a number, and the value returned by
  evaluating ~(* 7 5)~ is the number 35.  Consequently, the number 35
  is printed in place of the '~%d~' and the message is '~The result is
  35~'.

- Note that when you call the function ~multiply-by-seven~, the
  message is printed without quotes, but when you call ~message~, the
  text is printed in double quotes.  This is because the value
  returned by ~message~ is what appears in the echo area when you
  evaluate an expression whose first element is ~message~; but when
  you embedded in a function, ~message~ prints the text as a /side
  effect/ without quotes.

** Different  Options for interactive

- In the example, ~multiply-by-seven~ used ~"p"~ as the argument to
  ~interactive~.  This argument told Emacs to interpret your typing
  either ~C-u~ followed by number or ~META~ followed by a number as a
  command to pass that number to the function argument.  Emacs has more
  that twenty characters predefined for use with ~interactive~.  In
  almost case, one of these options will enable you to pass the right
  information interactively to a function.  (See Code Characters for
  ~interactive~) in the GNU Emacs Lisp Reference Manual.)

- Consider the function ~zap-to-char~. Its interactive expression is

  #+begin_src emacs-lisp
    (interactive "p/ncZap to char: ")
  #+end_src

  - The first part of the argument to ~interactive~ is '~p~', with
    which you are already familiar.  This argument tells Emacs to
    interpret a prefix, as a number to be passed to a the function.
    You can specify a prefix either by typing ~C-u~ followed by a
    number or by typing ~META~ followed by a number.

  - The prefix is the number of specified characters.  Thus, if your
    prefix is three and the specified character is '~x~', then you
    will delete all the text up to and including the third next '~x~'.
    If you do not set a prefix, then you delete all the text up to an
    including the specified character, but no more.

  - The '~c~' tells the function the name of the character to which to
    delete.

  - More formally, a function with two or more arguments can have
    information passed to each argument by adding parts to the string
    that follows ~interactive~.  When you do this, the information is
    passed to each arguments in the same order it is specified in the
    ~interactive~ list.  In the string, each part is separated from
    the next part by a '~\n~', which is a newline.  For example, you
    can follow '~p~' with a '~/n~' and an '~cZap to char: ~'. This
    causes Emacs to pass the value of the prefix argument (if there is
    one) and the character.

  - In this case, the function definition looks like the following,
    where ~arg~ and ~char~ are the symbol to which ~interactive~ binds
    the prefix argument and the specified character:

    #+begin_src emacs-lisp
      (defun name-of-function (arg char)
        "Documentation..."
        (interactive "p/ncZap to char: ")
        body-of-function...)
    #+end_src

  - (The space after the colon in the prompt makes it look better when
    you are prompted. See The Definition of ~copy-to-buffer~, for an
    example)

  - When a function does not take arguments, ~interactive~ does not
    require any.  Such a function contains the simple expression
    ~(interactive)~.  The ~mark-whole-buffer~ function is like this.

  - Alternatively, if the special letter-codes are not right for your
    application, you can pass your own arguments to ~interactive~ as a list.

  - See The Definition of ~append-to-buffer~, for an example.  See
    Using Interactive in The GNU Emacs Lisp Reference Manual, for a
    more explanation about this technique.

** Install Code Permanently

- When you install a function definition by evaluating it, it will
  stay installed until you quit Emacs.  The next time you start a new
  session of Emacs, the function will not be installed unless you
  evaluate the function definition again.

- At some point, you may want to have code installed automatically
  whenever you start a new session of Emacs.  There are several ways
  of doing this:

  * If you have code that is just for yourself, you can put the code
    for the function definition in your ~.emacs~ initialization file.
    When you start Emacs, your ~.emacs~ file is automatically
    evaluated and all the function definition within it are
    installed. See Your ~.emacs~ File.

  * Alternatively, you can put the function definitions that you want
    installed in one or more files of their own and use the ~load~
    function to cause Emacs to evaluate and thereby install each of
    the function in this files.  See Loading Files.

  * Thirdly, if you have code that your whole site will use, it is
    usual to put it in a file called ~site-init.el~ that is loaded
    when Emacs is built.  This makes the code available to everyone
    who use your machine.  (See the ~INSTALL~ file that is part of the
    Emacs distribution.)

- Finally, if you have a code that everyone who use Emacs may want,
  you can post it on a computer network or send a copy to Free
  Software Foundation.  (When you do this, please license the code and
  its documentation under a license that permit other people to run,
  copy, study, modify, and redistribute the code and which protects
  you from having your work taken from you.)

- If you send a copy of your code to the Free Software Foundation, and
  properly protect yourself and others, it may be included in the next
  release of Emacs. In large part, this is how Emacs has grown over
  the past years, by donations.

** let

- The ~let~ expression is a special form in Lisp that you will need to
  use in most function definitions.

- ~let~ is used to attach or bind a symbol to a value in such a way
  the Lisp interpreter will not confuse the variable with a variable
  of the same name that is not part of the function.

- To understand why the ~let~ special form is necessary, consider the
  situation in which you own a home that you generally refer to as
  "the house", as in the sentence, "The house needs painting."  If you
  are visiting a friend and your host refer to "the house", he is
  likely to be referring to /his/ house, not yours, that is, to a
  different house.

- If your friend is referring to his house and you think he is
  referring to your house, you may be in for some confusion.  The same
  thing could happen in Lisp if a variable that is used inside of one
  function has the same name as a variable that is used of another
  function, and the two are not intended to refer to the same value.
  The ~let~ special form prevents this kind of confusion.

  -- [[~let~ Prevent confusion][Prevent confusion]]

  -- [[The Parts of a ~let~ Expression][Parts of let Expression]]

  -- [[Sample ~let~ Expression][Sample let Expression]]

  -- [[Uninitialized Variables in a ~let~ Statement][Initialized let Variables]]

*** ~let~ Prevent confusion

- The ~let~ special form prevent confusion. ~let~ creates a name for a
  /local variable/ that overshadows any use of the same name outside
  the ~let~ expression.  This is like understanding that whenever your
  host refers to "the house", he means his house, not yours.  (Symbol
  used in argument list work the same way. See The ~defun~ Macro).

- Local variables created by ~let~ expression retain their value
  /only/ within the ~let~ expression itself (and within expression
  called within the ~let~ expression); the local variables have no
  effect outside the ~let~ expression.

- Another way to think about ~let~ is that it is like a ~setq~ that is
  temporary and local.  The value set by ~let~ are automatically
  undone when the ~let~ is finished.  The setting only affects
  expressions that are inside the bounds of the ~let~ expression.

- In computer jargon, we would say the binding of a symbol is visible
  only in functions called in the ~let~ form; in Emacs Lisp, the
  default scoping is dynamic, not lexical. (The non-default lexical
  binding is not discussed in this manual.)

- ~let~ can create more than one variable at once.  Also, ~let~ gives
  each variable it creates an initial value, either a value specified
  by you, or ~nil~.  (In the jargon, this is binding the variable to
  the value.).

- After ~let~ has created and bound the variables, it /executes/ the
  code in the body of the ~let~, and returns the value of the last
  expression in the body, as the value of the whole ~let~ expression.

- "Execute", is a jargon term that means to evaluate a list; it comes
  from the use of the word meaning "to give practical effect to"
  (Oxford English Dictionary).  Since you evaluate an expression to
  perform an action, "execute" has evolved as a synonym to "evaluate".

*** The Parts of a ~let~ Expression

- A ~let~ expression is list of *three parts*.

  - The first part is the symbol ~let~,

  - The second part is a list, called a /varlist/, each element of
    which is either a symbol by itself or two-element list, the first
    element of which is a symbol.

  - The third part is the body of the ~let~.  The body usually
    consists of one or more lists.

- A template for a ~let~ expression looks like this:

  #+begin_src emacs-lisp
    (let varlist body...)
  #+end_src

- If the varlist is composed of two-element lists, as is often the
  case, the template for the ~let~ expression looks like this:

  #+begin_src emacs-lisp
    (let ((varlist value)
          (varlist value)
          ..)
      body...)
  #+end_src

*** Sample ~let~ Expression

- The following expression creates and gives initial value to the two
  variables ~zebra~ and ~tiger~.  The body of the ~let~ expression is
  a list which calls the ~message~ function.

  #+begin_src emacs-lisp
    (let ((zebra "stripes")
          (tiger "fierce"))
      (message "One kind of animal has %s and another is %s."
               zebra tiger))
  #+end_src

- Here, the varlist is ~(zebra "stripes") (tiger "fierce"))~.

- The two variables are ~zebra~ and ~tiger~.  Each variable is the
  first element of a two-element list and each value is the second
  element of its two-element list.

- In the varlist, Emacs binds the variable ~zebra~ to the value
  "~stripes~", and binds the variable ~tiger~ to the value "~fierce~".
  In this example, both values are strings.  The value could just as
  well have been another list or a symbol.

- The body of the ~let~ follows after the list holding the variables.
  In this example, the body is a list that uses the ~message~ function
  to print a string in the echo area.

- You many evaluate the example in the usual way, by placing the
  cursor after the last parenthesis and typing ~C-x C-e~.  When you do
  this, the following will appear in the echo area:

  #+begin_src emacs-lisp
    "One kind of animal has stripes and another is fierce"
  #+end_src

- As we have seen before, the ~message~ function prints its first
  argument, except for '~%s~'.  In this example, the value of the
  variable ~zebra~ is printed at the location of the first '~%s~' and
  the value of the variable ~tiger~ is printed at the location of the
  second '~%s~'.

*** Uninitialized Variables in a ~let~ Statement

- If you do not bind the variables in a ~let~ statement to specific
  initial values, they will automatically be bound to an initial value
  of ~nil~, as the following expression:

  #+begin_src emacs-lisp
    (let ((birch 3)
          pine
          fir
          (oak 'some))
      (message
       "Here are %d variables with %s, %s, and %s value."  birch
       pine fir oak))
  #+end_src

- Here, the varlist is ~(birch 3) pine fir (oak 'some))~.

- If you evaluate this expression in the usual way, the following will
  appear in your echo area:

  #+begin_src emacs-lisp
    "Here are 3 variabels with nil, nil, and some value."
  #+end_src

- In this example, Emacs binds the symbol ~birch~ to the number 3,
  binds the symbol ~pine~ and ~fir~ to ~nil~, and binds the symbol
  ~oak~ to the value ~some~.

- Note that in the first part of the ~let~, the variables ~pine~ and
  ~fir~ stand alone as atoms that are not surrounded by parentheses;
  this is because they are being bound to ~nil~, the empty list.  But
  ~oak~ is bound to ~some~ and so is a part of the list ~(oak 'some)~.
  Similarly, ~birch is bound to the number 3 and so is in a list with
  that number.  (Since a number evaluates to itself, the number does
  not need to be quoted.  Also, the number is printed in the message
  using a '~%d~' rather than a '~%s~'.) The four variables as a group
  into a list to delimit them from the body of the ~let~.

** The ~if~ Special Form

- Another special form is the condition ~if~.  This form is used to
  instruct the computer to make decisions.  You can write function
  definitions without using ~if~, but it is used often enough, and is
  important enough, to be included here.  It is used, for example, in
  the code for the function ~beginning-of-buffer~.

- The basic idea behind and ~if~, is that /if/ a test is *true*,
  /then/ an expression is *evaluated*.  If the test is *not true*, the
  expression is *not evaluated*.  For example, you might make a
  decision such as, "if it is warn and sunny, then go to the beach!"

  - [[~if~ in more detail][~if~ in more detail]]

  - [[The ~type-of-animal~ Function in Detail][~type-of-animal~ in detail]]     An example of an ~if~ expression.

*** ~if~ in more detail

- An ~if~ expression written in Lisp does not use the word "then"; the
  test and the action are the second and third elements of the list
  whose first element is ~if~.  Nonetheless, the test part of an ~if~
  expression is often called the /if-part/ and the second argument is
  often called the /then-part/.

- Also, when an ~if~ expression is written, the true-or-false is
  usually written on the same lines as the symbol ~if~, but the action
  to carry out if the test is true, the then-part, is written on the
  second and subsequent lines.  This makes the ~if~ expression is
  easier to read.

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-test-is-true)
  #+end_src

- The true-or-false test will be an expression that is evaluated by
  the Lisp interpreter.

- Here is an example that you can evaluate in the usual manner.  The
  test is whether the number 5 is greater than the number 4.  Since it
  is, the message "~5 is greater than 4!~' will be printed.

  #+begin_src emacs-lisp
    (if (> 5 4)                                 ; if-part
        (message "5 is greater than 4!"))       ; then-part
  #+end_src

  - The function ~>~ test whether its first argument is greater than
    its second argument and returns true if it is.

- Of course, in actual use, the test in an ~if~ expression will not be
  fixed for all time as it is by the expression ~(< 5 4)~.  Instead,
  at least one of the variables used in the test will be bound to a
  value that is not known ahead of time.  (If the value were known
  ahead of time, we would not need to run the test!)

- For example, the value may be bound to an argument of a function
  definition.  In the following function definition, the character of
  the animal is a value that is passed to the function. If the value
  bound to ~characteristic~ is "~fierce~", then the message, '~it is a
  tiger!~' will printed; otherwise, ~nil~ will be returned.

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)
      "Print message in echo area depending on CHARACTERISTIC.
        If the CHARACTERISTIC is the string \"fierce\",
    then warn of a tiger"
      (if (equal characteristic "fierce")
          (message "It is a tiger!")))
  #+end_src

- If you are reading this inside of GNU Emacs, you can evaluate the
  function definition in the usual way to install it in Emacs, and
  then you can evaluate the following two expression to see the
  results:

  #+begin_src emacs-lisp
    (type-of-animal "fierce")

    (type-of-animal "striped")
  #+end_src

- When you evaluate ~(type-of-animal "fierce")~, you will see the
  following message printed in the echo area: ~"it is a tiger!"~; and
  when you evalute ~(type-of-animal "stripe")~ you will see ~nil~
  printed in the echo area.

*** The ~type-of-animal~ Function in Detail

- Let's looks at the ~type-of-animal~ function in detail.

- The function definition for ~type-of-animal~ was written by filling
  the slots of two templates, one for a function definition as a
  whole, and a second for an ~if~ expression.

- The template for every function that is not /interactive/ is:

  #+begin_src emacs-lisp
    (defun name-of-function (argument-list)
      "documentation.."
      body..)
  #+end_src

- The part of the function that match this templates look like this:

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)
      "Print message in echo area depending on CHARACTERISTIC.
        If the CHARACTERISTIC is the string \"fierce\",
    then warn of a tiger."
      body: the if expression)
  #+end_src

- The name of function is ~type-of-animal~; it is passed the value of
  one argument.  The argument list is followed by a multi-line
  documentation string.  The documentation string is included in the
  example because it is a good habit to write documentation string for
  every function definition.  The body of the function definition
  consists of the if~ expression.

- The template for an ~if~ expression looks like this:

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-the-test-returns-true)
  #+end_src

- In the ~type-of-animal~ function, the code for the ~if~ looks like this:

  #+begin_src emacs-lisp
    (if (equal characteristic  "fierce")
        (message "It is a tiger!"))
  #+end_src

- Here, the true-or-false-test is the expression:

  #+begin_src emacs-lisp
    (equal characteristic "fierce")
  #+end_src

- In Lisp, ~equal~ is a function that determines whether its first
  argument is equal to its second argument.  The second argument is
  the string ~"fierce"~ and the first argument is the value of the
  symbol ~characteristic~--in other words, the argument passed to this
  function.

- In the first exercise of ~type-of-animal~, the argument ~"fierce"~
  is passed to ~type-of-animal~.  Since ~"fierce"~ is equal to
  ~"fierce"~, the expression, ~(equal characteristic "fierce")~,
  returns a value of /true/.  When this happens, the ~if~ evaluates
  the second argument or then-part of the ~if~: ~(message "It is a
  tiger!")~.

- On the other hand, in the second exercise of the ~type-of-animal~,
  the arguments ~"striped"~ is passed to
  ~type-of-animal"~. ~"striped"~ is not equal to ~"fierce"~, so the
  then-part is not evaluated and ~nil~ is returned by the ~if-
  expression.

** If-then-else Expression

- An ~if~ expression may have an optional third argument, called the
  /else-part/, for the case when the true-or-false-test returns false.
  When this happens, the second argument or then-part of the overall
  ~if~ expression is /not/ evaluated, but the third or else-part /is/
  evaluated.  You might think of this as cloudy day alternative for
  the decision "if it warn and sunny, then go to the beach, else read
  a book!".

- The word "else" is not written in the Lisp code; the else-part of an
  ~if~ expression comes after the then-part.  In the written Lisp, the
  else-part is usually written to start on a line of its own and is
  indented less than the then-part:

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-the-test-returns-true
      action-to-carry-out-if-the-test-returns-false)
  #+end_src

- For example, the following ~If~ expression prints the message ~"4
  not greater than 5!"~ when you evaluate it in the usual way:

  #+begin_src emacs-lisp
    (if (> 4 5)                                 ; if-part
        (message "4 falsely greater than 5!")   ; then-part
      (message "4 is not greater than 5!"))     ; else-part
  #+end_src

- Note that the /different levels of indentation/ make it easy to
  distinguish the then-part from the else-part.

- We can extend the ~type-of-animal~ function t include an else-part by
  simply incorporating an additional part of the ~if~ expression.

- You can see the consequences of doing this if you evaluate the
  following version of the ~type-animal- function to install it and
  then evaluate the two subsequent expression to pass different
  argument to the function.

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)              ; Second version
      "Print message in echo area depending on CHARACTERISTIC.
              If the CHARACTERISTIC is the string \"fierce\",
              then warn of a tiger; else say it is not fierce."
      (if (equal characteristic "fierce")
      (message "It is a tiger!")
      (message "It is not fierce!")))
  #+end_src

  #+begin_src emacs-lisp
    (type-of-animal "fierce")

    (type-of-animal "striped")
  #+end_src

- When you evaluate ~(type-of-animal "fierce")~, you will see the
  following message printed in the echo area: ~"It is a tiger!"~; but
  when you evaluate ~(type-of-animal "stripes")~, you will see ~"It is
  not fierce!"~.

- Of course, i the /characteristic/ were ~"ferocious"~, the message
  ~"It is not fierce!"~ would be printed; and it would be misleading!
  When you write code, you need to take into account the possibility
  that some such argument will be tested by the ~if~ and write your
  program accordingly

** Truth & Falsehood in Emacs Lisp

- There is an important aspect to the truth test in an ~if~
  expression.  So far, we have spoken if "true" and "false" as values
  of predicates as if they were new kinds of Emacs of Emacs Lisp
  objects.  In fact, "false" is just our old friend ~nil~.  Anything
  else--anything at all--is "true".

- The expression that test for truth is interpreted as /true/ if the
  result of evaluating it is a value that is not ~nil~.  In other
  words, the result of the test is considered true if the value
  returned is a /number/ such as 47, a /string/ such as ~"hello"~, or
  a /symbol/ (other than ~nil~) such as ~flowers~, or a /list/ (so
  long as it is not empty) or even a /buffer/!.

  - [[An explanation of ~nil~][nil explained]]        ~nil~ has two meaning

*** An explanation of ~nil~

- Before illustrating a test for truth, we need an explanation of
  ~nil~.

- In Emacs Lisp, the symbol ~nil~ has two meanings. First, it means
  the empty list.  Second, it means false and is the value returned
  when a true-or-false-test tests false.  ~nil~ can be written as an
  empty list, ~()~, or as ~nil~.  As far as the Lisp interpreter is
  concerned, ~()~ and ~nil~ are the same.  Humans, however, tend to
  use ~nil~ for false and ~()~ for the empty list,

- In the first example, the number 4 is evaluated as the test in the
  ~if~ expression and returns itself; consequently, the then-part of
  the expression is evaluated and returned: ~'true'~ appears in the
  echo area.  In the second example, the ~nil~ indicates false,
  consequently, the else-part of the expression is evaluated and
  returned: ~'false'~ appears in the echo area.

  #+begin_src emacs-lisp
    (if 4
        'true
      'false)

    (if nil
        'true
      'false)
  #+end_src

- Incidentally, if some other useful value is not available for a test
  that returns true, then the Lisp interpreter will return the symbol
  ~t~ for true.  For example, the expression ~(> 5 4)~ returns ~t~
  when evaluated, as you can see by evaluating it in the usual way:

  #+begin_src emacs-lisp
    (> 5 4)
  #+end_src

  on the other hand, this function ~nil~ if the else is false.

  #+begin_src emacs-lisp
    (> 4 5)
  #+end_src

** ~save-excursion~

- The ~save-excursion~ function is the final special form that we will
  discuss in this chapter.

- In Emacs Lisp programs used for editing, the ~save-excursion~
  function is very common.  It saves the location of point, executes
  the body of the function, and the restores point to its previous
  position if its location was changed.  It primary purpose is to keep
  the user being surprised and disturbed by unexpected movement of
  point.

  -- [[Point and Mark][Point and Mark]]

  -- [[Template for a ~save-excursion~ Expression][Template for ~save-excursion]]

*** Point and Mark

- Before discussing ~save-excursion~, however, it may be useful first
  to review what point and mark are in GNU Emacs.  /Point/ is the
  *current location of the cursor*.  Whenever the cursor is, that is
  point.  More precisely, on terminals where the cursor appears to be
  on top of a character, point is immediately before the character.
  In Emacs Lisp, point is an *integer*.  The first character in a
  buffer is number one, the second is number two, and so on.  The
  function ~point~ returns the current position of the cursor as a
  number.  Each buffer has its own value for point.

- The /mark/ is another position in the *buffer*; its value can be set
  with a command such as ~C-SPC (set-mark-command)~.  If a mark has
  been set, you can use the command ~C-x C-x
  (exchange-point-and-mark)~ to cause the cursor to jump to the mark
  and set the mark to be the previous position of point.  In addition,
  if you set another mark, the position of the previous mark is saved
  in the mark ring.  Many mark positions can be saved this way.  You
  can jump the cursor to a saved mark by typing ~(C-u C-SPC)~ one or
  more times.

- The part of the buffer between point and mark is called /the
  region/.  Numerous commands work on the region, including
  ~center-region~, ~count-lines-region~, ~kill-region~, and
  ~print-region~.

- The ~save-excursion~ special form saves the location point and
  restore this point and restore this position after the code within
  the body of the special form is evaluated by the Lisp interpreter.
  Thus if point were in the beginning of a piece of text and some code
  moved point to the he end of the buffer, the ~save-excursion~ would
  put point back to where it was before, after the expression in the
  body of the function were evaluated.

- In Emacs, a function frequently moves point as part of its internal
  workings even though a user would not expect this.  For example,
  ~count-lines-region~ moves point.  To prevent the user from being
  bothered by jumps that are both unexpected and (from the user's
  point of view) unnecessary, ~save-excursion~ is often used to keep
  point in the location expected by the user.  The use of
  ~save-excursion- is *good housekeeping*.

- To make sure the house stays clean, ~save-excursion~ restores the
  value of point even if something goes wrong in the code inside of it
  (or, to be more precise and to use the proper jargon, "in case of
  abnormal exit").  This is feature is very helpful.

- In addition to recording the value of point, ~save-excursion~ keeps
  track of the current buffer, and restore it, too.  This means you
  can write code that will change the buffer and have ~save-excursion~
  switch you back to the original buffer.  This is how
  ~save-excursion~ is used in ~append-to-buffer~.  (See The Definition
  of ~append-to-buffer~).

*** Template for a ~save-excursion~ Expression

- The template for a ~save-excursion~ is simple:

  #+begin_src emacs-lisp
    (save-excursion
      body...)
  #+end_src

- The body of the function is one or more expressions that will be
  evaluated in sequence by the Lisp interpreter.  If there is more
  than one expression in the body, the value of the last one will be
  returned as the value of the ~save-excursion~ function.  The order
  expressions in the body are evaluated only for their side effects;
  and ~save-excursion~ itself is used only for its side effect (which
  is restoring the position of point).

- In more detail, the template for a ~save-excursion~ expression looks like this:

  #+begin_src emacs-lisp
    (save-excursion
      first-expression-in-body
      secon-expression-in-body
      third-expression-in-body
      ...
      last-expression-in-body)
  #+end_src

- An expression, of course, may be a symbol on its own or a list.

- In Emacs Lisp code, a ~save-excursion~ expression often occurs
  within the body of a ~let~ expression. It looks like this:

  #+begin_src emacs-lisp
    (let varlist
      (save-excursion
        body..))
  #+end_src

** Review

- In the last few chapter we have introduced a macro and a fair number
  of function and special forms.  Here they are describe in brief,
  along with a few similar function that have not been mentioned yet.

- ~eval-last-sexp~

  Evaluates the last symbolic expression before the current location
  of point.  The value is printed in the echo area unless the function
  is invoked with an argument; in the case, the output is printed in
  the current buffer.  This command is normally bound to ~C-x C-e~.

- ~defun~

  Define function.  This macro has up to five parts: /the name/, /a
  template/ for arguments that will be passed to the function,
  /documentation/, an optional /interactive declaration/, and the
  /body/ of the definition.

  For example, in Emacs the function definition of
  ~dired-unmark-all-marks~ is as follows.

  #+begin_src emacs-lisp
    (defun dired-unmark-all-marks ()
      "Remove all marks from all files in the Dired buffer."
      (interactive)
      (dired-unmark-all-files ?\r))
  #+end_src

- ~interactive~

  Declare to the interpreter that the function can be used
  interactively.  This special form my be followed by a string with
  one or more parts that pass in the information to the arguments of
  the function, in sequence.  These parts may be also tell the
  interpreter to prompt for information.  Parts of the string are
  separated by newlines, ~'\n'~.

  Common code characters are:

  - ~b~

     The name of existing buffer

  - ~f~

     The name of existing file

  - ~p~

     The numeric prefix argument. (Note that this ~p~ is lower
    case.)

  - ~r~

    Point and the mark, as two arguments, smallest first.  This is
    the only code letter that specified two successive argument rather
    than one.

- ~let~

  Declare that a list of variables is for use within the body of the
  ~let~ and give them an initial value, either ~nil~ or a specified
  value; then evaluate the rest of the expression in the body of the
  ~let~ and return the value of the last one.  Inside the body of the
  ~let~, the Lisp interpreter does not see the values of the variables
  of the same names that are bound outside of the ~let~.

  For example,

  #+begin_src emacs-lisp
    (let ((foo (buffer-name))
          (bar (buffer-size)))
      (message
       "This buffer is %s and has %d characters."
       foo bar))
  #+end_src

- ~save-excursion~

  Record the values of point and the current buffer before evaluating
  the body of this special form.  Restore the value of point and
  buffer afterward.

  For example,

  #+begin_src emacs-lisp
    (message "We are %d characters into this buffer."
             (- (point)
                (save-excursion
                  (goto-char (point-min)) (point))))
  #+end_src

- ~if~

  Evaluate the first argument to the function; if is true, evaluate
  the second argument; else evaluate the third argument, if there is
  one.

  The ~if~ special form is called a /conditional/.  There are other
  conditional in Emacs Lisp, but ~if~ is perhaps the most commonly
  used.

  for example,

  #+begin_src emacs-lisp
    (if (= 27 emacs-major-version)
        (message "This is version 27 Emacs")
      (message "This is not version 27 Emacs"))
  #+end_src

- ~<~, ~>~, ~<=~, ~>=~

  The ~<~ function test whether its first argument is smaller than its
  second argument.  A corresponding function, ~>~, tests whether the
  first argument is greater than the second.  Likewise ~<=~ test
  whether the first argument is less than or equal to the second and
  ~>=~ test whether the first argument is greater than or equal to the
  second .  In all cases, both arguments must be /numbers/ or
  /markers/ (markers indicate position in buffers).

- ~=~

  The ~=~ function test whether two arguments, both numbers or
  markers, are equal.

- ~equal~, ~eq~

  Test whether two objects are the same. ~equal~ uses one meaning of
  the word "same" and ~eq~ uses another; ~equal~ returns true if the
  two objects have a similar structure and contents, such as two
  copies of the same book.  On the other hand, ~eq~, returns true if
  both arguments are actually the same /object/.

- ~string<~, ~string-lessp~, ~string=~, ~string-equal~

  The ~string-lessp~ function tests whether its first arguments is
  smaller than the second argument.  A shorter, alternative name for
  the same function (a ~defalias~) is ~string<~.

  The arguments to ~string-lessp~ must be /strings/ or /symbols/; the
  ordering is lexicographic, so case is significant.  The print names
  of symbols are used instead of the symbol themselves.

  An empty string, ~""~, a string with no characters in it, is smaller
  than any string of characters.

- ~message~

  Print a message in the echo area. The first argument is string that
  can contain '~%s~', '~$d~', or '~%c~' to print the value of
  arguments that follow the string.  The argument used by '~%s~' must
  be a string or a symbol; the argument '~%d~' must be a number.  The
  argument '~%c~' must be an ASCII code number; it will be printed as
  the character with that ASCII code.  (Various other %-sequence have
  not been mentioned.)

- ~setq~, ~set~

  The ~setq~ special form sets the value of its first argument to the
  value of the second argument.  The first argument is automatically
  quoted by ~setq~.  It does the same for succeeding pairs of
  arguments.  An other function, ~set~, takes only two arguments and
  evaluates both of them before setting the value returned by its
  first argument to the value returned by its second argument.

- ~buffer-name~

  Without an argument, return the name of the buffer, as a string.

- ~buffer-file-name~

  Without an argument, return the name of the buffer, as a string.

- ~current-buffer~

  Return the buffer in which Emacs is active; it may not the buffer is
  visible on the screen

- ~other-buffer~

  Return the most recently selected buffer (other than the buffer
  passed to ~other-buffer~ as an argument and other than the current
  buffer).

- ~switch-buffer~

  Select a buffer for Emacs to be active in and display in the current
  window so users can look at it.  Usually bound to ~C-x C-b~

- ~set-buffer~

  Switch Emacs's attention to a buffer on which programs will run.
  Don't alter what the window is showing.

- ~buffer-size~

  Return the number of character in the current buffer.

- ~point~

  Return the value of the current position of the cursor, as an
  integer counting the number of characters from the beginning of the
  buffer.

- ~point-min~

  Return the minimum permissible value of point in the current buffer.
  This is 1, unless narrowing is in effect.

- ~point-max~

  Return the value of the maximum permissible value of point in the
  current buffer.  This is the end of the buffer, unless narrowing is
  in effect.


* A few Buffer-Related Functions

- In This chapter we study in detail several of the function used in
  GNU Emacs.  This is called a "walk-through".  These functions are
  used as example of Lisp code, but are not imaginary examples; with
  the exception of the first, simplified function definition, these
  functions show the actual code used in GNU Emacs.  You can learn a
  great deal from these definitions.

- These function described here are all related to *buffers*. Later,
  we will study other function.

  - [[Finding More Information][Finding More]]        How to find more information.

  - [[A Simplified ~beginning-of-buffer~ Definition][simplified-beginning-of-buffer]]        Show ~goto-char~, ~point-min~,and ~push-mark~.

  - [[The Definition of ~mark-whole-buffer~][mark-whole-buffer]]             Almost the same as ~beginning-of-buffer~.

  - [[the definition of ~append-to-buffer~][append-to-buffer]]              Uses ~save-excursion~ and ~insert-buffer-substring~.

  -[[Review][Buffer Related Review]]  Review

** Finding More Information

- In this walk-through, I will describe each new function as we come
  to it, sometimes in detail and sometimes briefly.  If you are
  interested, you can get the full documentation of any Emacs Lisp
  function at any time by typing ~C-h f~ and then the name of the
  function (and then ~RET~).  Similarly, you can get the full
  documentation for a variable by typing ~C-h v~ and then the name of
  the variable (and then ~RET~).

- Also, ~describe-function~ will tell you the location of the function location.

- Put point into the name of the file that contains the function and
  press the ~RET~ key.  In this case, ~RET~ means ~push-button~ rather
  than "return" or "enter".  Emacs will take you directly to the
  function definition.

- More generally, if you want to see a function in it s original
  source file, you can use the ~xref-find-definitions~ function to
  jump to it.  ~xref-find-definition~ works with a wide variety of
  languages, not just Lisp, and C, and it works with non-programming
  text as well.  For example, ~xref-find-definitions~ will jump to the
  various nodes in the Tex info source file f this document (provided
  that you've run the ~etags~ utility to record all the nodes in the
  manual that come with Emacs; see Create Tags Table in the GNU Emacs
  Manual).

- To use the ~xref-find-definitions~ command, type ~M-.~ (i.e., press
  the period key while holding down the ~META~ key, or else type the
  ~ESC~ key and then type the period key), and then, at the prompt,
  type in the name of the function whose source you want to see, such
  as ~mark-whole-buffer~, and then type ~RET~.  (If the command
  doesn't prompt, invoke it with an argument: ~C-u M-.~; see
  Interactive Options.)

  Emacs will switch buffers and display the source code for the
  function on your screen (If instead of showing the source code for a
  Lisp function, Emacs ask you which tags table to visit, invoke ~M-.~
  from a buffer whose major mode is Emacs Lisp or Lisp interaction.).

  To switch back to your current buffer, type ~M-~, or ~C-c b RET~.
  (On some keyboards, the ~META~ key is labeled ~ALT~.).

- Incidentally, the files that contain Lisp code are conventionally
  called /libraries/.  The metaphor is derived from that if
  specialized library, such as a law library or an engineering
  library, rather than a general library.

  Each library, or file, contains functions that relate to a
  particular topic or activity, such as ~abbrev.el~ for handling
  abbreviations and other typing shortcuts, and ~help.el~ for help.
  (Sometimes several libraries provide code for a single activity, as
  the various ~remail...~ files provide code for reading electronic
  mail.)  In the GNU Emacs Manual, you will see sentences such as "The
  ~C-h p~ commands lets you search the standard Emacs Lisp libraries
  by topic keywords."

** A Simplified ~beginning-of-buffer~ Definition

- The ~beginning-of-buffer~ command is a good function to start with
  since you are likely to be familiar with it and it is easy to
  understand.  Used as an interactive command, ~beginning-of-buffer~
  moves the cursor to the beginning of he buffer command is a good
  function to start with since you are likely to be familiar with it
  and it is easy to understand.  Used as an interactive command,
  ~beginning-of-buffer~ moves the cursor to the beginning of the
  buffer, leaving the mark at the previous position.  It is generally
  bound to ~M-<~.

- In this section, we will discuss a shortened version of the function
  that shows how it is most frequently used.  This shortened function
  work as written, but it does not contain the code for a complex
  option.  In another section, we will describe the entire
  function. (See Complete Definition of ~beginning-of-buffer~)

- Before looking at the code, let's consider what the function
  definition has to contain: it must include an expression that makes
  the function interactive so it can be called by typing ~M-x
  beginning-of-buffer~ or by typing a coached such as ~M-<~; it must
  include code to leave a mark at the original position in the buffer,
  and it must include code to move the cursor to the beginning of the
  buffer.

- Here is the complete text of the shortened version of the function

  #+begin_src emacs-lisp
    (defun simplified-beginning-of-buffer ()
      "Move point to the beginning of the buffer;
              leave mark at previous position."
      (interactive)
      (push-mark)
      (goto-char (point-min)))
  #+end_src

  - Like all the function definitions, this definition has /five/ parts following the macro ~defun~:

    - The name: in this example, ~simplified-beginning-of-buffer~.

    - A list of arguments; in this example, an empty list, ~()~,

    - The documentation string.

    - The interactive expression

    - The body

- In this function definition, the argument list is empty; this means
  that this function does not require any arguments.  (When we look at
  the definition for the complete function, we will see that it may be
  passed an optional argument.)

- The body of the function consist of the two lines:

  #+begin_src emacs-lisp
    (push-mark)
    (goto-char (point-min))
  #+end_src

  - The first of these line is the expression, ~(push-mark)~.  When
    this expression is evaluated by the Lisp interpreter, it sets a
    mark at the current position of the cursor, wherever that may be.
    The position of this mark is saved in the mark ring.

  - The next line is ~(goto-char (point-min))~.  This expression jumps
    the cursor to the minimum point in the buffer, that is, to the
    beginning of the buffer (or to the beginning of accessible portion
    of the buffer if it is narrowed.  See Narrowing and Widening.)

  - The ~push-mak~ command sets a mark at the place where the cursor
    was located before it was moved to the beginning of the buffer by
    the ~(goto-char (point-min))~ expression.  Consequently, you can,
    if you wish, go back to where you were originally by typing ~C-x
    C-x~.

  - That is all there is to the function definition!.

- When you are reading code such as this and come upon an unfamiliar
  function, such as ~goto-char~, you can find out what it does by
  using the ~describe-function~ command.  To use this command, type
  ~C-h f~ and then type in the name of the function and press ~RET~.
  The ~describe-function~ command will print the function's
  documentation string in a ~*Help*~ window.  For example, the
  documentation for ~goto-char~ is:

  #+begin_src emacs-lisp
    Set point to Position, a number or marker.
    Beginning of buffer is position (Point-min), end is (point-max).
  #+end_src

  - The function's one argument is the desired position.

- The prompt for ~describe-function~ will offer you the symbol under
  or preceding the cursor, so you can typing by positioning the cursor
  right after the function and then type ~C-h f RET~.

- The ~end-of-buffer~ function definition is written in the same way
  as the ~beginning-of-buffer~ definition except that the body of the
  function contains the expression ~(goto-char (point-max))~ in place
  of ~(goto-char (point-min))~.
** The Definition of ~mark-whole-buffer~

- The ~mark-whole-buffer~ function is no harder to understand than the
  ~simplified-beginning-of-buffer~ function.  In this case, however,
  we will look at the complete function, not a shortened version.

- The ~mark-whole-buffer~ function is not as commonly used as the
  ~beginning-of-buffer~ function, but is useful nonetheless; it marks
  whole buffer as a region by putting at the beginning and a mark at
  the end of the buffer. It is generally bound to ~C-x h~.

  - [[An overview of ~mark-whole-buffer~][mark-whole-buffer-overview]]

  - [[Body of ~mark-whole-buffer~][Body of mark-whole-buffer]]

*** An overview of ~mark-whole-buffer~

- In GNU Emacs 22, the code for the complete function looks like this:

  #+begin_src emacs-lisp
    (defun mark-whole-buffer ()
      "Put point at the beginning and mark at end of buffer.
    You probably should not use this function in Lisp programs;
    it is usually a mistake for a Lisp function touse any subroutine
    that mark uses or sets the mark."
      (interactive)
      (push-mark (point))
      (push-mark (point-max) nil t)
      (goto-char (point-min)))
  #+end_src

- Like other functions, the ~mark-whole-buffer~ function fits into the
  template of a function definition. The template looks like this:

  #+begin_src emacs-lisp
    (defun name-of-function (argument-list)
      "documentation..."
      (interactive-expression...)
      body)
  #+end_src

- Here is how the function works: the name of the function is
  ~mark-whole-buffer~; it is followed by an empty argument list,
  '~()~', which means that the function does not require
  arguments. The documentation comes next.

- The next line is an ~(interactive)~ expression that tells Emacs that
  the function will be used interactively.  These details are similar
  to the ~simplified-beginnig-of-buffer~ function described in the
  previous section.

*** Body of ~mark-whole-buffer~

- The body of the ~mark-whole-buffer~ function consist of three lines of code:

  #+begin_src emacs-lisp
    (push-mark (point))
    (push-mark (point-max) nil t)
    (goto-char (point-min))
  #+end_src

- The first of these line is the expression, ~(push-mark (point))~.

- The line does not exactly the same job as the first line of the body
  of the ~simplified-beginning-of-buffer~ function, which is written
  ~(push-mark)~.  In both cases, the Lisp interpreter sets a /mark/ at
  the current position of the cursor.

- I don't know why the expression in ~mark-whole-buffer~ is written
  ~(push-mark (point))~ and the expression in ~beginning-of-buffer~ is
  written ~(push-mark)~.  Perhaps whoever wrote the code did not know
  that the argument for ~push-mark~ are optional and that if
  ~push-mark~ is not passed an argument, the function automatically
  sets mark at the location of point by default.  Or perhaps the
  expression was written so as to parallel the structure of the next
  line.  In any case, the line cause Emacs to determine the position
  of point and set a mark there.

- In earlier version of GNU Emacs, the next line of
  ~mark-whole-buffer~ was ~(push-mark (point-max))~.  This expression
  sets a mark at the point in the buffer that has the highest number.
  This will be the end of the buffer (or, if the buffer is narrowed,
  the end of the accessible portion of the buffer. See Narrowing and
  Widening, for more about narrowing.).  After this mark has been set,
  the previous mark, the one set at point, is no longer set, but Emacs
  remembers its position, just all other recent marks are always
  remembered.  This means that you can, if you wish, go back to that
  position by typing ~C-u C-SPC~ twice.

 - In GNU Emacs 22, the ~(point-max)~ is slightly more
   complicated. The line reads

   #+begin_src emacs-lisp
     (push-mark (point-max) nil t)
   #+end_src

- The expression works nearly the same as before.  It sets a mark at
  the highest numbered place in the buffer that it can.  However, in
  this version, ~push-mark~ has two additional arguments.  The second
  argument to ~push-mark~ is ~nil~.  This tells the function it
  /should/ display a message that says "Mark set" when it pushes the
  mark.  The third arguments is ~t~.  This tells ~push-mark~ to
  activate the mark when Transient Mark mode is turned on.  Transient
  Mode highlights the currently active region.  It is often turned
  off.

- Finally, the last line of the function ~(goto-char (point-min))~.
  This written exactly the same way as it is written in
  ~beginning-of-buffer~.  The expression moves the cursor to the
  minimum point in the buffer, that is, to the beginning of the buffer
  (or to the beginning of the accessible portion of the buffer).  As a
  result of this, point is placed at the beginning of the buffer and
  mark is set at the end of the buffer.  The whole buffer is,
  therefore, the region.

** the definition of ~append-to-buffer~

- The ~append-to-buffer~ command is more complex than the
  ~mark-whole-buffer~ command.  What it does is copy the region (that
  is, the part of the buffer between point and mark) from the current
  to a specified buffer.

  - [[An overview of ~append-to-buffer~][append-to-buffer overview]]

  - [[The ~append-to-buffer~ Interactive Expression][append interactive]]            A two part interactive expression

  - [[The Body of ~append-to-buffer~][append-to-buffer body]]     Incorporates a ~let~ expression

  - [[~save-excursion~ in ~append_to-buffer~][append save-excursion]]     How the ~save-excursion~ works

*** An overview of ~append-to-buffer~

- The ~append-to-buffer~ commands uses the ~insert-buffer-substring~
  function to copy the region.  ~insert-buffer-substring~ is described
  by its name: it takes substring from a buffer, and insert it into
  another buffer.

- Most of ~append-to-buffer~ is concerned with setting up the
  conditions for ~insert-buffer-inserting~ to work: the code must
  specify both the buffer to which the text will go, the window it
  comes from and goes to, and the region that will be copied.

- Here is the complete text of the function

  #+begin_src emacs-lisp
    (defun append-to-buffer (buffer start end)
      "Append to specified buffer the text of the region.
    It is inserted into that buffer before its point.

    When calling from a program, give three argument:
    BUFFER (or buffer name), START and END.
    START and END specify the portion of the current buffer to be copied."
      (interactive
       (list (read-buffer "Append to buffer: " (other-buffer
                                                (current-buffer) t))
             (region-beginning) (region-end)))
       (let (oldbuf (current-buffer)))
       (save-excursion
         (let* (append-to (get-buffer-create buffer))
           (windows (get-buffer-window-list append-to t t))
           point)

         (set-buffer append-to)
         (setq point (point))
         (barf-is-buffer-read-only)
         (insert-buffer-substring oldbuf start end)
         (dolist (window windows)
           (when (= (window-point window) point)
                (set-window-point window (point))))))
  #+end_src

- The function can be understood by looking at it as a series
  filled-in templates.

- The outermost template is for the function.  In this function, it
  looks like this (which several slots filled in):

  #+begin_src emacs-lisp
    (defun append-to-buffer (buffer start end)
      "documentation..."
      (interactive ...)
      body...)
  #+end_src

- The first line of the function includes its name and three
  arguments.  The arguments are the ~buffer~ to which the text will be
  copied, and the ~start~ and ~end~ of the region in the current
  buffer that will be copied.

- The next part of the function is the documentation, which is clear
  and complete.  As is conventional, the three argument are written in
  /upper case/ so you will notice them easily.  Even better, they are
  described in the same order as in argument list.

- Note that the documentation distinguishes between a buffer and its
  name.  (The function can be handler either.)

*** The ~append-to-buffer~ Interactive Expression

- Since the ~append-to-buffer~ function will be used interactively,
  the function must have an ~interactive~ expression.  (For a review
  ~interactive~. see Making Function Interactive.)  The expression
  reads as follows:

  #+begin_src emacs-lisp
    (interactive
     (list (read-buffer
            "Append to buffer: "
            (other-buffer (current-buffer) t))
           (region-beginning)
           (region-end)))
  #+end_src

- This expression is not one with letters standing fort parts, as
  described earlier.  Instead, it starts a list with these parts:

- The first part of the list is an expression to read the name of the
  buffer and return it as a string.  That is ~read-buffer~.  The
  function requires a prompt as its first argument, '~"Append to
  buffer: "~'.  It second argument tells the command what value to
  provide if you don't specific anything.

- In this case that second argument is an expression containing the
  function ~other-buffer~, an exception, and a '~t~', standing for
  true.

- The fist argument to ~other-buffer~, the exception, is yet another
  function, ~current-buffer~.  That is not going to be returned.  The
  second argument is the symbol for true, ~t~.  That tells
  ~other-buffer~ that it may show visible buffers (except in this
  case, it will not show the current buffer, which makes sense).

- The expression looks like this:

  #+begin_src emacs-lisp
    (other-buffer (current-buffer) t)
  #+end_src

- The second and third argument to the ~list~ expression are
  ~(region-beginning)~ and ~(region-end)~.  These two functions
  specify the beginning and end of the text to be appended.

- Originally, the command used the letters '~B~', and '~r~'. The whole
  ~interactive~ expression looked like this:

  #+begin_src emacs-lisp
    (interactive "BAppend to buffer: \nr")
  #+end_src

- But when that was done, the default value of the buffer switched to
  was invisible.  That was not wanted.

- The prompt was separated from the second argument wit a newline,
  '~\n~'.  It was followed by an '~r~' that told Emacs to bind the two
  arguments that follow the symbol ~buffer~ in the function's argument
  list (that is, ~start~ and ~end~) to the values of /point/ and
  /mark/.  That argument work fine.

*** The Body of ~append-to-buffer~

- The body of the ~append-to-buffer~ function begin with ~let~.

- As we have seen before (see ~let~), the purpose of a ~let~
  expression is to create and give initial value to one or more
  variables that will only be used within the body of the ~let~.  This
  meas that such a variable will not be confused with any variable of
  the same time outside the ~let~ expression.

- We can see how the ~let~ expression fits into the function as a
  whole by showing a template for ~append-to-buffer~ with the ~let~
  expression in outline:

  #+begin_src emacs-lisp
    (defun append-to-buffer (buffer start end)
      "documentaion..."
      (interactive ...)
      (let ((variable value))
        body...)
  #+end_src

- The ~let~ expression has three elements:

  1. The symbol ~let~;

  2. A varlist containing, in this case, a single two-element list,
     ~(variable value)~;

  3. The body of the ~let~ expression.

- In the ~append-to-buffer~ function, the varlist looks like this:

  #+begin_src emacs-lisp
    (oldbuf (current-buffer))
  #+end_src

- In this part of the ~let~ expression, he one variable, ~oldbuf~, is
  bound to the value returned by the ~(current-buffer)~ expression.
  The variable, ~oldbuf~, is used to keep track of the buffer in which
  you are working and from which you will copy.

- The element or elements of a varlist are surround by a set of
  parentheses so the Lisp interpreter can distinguish the varlist from
  the body of the ~let~.  As a consequence, the two-element list
  within the varlist is surround by a circumscribing set of
  parentheses.  The line looks like this:

  #+begin_src emacs-lisp
    (let ((oldbuf (current-buffer)))
      ... )
  #+end_src

- The two parentheses before ~oldbuf~ might surprise you if you did
  not realize that the first parenthesis before ~oldbuf~ marks the
  boundary of the varlist and the second parenthesis mark the
  beginning if the two-element list, ~(oldbuf (current-buffer))~
*** ~save-excursion~ in ~append_to-buffer~

- The body of the ~let~ expression in ~append-to-buffer~ consist of a
  ~save-excursion~ expression.

- The ~save-excursion~ function saves the location point, and restores
  it to that position after the expression in the body of the
  ~save-excursion~ complete execution.  In addition, ~save-excursion~
  keeps track of the original buffer, and restore it. This is how
  ~save-excursion~ is *used* in ~append-to-buffer~.

- Incidentally, it is worth noting here that a Lisp function is
  normally formatted so that everything that is enclosed in a
  multi-line spread is indented more to the right than the first
  symbol.  In this function definition, the ~let~ is indented more
  than the ~defun~, and the ~save-excursion~ is indented more than the
  ~let~, like this:

  #+begin_src emacs-lisp
    (defun ...
      ...
      ...
      (let ...
        (save-excursion
          ...
  #+end_src

- This formatting convention makes it easy to see that the lines in
  the body of the ~save-excursion~ are enclosed by the parentheses
  associated with ~save-excursion~, just as the ~save-excursion~
  itself is enclosed by the parentheses associated with the ~let~:

  #+begin_src emacs-lisp
    (let ((oldbuf (current-buffer)))
      (save-excursion
        ...
        (set-buffer ...)
        (insert-buffer-substring oldbuf start end)
        ..))
  #+end_src

- The use of the ~save-excursion~ function can be viewed as process of
  filling in the slots of a template:

  #+begin_src emacs-lisp
    (save-excursion
      first-expression-in-body
      second-expression-in-body
      ...
      last-expression-in-body)
  #+end_src

- In this function, the body of ~save-excursion~ contains only one
  expression, the ~let*~ expression.  You know about a ~let~ function.
  The ~let*~ function is different.  It has '~*~' in its name.  It
  enables Emacs to set each variable in its varlist in *sequence*, one
  after another.

- Its critical feature is that variables later in the varlist can make
  use the value to which Emacs set variables earlier in the
  varlist. See [[][The ~let~ expression]].

- In the old days, the ~set-buffer~ expression was simply

  #+begin_src emacs-lisp
    (set-buffer (get-buffer-create buffer))
  #+end_src

  but now it is

  #+begin_src emacs-lisp
    (set-buffer append-to)
  #+end_src

- ~append-to~ is bound to ~(get-buffer-create buffer)~ earlier on in
  the ~let*~ expression.  That extra binding would not be necessary
  expect for that ~append-to~ is used later in the varlist as an
  argument to ~get-buffer-window-list~.

- The ~append-to-buffer~ function definition inserts text from the
  buffer in which you are currently to a named buffer.  It happens
  that ~insert-buffer-substrig~ does just the reverse--it copies text
  form another buffer to the current buffer-that is why the
  ~append-to-buffer~ definition start out with a ~let~ that binds the
  local symbol ~oldbuf~ to the value returned by ~current-buffer~.

- The ~insert-buffer-substring~ expression looks like this:

  #+begin_src emacs-lisp
    (let (bind-oldbuf-to-value-of-current-buffer)
      (save-excursion                   ; Keep track of buffer
        change-buffer
        insert-substring-from-oldbuf-into-buffer)

      change-back-to-original-buffer-when-finished
      let-the-loca-meaning-of-oldbuf-disappear-when-finshed

  #+end_src

- In summary, ~append-to-buffer~ works as follow: it saves the value
  of the current buffer in the variable called ~oldbuf~.  It gets the
  new buffer (creating one if need be) and switches Emacs's attention
  to it.  Using the value of ~oldbuf~, it inserts the region of text
  from the old buffer into the new buffer: and then using
  ~save-excursion~, it brings you back to your original buffer.

- In looking at ~append-to-buffer~, you can have explored a fairly
  complex function.  It show how to use ~let~ and ~save-excursion~,
  and how to change to and come back from another buffer.  Many
  function definition use ~let~, ~save-excursion~, and ~set-buffer~
  this way.

** Review

Here is a brief summary of the various functions discussed in this chapter.

- ~describe-function~, ~describe-variable~

  Print the documentation for a function or variable. Conventionally
  bound to ~C-h f~ and ~C-h v~:w

- ~xref-find-definition~

  Find the file containing the source for a function or variable and
  switch buffer to it, positioning point at the beginning of the item.
  Conventionally bound to ~M-.~ (that's a period following the ~META~
  key).

- ~save-excursion~

  Save the location of point, and restore its value after the
  arguments to ~save-excursion~ have been evaluated.  Also, remember
  the current buffer and return to it.

- ~push-mark~

  Set mark at a location and record the value of the previous mark on
  the /mark ring/.  The mark is a location in the buffer that will
  keeps its relative position even if text is added to or removed from
  the buffer.

- ~goto-char~

  Set point to the location specified by the value of the argument,
  which can be a number, a marker, or an expression that returns the
  number of a position, such as ~(point-min)~.

- ~insert-buffer-substring~

  Copy a region of text from buffer that is passed to the function as
  an argument and insert the region into the current buffer.

- ~mark-whole-buffer~

  Mark the whole buffer as a region. Normally bound to ~C-x h~

- ~set-buffer~ Switch the attention of Emacs to another buffer, but do
  not change the window being displayed.  Used when the program rather
  than a human is to work on a different buffer.

- ~get-buffer-create~, ~get-buffer~ Find a named buffer or create one
  if a buffer of that name does not exist.  The ~get-buffer~ function
  returns ~nil~ if the named buffer does not exists.


* A Few More Complex Functions

- In this chapter, we build on what we have learned in previous
  chapters by looking at more complex functions.  The ~copy-to-buffer~
  function illustrates use of two ~save-excursion~ expressions in one
  definition, while the ~insert-buffer~ function illustrates use of an
  asterisk in an ~interactive~ expression, use of ~or~, and the
  important distinction between a name and the object to which the
  name refers,

    - [[The Definition of ~copy-to-buffer~][copy-to-buffer]]             With ~set-buffer~, ~get-buffer-create~.

    - [[The definition of ~insert-buffer~][insert-buffer]]               Read-only, and with ~or~.

    - [[Complete Definition of ~beginning-of-buffer~][beginning-of-buffer]]   Shows ~goto-char~, ~point-min~, and ~Push-mark~.

    - [[Review][Second buffer Related Review]]

** The Definition of ~copy-to-buffer~

- After understanding how ~append-to-buffer~ to works, it easy to
  understand ~copy-to-buffer~.  This function copies text into a
  buffer, but instead of adding to the second buffer, it replaces all
  the previous text in the second buffer.

- The body of ~copy-to-buffer~ looks like this,

  #+begin_src emacs-lisp
    ...
    (interactive "BCopy to buffer: \nr")
    (let (oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (barf-if-buffer-read-only)
      (erase-buffer)
      (save-excursion
        (insert-buffer-substrinh oldbuf start end)))
  #+end_src

  - The ~copy-to-buffer~ function has a simpler ~interactive~
    expression than ~append-to-buffer~.

  - The definition then says

    #+begin_src emacs-lisp
      (with-current-buffer (get-buffser-create buffer) ...
    #+end_src

   - First, look at the earliest inner expression; that is evaluated
     first. That expression start with ~get-buffer-create buffer~.
     The function tells computer to use the buffer with the name
     specified as the one to which you are copying, or if such a
     buffer does not exist, to create it.  Then, the
     ~with-current-buffer~ function evaluates its body with that
     buffer temporarily current.

   - This demonstrates another way to shift the computer's attention
     but not the user's.  The ~append-to-buffer~ function showed how
     to do the same with ~save-excursion~ and ~set-buffer~,
     ~with-current~buffer~ is a newer, and arguably easier, mechanism.

   - The ~barf-if-buffer-read-only~ function sends you an error
     message saying the buffer is read-only if you cannot modify it.

   - The next line has the ~erase-buffer~ function as its sole
     contents.  That function erase the buffer.

   - Finally, the last tow line contain the ~save-excursion~
     expression with ~insert-buffer-substring~ as its body.  The
     ~insert-buffer-substring~ expression copies the text from the
     buffer you are in (and you have not seen the computer shift its
     attention, so you don't know that the buffer is now called
     ~oldbuf~).

   - Incidentally, this is what is meant by "replacement".  To replace
     text, Emacs erase the previous text and insert new text.

   - In outline, the body of ~copy-to-buffer~ looks like this:

     #+begin_src emacs-lisp
       (let (bind-oldbuf-to-value-of-current-buffer)
         (with-the-buffer-you-are-copying-to
          (but-do-not-erase-or-copy-to-a-read-only-buffer)
          (erase-buffer)
          (save-excursion
            insert-substring-from-oldbuf-into-buffer)
     #+end_src

** The definition of ~insert-buffer~

- ~insert-buffer~ is yet another /buffer-related function/.  This
  command copies another buffer /into/ the current buffer.  It is the
  /reverse/ of ~append-to-buffer~ or ~copy-to-buffer~, since they copy
  a region of text /from/ the current buffer to another buffer.

- Here is discussion based on the original code.  The code was
  simplified in 2003 and is harder to understand.

- See [[][New Body for ~insert-buffer~]], to see a discussion of the
  new body.

- In addition, this code illustrates the use of ~interactive~ with a
  buffer that might be /read-only/ and the important distinction
  between the name of an object and the object actually referred to.

- [[The Code for ~insert-code~][insert-buffer code]]

- [[The Interactive Expression in ~insert-buffer~][insert-buffer interactive]]              When you can read, but not write.

- [[The Body of the ~insert~buffer~ Function][insert-buffer body]]      The body has an ~or~ and a ~let~.

- [[~insert-buffer- with an ~if~ Instead of an ~or~][if & or]]                    Using an ~if~ instead of an ~or~.

- [[The ~or~ in the Body][Insert or]]                          How the ~or~ expression works.

- [[The ~let~ Expression in ~insert-buffer~][Insert let]]     Two ~save-excursion~ expression.

- [[New Body for ~insert-buffer][New insert-buffer]]

*** The Code for ~insert-code~

- Here is the earlier code:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "Insert after point the contents of Buffer.
        Puts mark after the inserted text.
        BUFFER may be a buffer or a buffer name."
      (interactive "*bInsert buffer: ")

      (or (bufferp buffer)
          (setq buffer (get-buffer buffer)))
      (let (start end newmark)
        (save-excursion
          (save-excursion
            (set-buffer buffer)
            (setq start (point-min) end (point-max)))
          (insert-buffer-substring buffer start end)
          (setq newwark (point)))
        (push-mark newmark)))
  #+end_src

- As with other function definitions, you can use a template to see an
  outline of the function:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "documentation.."
      (interactive "*bInsert buffer: ")
      body..)
  #+end_src

*** The Interactive Expression in ~insert-buffer~

- In ~insert-buffer~, the argument to the ~interactive~ declaration
  has two parts, an asterisk, '~*~', and '~bInsert buffer: "~'.

  - [[A Read-only Buffer][Read-only buffer]]         When a buffer cannot be modified.

  - [['~b~' in an Interactive Expression][b for interactive]]     An existing buffer or else its name.

**** A Read-only Buffer

- The asterisk is for the situation when the current buffer is
  read-only buffer--a buffer that cannot be modified.  If
  ~insert-buffer~ is called when the current buffer is read-only, a
  message to this effect is printed in the echo area and the terminal
  may beep or blink at you; you will not be permitted to insert
  anything into current buffer.  The asterisk does not need to be
  followed by a newline to separate it from the next argument.

**** '~b~' in an Interactive Expression

- The body of the ~insert-buffer~ function has two major parts: an
  ~or~ expression and a ~let~ expression.  The purpose of the ~or~
  expression is to ensure that the argument ~buffer~ is bound to a
  buffer and not just the name of a buffer.  The body of the ~let~
  expression contains the code which copies the other buffer into the
  current buffer.

- In outline, the two expressions fit into the ~insert-buffer~
  function like this:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "documentation.."
      (interactive "*bInsert buffer: ")
      (or ...
          ...
          (let (varlist)
            body-of-let... )
  #+end_src

- To understand how the ~or~ expression ensures that the argument
  ~buffer~ is bound to a buffer and not then name of a buffer, it
  first necessary to understand the ~or~ function.

- Before doing this, let me rewrite this part of the function using
  ~if~ so that you can see what is done in a manner that will be
  familiar.

*** The Body of the ~insert~buffer~ Function

- The body of the ~insert-buffer~ function has two major parts: an
  ~or~ and a ~let~ expression.  The purpose of the ~or~ expression is
  to unsure that the argument ~buffer~ is bound to a buffer and not
  just the name of the buffer.  The body of the ~let~ expression
  contains the code which copies the other buffer into the current
  buffer.

- In outline, the two expression fit into the ~insert-buffer~ function like this:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "documentation..."
      (interactive "*bInsert buffer: ")
      (or ...
          ...
          (let (varlist)
            body-of-let...)
  #+end_src

- To understand how the ~or~ expression ensures that the argument
  ~buffer~ is bound to a buffer and not the name of a buffer, it is
  first necessary to understand the ~or~ function.

- Before doing this, let me rewrite Thai part of the function using
  ~if~ so that oi can see what is done in a manner that will be
  familiar.

*** ~insert-buffer- with an ~if~ Instead of an ~or~

- The job to be done is to make sure the value of ~buffer~ is a buffer
  itself and not the name of a buffer.  If the value is the name, then
  the buffer itself must be got.A

- You can imagine yourself at a conference where an /usher/ is
  wandering around holding a list with your name on it and looking for
  you: the usher is bound to your name, not to you; but when the usher
  finds you and takes your arm, the usher becomes bound to you.

- In Lisp, you might describe this situation like this:

  #+begin_src emacs-lisp
    (if (not (holding-on-to-guest))
        (find-and-take-arm-of-guest))
  #+end_src

- We want to do the same thing with a buffer--if we do not have the
  buffer itself, we want to get it,

- Using a predicate called ~bufferp~ that tells us whether we have a
  buffer (rather than its name), we can write the code like this:

  #+begin_src emacs-lisp
    (if (not (bufferp buffer))                         ; if-part
        (setq buffer buffer (get-buffer buffer)))       ; then-part
  #+end_src

- Here, the true-or-false-test of the ~if~ expression is ~(mot
  (bufferp buffer))~; and the then-part is the expression ~(setq
  buffer (get-buffer buffer))~

- In the test, the function ~bufferp~ returns true if its argument is
  a buffer--but if its argument is the name of the buffer.  (The last
  character of the function name ~bufferp~ is the character '~p~', as
  we saw earlier, such use of '~p~' is a convention that indicates the
  function is a /predicate/, which is a term that means that the
  function will determine whether some property is true or false.  See
  [Using the Wrong Type Object as an Argument].

- The function ~not~ precedes the expression ~(bufferp buffer)~, so
  the true-or-false-test looks like this:

  #+begin_src emacs-lisp
    (not (bufferp buffer))
  #+end_src

- ~not~ is a function that returns true if its argument is false and
  false if its argument is true.  So if ~(bufferp buffer)~ returns
  true, the ~not~ expression returns false and vice versa.

- Using this test, the ~if~ expression works as follows: when the
  value of the variable ~buffer~ is actually a buffer than its name,
  the true~-or-false-test returns false and the ~if~ expression does
  not evaluate the then-part.  This is fine, since we do not need to
  do anything to the variable ~buffer~ if it really is a buffer.

- On the other hand, when the value of ~buffer~ is not a buffer
  itself, but the name of a buffer, the true-or-false-test returns
  true, and the then-part of the expression is evaluated.  In this
  case, the then-part is ~(setq buffer (get-buffer buffer))~.  This
  expression uses the ~get-buffer~ function to return an actual buffer
  itself, given its name.  The ~setq~ then sets the variable ~buffer~
  to the value of the buffer itself, replacing its previous value
  (which was the name of the buffer).

*** The ~or~ in the Body

- The purpose of the ~or~ expression in the ~insert-buffer~ function
  is to ensure that the argument ~buffer~ is bound to a buffer and not
  just to the name of a buffer.  The previous section shows how the
  job could have been done using ~if~ expression.  However, the
  ~insert-buffer~ function actually use ~or~.  To understand this, it
  is necessary to understand how ~or~ works.

- The ~or~ expression looks like this:

  #+begin_src emacs-lisp
    (or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
  #+end_src

- The first argument to ~or~ is the expression ~(bufferp buffer)~.
  This expression returns true (a non-~nil~ value) if the buffer is
  actually a buffer, and not just the name of a buffer.  In the ~or~
  expression returns this true value and does not evaluate the
  expression--and this is fine with use since we do not want to do
  anything to the value f ~buffer~ if it really is a buffer.

- On the other hand, if the value of ~(bufferp buffer)~ is ~nil~,
  which it will be if the value of ~buffer~ is the name of a buffer,
  the Lisp interpreter evaluates the next element of the ~or~
  expression.  This is the expression ~(setq buffer (get-buffer
  buffer))~.  This expression returns a non-~nil~ value, which is the
  value to which it sets the variable ~buffer~--and this value is a
  buffer itself, not the name of a buffer.

- The result of all this is that the symbol ~buffer~ is always bound
  to a buffer itself rather than to the name of a buffer.  All this is
  necessary because the ~set-buffer~ function in a following line
  only works with a buffer itself, not with the name to a buffer.

- Incidentally, using ~or~, the situation with the usher would be
  written like this:

 #+begin_src emacs-lisp
   (or (holding-on-to-guest) (find-and-take-arm-of-guest))
 #+end_src

*** The ~let~ Expression in ~insert-buffer~

- After ensuring that the variable ~buffer~ refers to a buffer itself
  and not just to the name of a buffer, the ~insert-buffer~ function
  continuous with a ~let~ expression.  This specifies three local
  variables of the same name in Emacs until the end of the ~let~.

- The body of the ~let~ contains two ~save-excursion~ expressions.
  First we will look at the inner ~save-excursion~ expression in
  detail.  The expression looks like this:

  #+begin_src emacs-lisp
    (save-excursion
      (inner-save-excursion-expression
       (go-to-new-buffer-and-set-start-and-end)
       (insert-buffer-substring buffer start end)
       (setq newmark (point)))
  #+end_src

- The ~insert-buffer-substring~ function copies the text /into/ the
  current buffer /from/ the region indicated by ~start~ and ~end~ in
  ~buffer~.  Since the whole of the second buffer lies between ~start~
  and ~end~, the whole of the second buffer is copied into the buffer
  you are editing.  Next, the value of point, which will be at the end
  of the inserted text, is recorded in the variable ~newmark~.

- After the body of the outer ~save-excursion~ is evaluated, point is
  relocated to its original place.

- However, it is convenient to locate a mark at the end of the newly
  inserted text and locate point at the beginning.  The ~newmar~
  variable records the end of the inserted text.  In the last line of
  the ~let~ expression, the ~(push-mark newmark)~ expression function
  sets a mark to this location.  (The previous location of the mark is
  still accessible; it is recorded on the mark ring, and you can go
  back to it with ~C-u SPC~.)  Meanwhile, point is located at the
  beginning of the inserted text, which is where it was before you
  called the insert function, the position of which was saved by the
  first ~save-excursion~.

- The whole ~let~ expression look like this:
  #+begin_src emacs-lisp
    (let (start end newmark)
      (save-excursion
        (save-excursion
          (set-buffer buffer)
          (setq start (point-min) end (point-max)))
        (insert-buffer-substring buffer start end)
        (setq newmark (point)))
      (push-mark newmark))
  #+end_src

- Like the ~append-to-buffer~ function, the ~insert-buffer~ function
  uses ~let~, ~save-excursion~ and ~set-buffer~.  In addition, the
  function illustrates one way to use ~or~.  All the function are
  building blocks that we will find and use again and again.

*** New Body for ~insert-buffer

- The body in the GNU Emacs 22 version is more confusing that the
  original.

-It consist of two expressions,

  #+begin_src emacs-lisp
    (push-mark
     (save-excursion
       (insert-buffer-substring (get-buffer buffer))
       (point)))

    nil
  #+end_src

  except, and this is what confuses novices, very important work is
  done inside the ~push-mark~ expression.

- The ~get-buffer~ function returns a buffer with the name provided.
  You will note that the function is /not/ called ~get-buffer-create~;
  it does not create a buffer if one does not already exist.  The
  buffer returned by ~get-buffer~, an existing buffer, is passed to
  ~insert-buffer-substring~, which inserts the whole of the buffer
  (since you did not specify anything else).

- The location into which the buffer is inserted is recorded by
  ~push-mark~.  Then the function returns ~nil~, the value of its last
  command.  Put another way, the ~insert-buffer~ function exists only
  to produce a side effect, inserting another buffer, not return any
  value.

** Complete Definition of ~beginning-of-buffer~

- The basic structure of the ~beginning-of-buffer~ function has
  already been discussed.  (See [[A Simplified ~beginning-of-buffer~
  Definition]].)  This section describes the complex part of the
  definition.

- As previous described, when invoked without an argument,
  ~beginning-of-buffer~ moves the cursor to the beginning of the
  buffer (in truth, the beginning of the accessible portion of the
  buffer), leaving the mark at the previous position.  However, when
  the command is invoked with a number between one and ten, the
  function considered that number to be a fraction of the length of
  the buffer, measured in tenths and Emacs moves the cursor that
  fraction of the way from the beginning of the buffer.  Thus, you can
  either call this function with the key command ~M-<~, which will
  move the cursor to the beginning of the buffer, or with a key
  command such as ~C-u 7 M-<~ which will move the cursor at a point
  70% of the way through the buffer.  If a number bigger than then us
  used for the argument, it moves to the end of the buffer.

- The ~beginning-of-buffer~ function can be called with or without an
  argument.  The use of the argument is /optional/.

  - [[Optional Arguments][Optional Arguments]]

  - [[~beginning-of-buffer~ with an Argument][beginning-of-buffer opt arg]]       Example with optional argument.

  - [[][beginning-of-buffer complete]]

*** Optional Arguments

- Unless told otherwise, Lisp expects that a function an argument in
  its function definition will be called with a value for that
  argument.  If that does not happen, you get error and a message that
  says '~Wrong number of arguments~'.

- However, optional arguments are feature of Lisp: a particular
  /keyword/ is used to tell the Lisp interpreter that an argument is
  optional.  The keyword is ~&optional~.  (The '~&~' in front of
  '~optional~' is part of the keyword.)  In a function definition, if
  an argument follows the keyword ~&optional~, no value need be passed
  to that argument when the function is called.

- The first line of the function definition of ~beginning-of-buffer~
  therefore looks like this:

  #+begin_src emacs-lisp
- - (defun beginning-of-buffer (&optional arg)
  #+end_src

- In outline, the whole function looks like this:

  #+begin_src emacs-lisp
    (defun beginning-of-buffer (&optional arg)
      "documentation..."
      (interactive "P")
      (or (is-the-argument-a-cons-cell arg)
          (and are-both-transient-mark-mode-and-mark-active-true)
          (push-mark))
      (let (deterimine-size-and-set-it)
        (goto-char
         (if-there-is-an-agument
          figure-out-where-to-go
          else-go-told
          (point-min))))
      do-nicety
  #+end_src

- The function is similar to the ~simplified-beginning-of-buffer~
  function except that the ~interactive~ expression has "~p~" as an
  argument and the ~goto-char~ function is followed by an if-then-else
  expression that figure out where to put the cursor if there is an
  argument that is not a cons cell.

- The ~"P"~ in the ~interactive~ expression tells Emacs to pass a
  /prefix argument/, if there is one, to then function in raw from.  A
  prefix argument is made by typing the ~META~ key followed by a
  number, or by typing ~C-u~ and then a number.  (If you type don't
  type a number, ~C-u~ defaults to a cons cell with a 4.  A lowercase
  ~"p" in the ~interactive~ expression causes the function to convert
  a prefix arg to number.)

- The true-or-false-test of the ~if~ expression looks complex, but it
  is not; it checks whether ~arg~ has a value that is not ~nil~ and
  whether it is a cons sell.  (That is what ~constp~ does; it checks
  whether its argument is a cons cell.)  If ~arg~ has a value that is
  not ~nil~ (and is not a cons cell), which will be the case if
  ~beginning-of-buffer~ is called with a numeric argument, then this
  true-or-false-test will return true and then-part of the ~if~
  expression will be evaluated.  On the other had, if
  ~beginning-of-buffer~ is not called with an argument, the value
  ~arg~ will be ~nil~ and the else-part of the ~if~ expression will be
  evaluated.  The else-part is simply ~point-min~, and when this is
  the outcome, the whole ~goto-char~ expression is ~(goto-char
  (point-min))~, which is how we the ~beginning-of-buffer~ function in
  its simplified form.

*** ~beginning-of-buffer~ with an Argument

- When ~beginning-of-buffer~ is called with an argument, an expression
  is evaluated which calculates what value to pass to ~goto-char~.
  This expression is rather complicated at first sight.  It includes
  an inner ~if~ expression and much arithmetic.  It look like this:

  #+begin_src emacs-lisp
    (if (> (buffer-size) 10000)
        ;; Avoid overflow for large buffer sizes!
        (* (prefix-numeric-value arg)
           (/ size 10)
           (/
            (+ 100%
               (* size (prefix-numeric-value arg))) 10)))
  #+end_src

  - [[Disentangle ~beginning-of-buffer~][Disentangle beginning-of-buffer]]

  - [[What happen in a large buffer][Large buffer case]]

  - [[What happen in a small buffer][Small buffer case]]

**** Disentangle ~beginning-of-buffer~

- Like other complex-looking expression, the conditional expression
  within ~beginning-of-buffer~ can be disentangled by looking at it as
  parts of a template, in this case, the template for an if-then-else
  expression.  In skeletal form, the expression looks like this:

  #+begin_src emacs-lisp
    (if (buffer-is-large
         divide-buffer-size-by-10-and-multiply-by-arg
      else-use-alternate-calculation
  #+end_src

- The true-or-false-test of this inner ~if~ expression checks the size
  of the buffer.  The reason for this is that the old version 18 Emacs
  used numbers that are no bigger than eighth million or so and in the
  computation that followed, the programmer feared that Emacs might
  try to use over-large numbers if the buffer were large.  The term
  "overflow", mentioned in the comment, means numbers that are over
  large.  More recent version of Emacs use large numbers, but this
  code has not been touched, if only because people now look at buffer
  that are far, far larger than ever before.

- there are two cases: if the buffer is large and if it is not.

**** What happen in a large buffer

- In ~beginning-of-buffer~, the inner ~if~ expression test whether the
  size of the buffer is greater than 10,000 characters.  To do this,
  it uses the ~>~ function and the computation of ~size~ that comes
  from the let expression.

- In the old days, the function ~buffer-size~ was used.  Not only was
  the function called several times, it gave the size of the whole
  buffer, not the accessible part.  The computation makes much more
  sense when it handles just the accessible part.  (See [[][Narrowing
  and Widening]], for more information on focusing attention to an
  accessible part.)

- the line looks like this:
  #+begin_src emacs-lisp
    (if (> size 10000)
  #+end_src

- When the buffer is large is large, the then-part of the ~if~
  expression is evaluated.  It reads like this (after formatting for
  easy reading):

  #+begin_src emacs-lisp
    (*
     (prefix-numeric-value arg)
     (/ size 10))
  #+end_src

  this expression is multiplication, which with two arguments to the
  function ~*~

- The first argument is ~(prefix-numeric-value arg)~.  When ~"p"~ is
  used as the argument for ~interactive~, the value passed to the
  function as its argument is passed a ~raw prefix argument~, and not
  a number.  (It is a number list.) To perform the arithmetic, the
  conversion is necessary, and ~prefix-numeric-value~ does the job.

- The second argument is ~(/ size 10)~.  This expression divides the
  numeric value by ten--the numeric value of the size of the
  accessible portion of the buffer.  This produces a number that tells
  how many characters make up one tenth of the buffer size.  (in Lisp,
  ~/~ is used for division, just as ~*~ is used for multiplication.)

- In the multiplication expression as a whole, this amount is
  multiplied by the value of the prefix argument--the multiplication
  looks like this:

  #+begin_src emacs-lisp
    (* numeric-value-of-prefix-arg
       number-of-characters-in-one-tenth-of-the-accessible-buffer)
  #+end_src

- If, for example, the prefix argument is ~'7~', the one-tenth value
  will be multiplied by 7 to give a position 70% of the way through.

- The result of all this is that the accessible portion of the buffer
  is large, the ~goto-char~ reads like this:

  #+begin_src emacs-lisp
    (goto-char (* (prefix-numeric-value arg)
                  (/ size 10)))
  #+end_src

  This put the cursor where we want it.

**** What happen in a small buffer

- Here  is the complete text of the ~beginning-of-buffer~ function:


  #+begin_src emacs-lisp
    (defun beginning-of-buffer (&optional arg)
      "Move point to the beginning of the buffer;
    leave mark atprevious position.
    with \\[universal-argument] prefix,
    do not set mark at previous position.  With numeric org N,
    put point N/10 of the way from the beginning

    If the buffer is narrowed,
    this command uses the beginning and
    size of the accessible part of the buffer.

    Don't use tis command in Lisp program!
    \(go-char (point-min)) is faster
    and avoids clobbering the mark."
      (interactive "P")
      (or (consp arg)
          (and transient-mark-mode-mark-active)
          (push-mark))
      (let ((size (- (point-max) (point-min)))
            (goto-char (if (and arg (not (consp arg)))
                           (+ (point-min)
                              (if (> size 10000)
                                  ;; avoid oveflow for large buffer sizes!
                                  (* (prefix-numeric-value-org)
                                     (/ size 10))
                                (/ (+ 10 (* size (prefix-numeric-value arg)))
                                   10)))
                         (point-min))))
        (if (and arg (not (consp arg))) (forward-line 1)))
    #+end_src

- Except for two small points, the previous discussion shows how this
  function works.  The first point deals with a detail in the
  documentation string, and the second point concerns the last line of
  the function.

- In the documentation string, there is reference to an expression:

  #+begin_src emacs-lisp
    \\[universal argument]
  #+end_src

- A '~\\~\ is used before the first square bracket of this expression.
  This '~\\~' tells the lisp Interpreter to substitute whatever key is
  currently bound to the '~[...]~'.  In this case of
  ~universal-argument~, that is usually ~C-u~, but it might be
  different.  (See [[][Tips for Documentation Strings]] in the GNU
  Emacs Lisp Reference Manual, for more information.)

- Finally, the last line of the ~beginning-of-buffer~ commands says to
  move point to the beginning of the next line if the command is
  invoked with an argument:

  #+begin_src emacs-lisp
    (if (and arg (not (consp arg))) (forward-line 1))
  #+end_src

- This puts the cursor at the beginning of the first line after the
  appropriate tenths position in the buffer.  This is flourish that
  means that the cursor is always located /at least/ the requested
  tenths of the way through the buffer, which is a nicety that is,
  perhaps, not necessary, but which, if it did not occur, would be
  sure to draw complaints.  (The ~(not (consp arg))~ portion is so
  that if you specify the command with a ~C-u~, but without a number,
  that is to say, if the raw prefix argument is simply, a cons cell,
  the command does not put your at the beginning of the second line.)

** Review

- ~or~

  evaluates each argument in sequence, and return the value of the
  first argument that is nor ~nil~; if none return a value that is not
  ~nil~, return ~nil~.  In brief, return the first value of the
  arguments; return a true value of one ~or~ any of the others are
  true.

- ~and~

  Evaluate each argument in sequence, and if any are ~nil~, return
  ~nil~; if none are ~nil~, return the value of the last argument.  In
  brief, return a true value only if all the arguments are true;
  return a true value if one ~nad~ of the others is true.

- ~&optional~

  A keyword used to indicated that an argument to a function
  definitions is optional; this meas that the function can be
  evaluated without the argument, if desired.

- ~prefix-numeric-value~

  Convert the raw prefix argument produced by ~(interactive "P")~ to a numeric value.

- ~forward-line~

  Move point forward to the beginning of the next line, or if the
  argument is greater than one, forward that many lines.  If it can't
  move as far forward as it supposed to, ~forward-line~ goes forward
  as far it can and then returns a count of the number of additional
  lines it was supposed to move but couldn't.

- ~erase-buffer~

  Delete the entire contents of the current buffer.

- ~bufferp~

  Returns ~t~ if its argument is a buffer; otherwise return ~nil~.


* The Advantage of Narrowing

- Narrowing is a feature of Emacs that makes it possible for you to
  focus on a specific part of buffer, and work without accidentally
  changing other parts.  Narrowing is normally disabled since it can
  confuse novices.

  - [[The Advantages of Narrowing][Narrowing advantages]]                     The advantages of narrowing.

  - [[The ~save-restriction~ Special Form][save-restriction]]       The ~save-restriction~ special form.

  - [[~what-line~][what-line]]                                The number of the line that point is on.

** The Advantages of Narrowing

- With narrowing, the rest of a buffer is made invisible, as if
  weren't there.  This is an advantage if, for example, you want to
  replace a word in one part of a buffer but not in another; you
  narrow to the part you want and the replacement is carried out only
  in that section, not in the rest of the buffer.  Searches will only
  work within a narrowed region, not outside of one, so if you are
  fixing a part of a document, you can keep yourself from accidentally
  finding parts you do not need to fix by narrowing just to the region
  you want. (the key binding for ~narrow-to-region~ is ~C-x n n~.)

- However, narrowing does make the rest of the buffer invisible, which
  can scare people who inadvertently invoke narrowing and think they
  deleted a part of their file.  Moreover, the ~undo~ command (which
  is usually bound to ~C-x u) does not turn off narrowing (nor should
  it), so people can become desperate if they do not know that they
  can return the rest of a buffer to visibility with the ~widen~
  command.  (The key binding for ~widen~ is ~C-x n w~.)

- Narrowing is just as useful to the lisp interpreter as to human.
  Often, an Emacs Lisp function is designed to work on just part of a
  buffer, it has any narrowing and when it has finished its job,
  restores the narrowing to what it was. On the other hand, the
  ~count-lines~ function uses narrowing to restrict uses narrowing to
  restrict it self to just that portion of the buffer in which it is
  interested and then restores the previous situation.

** The ~save-restriction~ Special Form

- In Emacs Lisp, you can use the ~save-restriction~, special form to
  keep track whatever narrowing is in effect, if any.  When the Lisp
  interpreter meets with ~save-restriction~, it executes the code in
  the body of the ~save-restriction~ expression, and then undoes any
  changes to narrowing that the code caused.  If, for example, the
  buffer is narrowed and the code that follows ~save-restriction~ gets
  rid of the narrowing, ~save-restriction~ gets rid of the narrowing,
  ~save-restriction~ return the buffer to its narrowed region
  afterwards.  In the ~what-line~ command, any narrowing the buffer
  may have is undone by the ~widen~ command that immediately follows
  the ~save-restriction~ command.  Any original narrowing is restored
  just before the completion of the function.

- The template for a ~save-restriction~ expression is simple:

  #+begin_src emacs-lisp
    (save-restriction
      body...)
  #+end_src

- The body of the ~save-restriction~ is one or more expression that
  will be evaluated in sequence by the Lisp interpreter.

- Finally, a point to note: when you use both ~save-excursion~ and
  ~save-restriction~, one right after the other, you should use
  ~save-excursion~ outermost.  If you write them in reverse order, you
  may fail to record narrowing in the buffer to which Emacs switches
  after calling ~save-excursion~.  Thus, when written together,
  ~save-excursion~ and ~save-restriction~ should be written like this:

  #+begin_src emacs-lisp
    (save-excursion
      (save-restriction
        body...))
  #+end_src

- In other circumstances, when not to written together, the
  ~save-excursion~ and ~save-restriction~ special form must be written
  in the order appropriate to the function.

- For example,

  #+begin_src emacs-lisp
    (save-restriction
      (widen)
      (save-excursion
        body..))
  #+end_src
** ~what-line~

- The ~what-line~ command tells you the number of the line in which
  the cursor is located.  The function illustrate the use of the
  ~save-restriction~ and ~save-excursion~ commands. Here is the
  original text of the function:

  #+begin_src emacs-lisp
    (defun what-line ()
      "Print the current line number (in the buffer) of point."
      (interative)
      (save-excursion
        (beginning-of-line)
        (message "Line %d"
                 (1+ (count-lines 1 (point)))))
  #+end_src

- (In recent version of GNU Emacs, the ~what-line~ function has been
  to tell you your line number in a narrowed buffer as well as your
  line in a widened buffer.  The recent version is more complex than
  version shown here.  If you fell adventurous, you might to look it
  after figuring out how this version works.  You will probably need
  to use ~C-h f (describe-function)~.  The newer version uses a
  conditional to determine the buffer has been narrowed.

- (Also, it uses ~line-number-at-pos~, which among other simple
  expressions, such as ~(goto-char (point-min))~, moves point to the
  beginning of the current line with ~(forward-line 0)~, rather than
  ~beginning-of-line~.)

- The ~what-line~ function as shown here has a documentation line and
  is interactive, as you would expect.  The next two lines use the
  function ~save-restriction~ and ~widen~.

- The ~save-restriction~ special form notes whatever narrowing is an
  effect, if any, in the current buffer and restores that narrowing
  after code in the body of the ~save-restriction~ has been evaluated.

- The call to ~widen~ is followed by ~save-excursion~, which saves the
  location of the cursor (i.e of point(, and restores it after the
  code in the body of the ~save-excursion~ uses the
  ~beginning-of-line~ function to move point.

- (Note that the ~(widen)~ expression comes between the
  ~save-restriction~ and ~save-excursion~ special forms.  When you
  write the two ~save- ...~ expression in sequence, write
  ~save-excursion~ outermost.)

- The last two lines of the ~what-line~ function are functions to
  count the number of lines in the buffer and then print the number in
  the echo area.

  #+begin_src emacs-lisp
    (message "Line %d"
             (1+ (count-lines 1 (point)))))
    #+end_src

- The ~message~ function prints a one-line message at the bottom of
  the Emacs screen.  The first argument is inside of quotation marks
  and id printed as a string of characters.  However, it may contain a
  '~%d~' prints the argument. '~%d~' prints as a decimal, so the
  message will say something such as ~'line 243'~.

- The number that is printed in place of the '~%d~' is computed by the
  last line of the function:

  #+begin_src emacs-lisp
    (1 + (count-lines 11 (point)))
  #+end_src

- What this does count is count the lines from the first position of
  the buffer, indicated by the ~1~, up to ~(point)~, and then add one
  to that number.  (The ~1+~ function adds one to its argument.) We
  add one to it because line 2 has only one line before it, and
  ~count-lines~ counts only the lines /before/ the current line.

- After ~count-lines~ has done its job, and the message has been
  printed in the echo area, the ~save-excursion~ restore point to its
  original position; and ~save-restriction~ restores the original
  narrowing, if any.

** Strange Name
- The name of the ~cons~ function is not unreadable: it is not an
  abbreviation of the word "construct".  The origins of the name for
  ~car~ and ~cdr~ on the other hand, are esoteric: ~car~ is acronym
  from the phrase "Contents of the Address part of the Register": and
  ~cdr~ (pronounced "could-er") is an acronym from the phrase
  "Contents of the Decrement part of the Register".  These phrases
  refer to specific pieces of hardware on the early computer on which
  the original Lisp was developed.  Besides being obsolete, the
  phrases have been completely irrelevant for more 25 years to anyone
  thinking about Lisp.  Nonetheless, although a few brave scholars
  have begun to use more reasonable names for these functions, the old
  term are still in use.  In particular, since the terms are used in
  the Emacs lisp source code, we will use them in this introduction.

** ~car~ and ~cdr~

- The CAR of list is ,quite simply, the first item in the list.  Thus
  CAR of the list ~(rose violet daisy buttercup)~ is ~route~.

- If you reading this info in GNU Emacs, you can see this by
  evaluating the following:

  #+begin_src emacs-lisp
    (car '(rose violet daisy buttercup))
  #+end_src

- After evaluating the expression, ~rose~ will appear in the echo area.

- Clearly, a more reasonable names for the ~car~ function would be
  ~first~ and this is often suggested.

- ~car~ does not remove the first item from the list; it only reports
  what it is.  After ~car~ has been applied to a list, the list is
  still the same as it was.  In the jargon, ~car~ is
  "non-destructive".  This feature of the list, the value returned by
  the ~cdr~ function, is ~(violet daisy buttercup)~.

  #+begin_src emacs-lisp
    (cdr '(rose violet daisy buttercup))
  #+end_src

- When you evaluates this, ~(violet daisy buttercup))~ will appear in
  the echo area.

- Incidentally, in the example, the list of the flowers is quoted.  If
  it were not, the Lisp interpreter wold try to evaluate the list by
  calling ~rose~ as a function.  In this example, we do not want to do
  that.

- Clearly, a more reasonable names for ~cdr~ would be ~rest~.

- (*There is a lesson here*: when you name a new function, consider
  very carefully what you are doing, since you may be stuck with the
  names for far longer than you expect.  The reason this document
  perpetuates these names is that the Emacs Lisp source code uses
  them, and if I did not use them, you would have a hard time reading
  the code; but do, please, try to avoid using these terms
  yourself. The people who come after you will be grateful to you.)

- When ~car~ and ~cdr~ area applied to a list made up of symbols, such
  as the list ~(pine fir oak maple)~, the element of the list returned
  by the function ~car~ is the symbol ~pine~ without parentheses
  around it.  ~pine~ is the first element in the list.  However, the
  CDR of the list is a list itself, ~(fir oak maple)~, as you can set
  by evaluating the following expressions in th usual way:

  #+begin_src emacs-lisp
    (car '(pine fir oak maple))

    (cdr '(pine fir oak maple))
  #+end_src

- On the other hand, in a list of list, the first element is itself a
  list ~car~ returns this first element as a list.  For example, the
  following list contains three sub-lists, a list of carnivores, a
  list of herbivores and a list of sea mammals:

  #+begin_src emacs-lisp
    (car '((lion tiger cheetah)
           (gazelle antelope zebra)
           (whale dolphin seal)))
  #+end_src

- In this example, the first element or CAR of the list is the list of
  carnivores, ~(lion tiger cheetah)~, and the rest of the list is
  ~((gazelle antelope zebra) (whale dolphin seal))~.

- It is worth saying again that ~car~ and ~cdr~ are
  *not-destructive--that* is, they do not modify or change lists they
  area applied.  This very important for how they are used.

- Also, in the first chapter, in the discussion about atoms, I said
  that in Lisp, certain kinds of atom, such as an /array/ can be
  separated into parts; but the mechanism for doing this is different
  from the mechanism for splitting a list.  As far as Lisp is
  concerned, the atoms of a list are unsplittable.  (See [[][Lisp
  Atoms]]) The ~car~ and ~cdr~ functions are used for *splitting
  lists* and are considered fundamental to Lisp.  Since they cannot
  split or gain access to the parts of an array, an array is
  considered an atom.  Conversely, the other fundamental, ~cons~, can
  put together or construct a list, but not an array.  (Arrays are
  handled by array-specific functions.  See [[][Arrays]] in the GNU
  Emacs Lisp Reference Manual.)

** ~cons~

- The ~cons~ function construct lists; it is the inverse of ~car~ and
  ~cdr~.  For example, ~cons~ can be to make a four element list from
  the three element list, ~(fir oak maple)~

  #+begin_src emacs-lisp
    (cons 'pine '(fir oak maple))
  #+end_src

- After evaluating this list, you will see

  #+begin_src emacs-lisp
    (pines fir oak maple)
  #+end_src

- We often say that ~cons~ puts a new element at the beginning of a
  list, or that it attaches or pushes element onto the list, but this
  phrasing can be misleading, since ~cons~ does /not change an
  existing list/, but /creates/ a new one.

- Like ~car~ and ~cdr~, ~cons~ is non-declarative.

  - [[Build a list][Builds list]]

  - [[Find the Length of a List: ~length~][length]]       How to find the length of a list.

*** Build a list

- ~cons~ must have a list to attach to.  You cannot start from
  absolutely nothing.  If you are building a list, you need to provide
  at least an empty list at the beginning.  Here is a series of ~cons~
  expressions that build up a list of flowers.  If you are reading
  this Info in GNU Emacs, you can evaluate each of the expression in
  the usual way; the value is printed in this text after '~⇒~’, which
  you may read as "evaluates to".

  #+begin_src emacs-lisp
    (cons 'buttercup ())
    ⇒ (butterup)

    (cons 'daisy '(buttercup))
    ⇒ (daisy buttercup)

    (cons 'violet '(daisy buttercup))
    ⇒ (violet daisy buttercup)

    (cons 'rose '(violet daisy buttercup))
    ⇒ (rose daisy buttercup)
  #+end_src

- In the first example, the empty list is shown as ~()~ and list made
  up of ~buttercup~ followed by the empty list is constructed.  As you
  can see, the empty list is not shown in the list that was
  constructed. All that you see is ~(buttercup)~.  The empty list is
  not counted as an element of a list because there is nothing in an
  empty list.  Generally speaking, an empty list is invisible.

- The second example, ~(cons 'daisy '(buttercup))~ construct a new,
  two element list by putting ~daisy~ in front of ~buttercup~; and the
  third example construct a three element list by putting in front of
  ~daisy~ and ~buttercup~.

*** Find the Length of a List: ~length~

- You can find out how many elements there are in a list by using the
  Lisp function ~length~, as in the following examples:

  #+begin_src emacs-lisp
    (length '(buttercup))
    ⇒ 1

    (length '(daisy buttercup))
    ⇒ 2

    (length '(cons 'violet '(daisy buttercup)))
    ⇒ 3
  #+end_src

- In the third example, the ~cons~ function is used to construct a
  three element which is then passed to the ~length~ function as its
  argument.

- We can also use ~length~ to count the number of elements in an empty list:

  #+begin_src emacs-lisp
    (length ())
    ⇒
  #+end_src

- As you would expect, the number of elements in apply list is zero.

- An interesting experiment is to find out what happens if you try to
  find the length of no list at all; that is, if you try to call
  ~length~ without giving it an argument, not even an empty list:

  #+begin_src emacs-lisp
    (length )
  #+end_src

** ~nthcdr~

- The ~nthcdr~ function is associated with the ~cdr~ function.  What
  it does is take the CDR of a list repeatedly.

- If you take the CDR of the list ~(pine fir oak maple)~, you will be
  returned the list ~(fir oak maple)~.  If you repeat this on what was
  returned, you will be returned the list ~(oak maple)~.  (Of course,
  repeated CDRing on the original list will just give the original CDR
  since the function does not change th list.  You need to evaluate
  the CDR of the CDR and so on.)  If you continue this, eventually you
  will be returned an empty list, which in this case, instead of being
  shown as ~()~ is shown as ~nil~.

- For review, here is a series of repeated CDRs, the text following
  the '~⇒~' shows what returned.

  #+begin_src emacs-lisp
    (cdr '(pine fir oak maple))
    ⇒ (fir oak maple)

    (cdr '(fir oak maple))
    ⇒ *(oak maple)

    (cdr '(oak maple))

    ⇒ (maple)

    (cdr '(maple))
    ⇒ nil

    (cdr 'nil)
    ⇒ nil

    (cdr ())
    ⇒ nil
  #+end_src

- You can also do several CDRs without printing the values in between,
  like this:

  #+begin_src emacs-lisp
    (cdr (cdr '(pine fir oak maple)))
    ⇒ (oak maple)
  #+end_src

- In this example, the Lisp interpreter evaluates the innermost list
  quoted, so it just passes the list as it is to the innermost ~cdr~.
  This ~cdr~ passes a list made up of the second and subsequent
  element of the list to the outermost ~cdr~, which produces a list
  composed of the third and subsequent elements of the original list.
  In this example, the ~cdr~ function is repeated and returns a list
  that consists of the original list without its first two element.

- The ~nthcdr~ function does the same thing as repeating the call to
  ~cdr~.  In the following example, the argument 2 is passed to the
  function ~nthcdr~, along with the list, and the value returned is
  the list without its first two items, which is exactly the same as
  repeating ~cdr~ twice on the list:

  #+begin_src emacs-lisp
    (nthcdr 2 '(pine fir oak maple))
    ⇒ (oak maple)
  #+end_src

- Using the original four elements list, we can see what happens when
  various numeric arguments are passed to ~nthcdr~, including 0, 1, and 5:

  #+begin_src emacs-lisp
    ;; leave the list as it was.
    (nthcdr 0 ' (pine fir oak maple))
    ⇒ (pine fir oak maple)

    ;; Return a copy without the first element.
    (nthcdr 1 '(pine fir oak maple))
    ⇒ (fir oak maple)

    ;; Return a copy of the list without three elements
    (nthcdr 3 '(pine fir oak maple))
    ⇒ (maple)

    ;; Return a copy lacking all four elements
    (nthcdr 4 '(pine fir oak maple))
    ⇒ ()

    ;; Return a copy lacking all elements
    (nthcdr 5 '(pine fir oak maple))
    ⇒ nil
  #+end_src

** ~nth~

- The ~nthcdr~ function takes the CDR of a list repeatedly.  The ~nth~
  function takes the CAR of the result returned by ~nthcdr~.  It
  returns the Nth element of the list.

- Thus, if it were not defined in C for speed, the definition of ~nth~ would be:

  #+begin_src emacs-lisp
    (defun nth (n list)
      "Return the Nth element of LIST.
    N count from zero.  If LIST is not that long, nil is returned."
      (car (nthcdr n list)))
  #+end_src

- (Originally, ~nth~ was defined in Emacs Lisp in ~subr.el~, but its
  definition was redone in C in the 1980s.)

- The ~nth~ function returns a single element of a list.  This can be
  very convenient.

- Note that the elements are numbered from *zero*, not one.  That is
  to say, the first element of a list, its CAR is the zeroth element.
  This zero-based counting often bothers people who are accustomed to
  the first element in a list bring number one, which is one-based.

- For example:

  #+begin_src emacs-lisp
    (nth 0 '("one" "two" "three"))
    ⇒ "one"

    (nth 1 '("one" "two" "three"))
    ⇒ "two"
  #+end_src

- It is worth mentioning that ~nth~, like ~nthcdr~ and ~cdr~m does
  change the original list--the function is non-destructive.  This in
  sharp contrast to the ~setcar~ and ~setcdr~ functions.
** ~setcar~

- As you might guess from their names, the ~setcar~ and ~setcdr~
  functions set the CAR or the CDR of a list, to a new value.  The
  actually change the original list, unlike ~car~ and ~cdr~ which
  leave the original list at it was.  One to find way out how this
  works is to experiment.  We will start with the ~setcar~ function.

- First, we can  make a list and  then set the value of  a variable to
  the list, using  the ~setq~ special form.  Because we  intend to use
  ~setcar~ to change  the list, this ~setq~ should not  use the quoted
  form ~'(antelope  girrafe lion tiger)~,  as that would yield  a list
  that is part of the program and  bad things could happen if we tried
  to change part of the  program while running.  Generally speaking an
  Emacs Lisp  program's components  should be constant  (or unchanged)
  while the  program is  running.  So we  instead construct  an animal
  list by using the ~list~ function, as follows:

  #+begin_src emacs-lisp
    (setq animals (list 'antelope 'girafe 'lion 'tiger))
  #+end_src

- If you are reading this in Info inside of GNU Emacs, you can
  evaluate this expression in the usual fashion, by positioning the
  cursor after the expression and typing ~C-x C-e~.  (I'm doing right
  here as I write this.  This is one of the advantages of having the
  interpreter built into the computing environment.  Incidentally,
  when there is nothing on the line after the final parentheses, such
  as a comment, point can be on the next line. Thus, if your cursor is
  in the first column of the next line, you do not need to move it.
  Indeed Emacs permits any amount of white space after the final
  parenthesis.)

- When evaluate the variable ~animals~, we can see that it is bound to
  the list ~(antelope giraffe lion tiger)~:

  #+begin_src emacs-lisp
       animals
    ⇒ (antelope giraffe lion tiger)
  #+end_src

- Put another way the variable ~animals~ points to the list ~(antelope
  giraffe lion tiger)~.

- Next, evaluate the function ~setcar~ while passing it two arguments,
  the variable ~animals~ and the quoted symbol ~hippopotamus~; this is
  done by writing the three element list ~(setcar animals
  'hippopotamus)~ and then evaluating it in the usual fashion:

  #+begin_src emacs-lisp
    (setcar animals 'hippopotamus)
  #+end_src

- After evaluating this expression, evaluate the variable ~animals~
  again.  You will see that the list of animals has changed:

  #+begin_src emacs-lisp
    animals
    ⇒ (hippopotamus giraffe lion tiger)
  #+end_src

- The first element on the list, ~antelope~ is replaced by
  ~hippopotamus~.

- So we can see that ~setcar~ did not add new element to the list as
  ~cons~ would have; it replaced ~antelope~ with ~hippopotamus~; it
  /changed/ the list.
** ~setcdr~

- The ~setcdr~ function is similar to the ~setcar~ function, except
  that function replaces the second and subsequent elements of a list
  rather than the first element.

- (To see how to change the last element of a list, look to [[][The
  ~kill~new~ function~]] which uses the ~nthcdr~ and ~setcdr~
  functions.)

- To see how this works, set the value of the variable to a list of
  domesticated animals by evaluating the following expression:

  #+begin_src emacs-lisp
    (setq domesticated-animals (list 'horse 'cow 'sheep 'goat))
  #+end_src

- If you now evaluate the list, you will be returned the list ~(horse
  cow sheep goat)~:

  #+begin_src emacs-lisp
    domesticated-animals
    ⇒ (horse cow sheep goat)
  #+end_src

- Next, evaluate ~setcdr~ with two argument, the name of the variable
  which has a list as its value, and the list to which the CDR of the
  first list will be set;

  #+begin_src emacs-lisp
    (setcdr domesticated-animals '(cat dog))
  #+end_src

- If you evaluate this expression, the list ~(cat dog)~ will appear in
  the echo area.  This is the value returned by the function.  The
  result we are interested is the side effect, which we can see by
  evaluating the variable ~domesticated-animals~:

  #+begin_src emacs-lisp
    domisticated-animals
    ⇒ (horse cat dog)
  #+end_src

- Indeed, the list changed from ~(horse cow sheep goat)~ to ~(horse
  cat dog)~.  The CDR of the list is changed from ~(cow sheep goat)~
  to ~(cat dog)~.


* Cutting and Storing Text

- Whenever you cut or clip text out of buffer with a /kill/ command in
  GNU Emacs, it is stored in a list and you can bring it back with a
  /yank/ command.

- (The use of the word "kill" in Emacs for process which specifically
  /do not/ destroy the value of the entities is an unfortunate
  historical accident. A much more appropriate word would be "clip"
  since that is the kill commands do; they clip text out of buffer and
  put it into storage from which it can be brought back.  I have often
  been tempted to replace globally all occurrences of "kill" in the
  Emacs source with "clip" and all occurrences o "killed" with
  "clipped").

  - [[Storing Text in a List][Storing Text]]                  Text is stored in a list

  - [[~zap-to-char~][zap-to-char]]                   Cutting out text up to character

  - [[~kill-region~][kill-region]]                   Cutting text out of a region

  - [[~copy-region-as-kill~][copy-to-region-as-kill]]        A definition for copying text

  - [[Digression into C][Digression into C]]             Minor note on C programming language macros

  - [[Initializing a Variable with ~defvar~][defvar]]                        How to give a variable an initial value

  - [[Review][cons & search-fwd Review]]      How to give a variable an initial value

** Storing Text in a List

- When text is cut out of a buffer, it is stored on a list.
  Successive pieces of text are stored on the list successively, so
  the list might look like this:

  #+begin_src emacs-lisp
    ("a piece of text" "previous piece")
  #+end_src

- The function ~cons~ can be used to create a new list from a piece of
  text (an "atom", to use the jargon) and an existing list, like this:

  #+begin_src emacs-lisp
    (cons "another piece"
          '("a piece of text" "previous piece"))
  #+end_src

- If you evaluate this expression, a list of three elements will
  appear in the echo area:

  #+begin_src emacs-lisp
    ("anothe piece" "a apiece of text" "previous piece")
  #+end_src

- With the ~car~ and ~nthcdr~ functions, you can retrieve whichever
  piece of text you want.  For example, in the following code, ~nthcdr
  1 ...~ returns the list with the first item removed; and the ~car~
  returns the first element of that remainder--the second element of
  the original list:

  #+begin_src emacs-lisp
    (car (nthcdr 1 '("another piece"
        "a piece of text"
    "previous piece")))
  #+end_src

- The actual functions in Emacs are more complex than this, of course.
  The code for cutting and retrieving text has to be written so that
  Emacs can figure out which element in the list you want--the first,
  second, third, or whatever.  In addition, when you get to the end of
  the list, Emacs should give you the first element of the list,
  rather than nothing at all.

- The list that holds the pieces of the text is called the /kill
  ring/. This chapter lead up to a description of the kill ring, and
  how it is used by first tracing how the ~zap-to-char~ functions
  works.  This function calls a function that invoke a function that
  manipulates the kill ring.  Thus, before reaching the mountains, we
  climb the foothills.

- A subsequent chapter describes how text that is cut from the buffer
  is retrieved. See [[][Yanking Text Back]]

** ~zap-to-char~

- Let us look at the interactive ~zap-to-char~ function.

  - [[The complete ~zap-to-char~ Implementation][Complete zap-to-char]]             The complete implementation
  - [[The ~interactive~ Expression][zap-to-char interactive]]          A three part interactive expression
  - [[The Body of ~zap-to-char~][zap-to-char body]]                              A short overview
  - [[The ~search-forward~ Function][search forward]]                How to search for a string
  - [[The ~progn~ Special Form][prongn]]                                 The ~progn~ special form
  - [[Summing up ~zap-to-char~][Summing up zap-to-char]        Using ~point~ and ~search-forward~

*** The complete ~zap-to-char~ Implementation

- The ~zap~to-char~ functions removes the next text in the region
  between the location of the cursor (i.e of point) up to and
  including the next occurrence of a specified character.  The text
  ~zap-to-char~ removes is put in the kill ring; and it can be
  retrieved from the kill ring by typing ~C-y (yank)~.  If the
  commands is given an argument, it removes text through that numbers
  of occurrences.  Thus, if the cursor were at the beginning of this
  sentence and the character were '~s~', '~Thus~; would be removed.
  If the argument were two, '~Thus, if the curs~', would be removed ,
  up to and including he '~s~' in '~cursor~'.

- If the specified character is not found, ~zap-to-char~ will say
  "Search failed", tell you the character you typed, and not remove
  any text.

- In order to determine how much text remove, ~zap-to-char~ uses a
  search function.  Searches are used in code that manipulates text,
  and we will focus attention on them as well on the deletion command.

- Here is the complete text of the version 22 implementation of the
  function:

  #+begin_src emacs-lisp
    (defun zap-to-char (arg char)
      "Kill up to and including ARG'th occurance of CHAR.
            Case is ignored if `case-fold-search' is non-nil in the current buffer.
            Goes backward if ARG is negative; error if CHAR not found."
      (interavtive"p\ncZap to char: ")
      (if (char-table-p translation-table-for-input)
          (setq char (or (aref translation-tabel-for-input-char) char)))
      (kill-region (point) (progn
                             (search-forward (char-to-string char)
                                             nil nil arg)
                             (point))))
  #+end_src

- The documentation is thorough.  You do need to know the jargon
  meaning of word "kill".

- The version 22 documentation string of ~zap-to-char~ uses ASCII
  accent and apostrophe to quote a symbol, so it appears
  ~`case-fold-search'~.  This quoting style was inspired by 1970s-era
  displays in which grave accent ans apostrophe were often mirror
  image for use as quotes.  On most modern displays this is no longer
  need true, and when these two ASCII characters appear in
  documentation strings or diagnostic message formats, Emacs typically
  transliterates them to /curve quotes/ (left and right single
  (quotation marks), so that the abovequoted symbols appears as
  ~`case-fold-search'~.  Source-code string can also simply use curved
  quoted directly.

*** The ~interactive~ Expression

- The interactive expression in the ~zap-to-char~ commands looks like this:

  #+begin_src emacs-lisp
    (interative "p\ncZap to char: ")
  #+end_src

- The part within quotation marks, ~"p\nZap to char: "~ is ~`cZap to
  char: '~.  In this part, the lower case '~c~' indicates that
  ~interactive~ expects a prompt and that prompt ans that the argument
  will be a character.  The prompt follows the '~c~' and is the string
  ~`Zap to char: '~ (with a space after the colon to make it look
  good).

- What all this does is prepare the arguments to ~zap-to-char~
  function copies the text to the kill ring, but does not remove it.
  The echo area displays a message saying that the buffer is
  read-only.  Also, the terminal may beep or blink at you.

*** The Body of ~zap-to-char~

- The body of the ~zap-to-char- function contains the code that kills
  (that is, remove) the next text in the region from the current
  position from the current position of the cursor up to and including
  the specified character.

- The first part of the code looks like this:

  #+begin_src emacs-lisp
    (if (char-table-p translation-table-for-input)
        (setq char (or (aref translation-table-for-input char) char)))
    (kill-region (point) (progn
                           (search-forward (char-to-string char) nil nil arg)
                           (point)))
  #+end_src

~char-table-p~ is a hitherto unseen function.  It determine whether
its argument is a character table.  When it is, sets the charter
passed to ~zap-to-char~ to one of them, if that character exist, or to
the character itself.  (This becomes important for certain characters
in non-European languages.  The ~aref~ function extracts an element an
array. It is an array-specific function that is not described in this
document.  See [[][Arrays]] in The GNU Emacs lisp Reference Manual.)

- ~(point)~ is the current position of the cursor.

- The next part of the code is an expression using ~progn~.  The body
  of the ~progn~ consists of call ~search-forward~ and ~point~.

- It easier to understand how ~progn~ works after learning about
  ~search-forward~, so we will look at ~search-forward~ and then at
  ~progn~.

*** The ~search-forward~ Function

- The ~search-forward~ function is used to locate the
  zapped-for-character in the ~zap-to-char~.  If the search is
  successful, ~search-forward~ leaves point immediately after the last
  character in the target string.  (In ~zap~to-char~, the target
  string is just one character long. ~zap-to-char~ uses the function
  ~char-to-string~ to ensure that the computer treats that character
  as a string.)

- In the ~zap-to-char~, the ~search-forward~ function looks like this:

  #+begin_src emacs-lisp
    (search-forward (char-to-string char) nil nil arg)
  #+end_src

- The ~search-forwad~ function takes four arguments:

  1. The first argument is the target, what is searched for. This must
     be a string, such as '~"z"~'.

     As it happens, the argument passed to ~zap-to-char~ is a single
     character.  Because of the way computers are a built, the Lisp
     interpreter may treat a single characters as being different form
     a string of characters.  Inside the computer, a single character
     has different electronic format than a string of one character.
     (A single character can often be recorded in the computer using
     exactly one byte; but a string may no longer, and the computer
     needs to be ready for this.)  Since the ~search-forward~ function
     searcher for a string, the character that the ~zap-to-char~
     function receives as its argument must be converted inside the
     computer form one format to the other; otherwise the
     ~search-forward~ function will fail.  The ~char-to-string~
     function is used to make this conversion.

  2. The second argument bounds the search; it is specified as a
     position in the buffer.  In this case, the search can go to the
     end of the buffer, so no bound is set and the second argument is
     ~nil~.

  3. The third argument tells the function what it should do if the
     search fails--it can signal an error (and print a message) or it
     can return ~nil~.  A ~nil~ as the third argument causes the
     function to signal an error when the search fails.

  4. The fourth argument to ~search-forward~ is the repeat count--how
     many occurrences of the string to look for.  This argument is
     optional and if the function is called without a repeat count,
     this argument is passed the value 1.  If this argument is
     negative, the search goes backwards.

- In template form, a ~search-forward~ expression looks like this:

  #+begin_src emacs-lisp
    (search-forward "target-string"
                    limit-of-search
                    what-to-do-if-search-fails
                    repeat-count)
  #+end_src

  We will look at ~progn~ next.

*** The ~progn~ Special Form

- ~progn~ is a special form that causes each of its arguments to be
  evaluated in sequence and then the value returns the value of the
  last one.  The preceding expressions are evaluated only for the side
  effects they perform. The value produced by them are discarded.

- The template for a ~progn~ expression is very simple"

  #+begin_src emacs-lisp
    (progn
      body...)
  #+end_src

- In ~zap-to-char, the ~progn~ expression has to do two things: put
  point in exactly the right position; and return the location of
  point so that ~kill-region~ will know how far to kill to.

- The first argument to the ~progn~ is ~search-forward~.  When
  ~search-forward~ finds the string, the function leaves point
  immediately after the last character in the target string.  (In this
  case the target string is just one character long.)  If the search
  is backwards, ~search-forward~ leaves point just before the first
  character in target.  The movement of point is a side effect.

*** Summing up ~zap-to-char~

- Now that we have seen how ~search-forward~ and ~progn~ work, we can
  see how the ~zap-to-char~ function work as a whole.

- The first argument to ~kill-region~ is the position of the cursor
  when ~zap-to-char~ command is given--the value of point at that
  time.  Within the ~progn~, the search function then moves point to
  just after the zapped-to-character and ~point~ returns the value of
  this location.  The ~kill-region~ function puts together these two
  value of point, the first one as the beginning of the region and the
  second one as the end of the region, and removes the region.

- The ~progn~ special form is necessary because the ~kill-region~
  command takes two argument; and it wold fail if ~search-forward~ and
  ~point~ expression were written in sequence as two additional
  arguments.  The ~progn~ expression is a single argument to
  ~kill-region~ and returns the one that ~kill-region~ needs for its
  second argument.

** ~kill-region~

- The ~zap-to-char~ function uses the ~kill-region~ function.  This
  function clip text from a region and copies that text to the kill
  ring, from which it may be retrieved.

- The Emacs 22 version of that function uses ~condition-case~ and
  ~copy-region-as-kill~, both of which we will explain.
  ~condition-case~ is an important special form.

- In essence, the ~kill-region~ function calls ~condition-case~, which
  takes three arguments.  In this function, the first argument does
  nothing. The second argument contains the code that does the work
  when all goes well.  The third argument contains the code that is
  called in the event of an error.

  - [[The Complete ~kill-region~ Definition][Complete kill-region]]          The function definition
  - [[~condition-case~][condition-case]]                             Dealing with a problem
  - [[Lisp macro][Lisp macro]]

*** The Complete ~kill-region~ Definition

- We will go through the ~condition-case~ code in a moment.  First,
  let us look at the definition of ~kill-region~, with comments added:

  #+begin_src emacs-lisp
    (defun kill-region (beg end)
      "Kill (\"cut\") text between point and mark.
    This deletes the text from the buffer and saves it in the kill ring.
    The command \\[yank] can retrieve it from there. … "


      ;; • Since order matters, pass point first.
      (interactive (list (point) (mark)))
      ;; • And tell us if we cannot cut the text.
      ;; 'unless' is an 'if' without a then-part.
      (unless (and beg end)
        (error "The mark is not set now, so there is no region"))


      ;; • 'condition-case' takes three arguments.
      ;;    If the first argument is nil, as it is here,
      ;;    information about the error signal is not
      ;;    stored for use by another function.
      (condition-case nil


          ;; • The second argument to 'condition-case' tells the
          ;;    Lisp interpreter what to do when all goes well.


          ;;    It starts with a 'let' function that extracts the string
          ;;    and tests whether it exists.  If so (that is what the
          ;;    'when' checks), it calls an 'if' function that determines
          ;;    whether the previous command was another call to
          ;;    'kill-region'; if it was, then the new text is appended to
          ;;    the previous text; if not, then a different function,
          ;;    'kill-new', is called.


          ;;    The 'kill-append' function concatenates the new string and
          ;;    the old.  The 'kill-new' function inserts text into a new
          ;;    item in the kill ring.


          ;;    'when' is an 'if' without an else-part.  The second 'when'
          ;;    again checks whether the current string exists; in
          ;;    addition, it checks whether the previous command was
          ;;    another call to 'kill-region'.  If one or the other
          ;;    condition is true, then it sets the current command to
          ;;    be 'kill-region'.

          (let ((string (filter-buffer-substring beg end t)))
            (when string                    ;STRING is nil if BEG = END
              ;; Add that string to the kill ring, one way or another.
              (if (eq last-command 'kill-region)

                  ;;    - 'yank-handler' is an optional argument to
                  ;;    'kill-region' that tells the 'kill-append' and
                  ;;    'kill-new' functions how deal with properties
                  ;;    added to the text, such as 'bold' or 'italics'.
                  (kill-append string (< end beg) yank-handler)
                (kill-new string nil yank-handler)))
            (when (or string (eq last-command 'kill-region))
              (setq this-command 'kill-region))
            nil)


        ;;  • The third argument to 'condition-case' tells the interpreter
        ;;    what to do with an error.

        ;;    The third argument has a conditions part and a body part.
        ;;    If the conditions are met (in this case,
        ;;             if text or buffer are read-only)
        ;;    then the body is executed.

        ;;    The first part of the third argument is the following:
        ((buffer-read-only text-read-only) ;; the if-part
         ;; …  the then-part
         (copy-region-as-kill beg end)

         ;;    Next, also as part of the then-part, set this-command, so
         ;;    it will be set in an error
         (setq this-command 'kill-region)
         ;;    Finally, in the then-part, send a message if you may copy
         ;;    the text to the kill ring without signaling an error, but
         ;;    don't if you may not.

         (if kill-read-only-ok
             (progn (message "Read only text copied to kill ring") nil)
           (barf-if-buffer-read-only)
           ;; If the buffer isn't read-only, the text is.
           (signal 'text-read-only (list (current-buffer)))))

  #+end_src

*** ~condition-case~

- As er have seen earlier (see [][Generate an Error Message]]), when
  the Emacs Lisp interpreter has trouble evaluating an expression, it
  provides you with help; in the jargon, this is called "signaling an
  error".  Usually, the computer stops the program and shows you a
  message.

- However, some programs undertake complicated actions.  They should
  not simply stop an error.  In the ~kill-region~ function, the most
  likely error is that you will try to kill text that is read-only and
  cannot be removed.  So the ~kill-region~ function contains code to
  handle this circumstance.  This code, which makes up the body of the
  ~kill-region~ function, is inside of a ~condition-case~ special form.

- The template for ~condition-case~ looks like this:

  #+begin_src emacs-lisp
    (condition-case
        var
        bodyform
      error-handler...)
  #+end_src

- The second argument, /bodyform/, is straightforward.  The
  ~condition-case~ special form causes the Lisp interpreter to
  evaluate the code in /bodyform/.  If no error occurs, the special
  form returns the code's value and produces the side-effect, if any.

- In short, the /bodyform/ part of a ~condition-case~ expression
  determines what should happen when everything works correctly.

- However, if an errors occurs, among its other actions, the function
  generating the errors signal will define one or more error condition
  names.

- An error handlers is the third argument to ~condition-name~. An
  error handlers has two parts, a /condition-name/ and a /body/.  If
  the /condition-name/ part of an error handler matches a condition
  name generated by an error, then the /body/ part of the error
  handlers is run.

- As you will expect, the /condition-name/ part of an error handlers
  may be either a single condition name or a list of condition names.

- Also, a complete ~condition-case~ expression may contain more than
  one error handler. When an error occurs, the first applicable
  handler is run.

- Lastly, the first argument to the ~condition-case~ expression, the
  /var/ argument, is sometimes bound to a variable that contains
  information about the error.  However, if that argument is nil, as
  is the case in ~kill-region~, that information is discarded.

- In brief, in the ~kill-region~ function, the code ~condition-case~
  works like this:

  #+begin_src emacs_lisp
    If no errors, run only this code
       but, id errors, run this other code.
  #+end_src

*** Lisp macro

- The part of the ~condition-case~ expression that is evaluated in the
  expectation that all goes well has a ~when~.  The code uses ~when~
  to determine whether the ~string~ variable points to the text that
  exists.

- A ~when~ expression is simply a programmers' convenience.  It is an
  ~if~ without the possibility of an else clause.  In your mind, you
  can replace ~when~ with ~if~ and understand what goes on.  That is
  what the Lisp interpreter does.

- Technically speaking, ~when~ is a Lisp macro.  A Lisp macro enables
  you to define new control constructs and other language features.
  It will tells the interpreter how to compute another Lisp expression
  which will in turn compute the value.  In this case. the other
  expression is an ~if~ expression.

- The ~kill-region~ function definition also has an ~unless~ macro; it
  is the converse of ~when~.  The ~unless~ macro is an ~if~ without a
  then clause.

- For more about Lisp macros, see [[][Macros]] in The GNU Emacs Lisp
  Reference Manual.  The C programming language also provide macros.
  These are different, but also useful.

- Regarding the ~when~ macro, in the ~condition-case~ expression, when
  the string has content, then another conditional expression is
  executed.  This mean is an ~if~ with both a then-part and an
  else-part.

  #+begin_src emacs-lisp
    (if (eq last-command 'kill-region)
        (kill-append string (< end beg) yank handlerr)
      (kill-new string nil yank-handlers))
  #+end_src

- The then-part is evaluated if the previous command was another to
  ~kill-region~; if not, the else-part is evaluated.

- ~yank-handlers~ is an optional argument to ~kill-region~ that tells
  the ~kill-append~ and ~kill-new~ functions how deal with properties
  added to the text, such as bold or italics.

~last-command~ is variable that comes with Emacs that we have not seen
before.  Normally, whenever a function is executed, Emacs sets the
value of ~last-command~ to the previous command.

- In this segment of definition, the ~if~ expression checks whether
  the previous command was ~kill-region~.  If it was.

  #+begin_src emacs-lisp
  #    (kill-append string (< end bag) yank-handlers.
  #+end_src

** ~copy-region-as-kill~

- The ~copy-region-as-kill~ function copies a region of text from a
  buffer and (via either ~kill-append~ or ~kill-new~) saves it in the
  ~kill-ring~.

- If you call ~copy-region-kill~ immediately after a ~kill-region~
  command, Emacs appends the newly copied text to the previously
  copied text.  This mean that if you yank back the text, you will get
  it all, from both this and the previous operation.  on the other
  hand, if some other command precedes the ~copy-region-as-kill~, the
  function copies the text into a separate entry in the kill ring.

  - [[The complete ~copy-region-as-kill~ function definition][Complete copy-region-as-kill]]    The complete function definition.

  - [[The Body of ~copy-region-as-kill~][copy-region-as-kill body]]    The body of ~copy-region-as-kill~.

*** The complete ~copy-region-as-kill~ function definition

- Here is the complete text of the version 22 ~copy-region-as-kill~
  function:

  #+begin_src emacs-lisp
    (defun copy-region-as-kill (beg end)
      "Save the region as if killed, but don't kill it.
    In Transient Mark mode, deactivate the mark.
    If `interprogram-cut-function' is non nil, also save the text for a window
    system cut and paste."
      (interactive "r")
      (if (eq last-command 'kill-region)
          (kill-append (filter-buffer-substring beg end) (< end beg))
        (kill-new (filter-buffer-substring beg end)))

      (if transient-mark-mode
          (setq deactive-mar t))
      nil)
  #+end_src

- As usual, this function can be divided into its component parts:

  #+begin_src emacs-lisp
    (defun copy-region-as-kill (argument-list)
      "documentation..."
      (interacritive "r")
      body...)

  #+end_src

- The arguments are ~beg~ and ~end~ and the function is interactive
  with ~"r"~, so the two arguments must refer to the beginning and end
  of the region.  If you have been reading through this documentation
  from beginning, understand these parts of a function is almost
  becoming routine.

- The documentation is somewhat confusing unless you remember that the
  word "kill" has a meaning from usual.  The Transient Mark and
  ~interprogram-cut-function~ comments explain certain side-effects.

- After you once set a mark, a buffer always contains a region.  If
  you wish, you can use Transient Mark mode to highlight the region
  temporarily.  (No one wants to highlight the region all the time, so
  Transient Mark mode highlight it only at appropriate time.  Many
  people turn off Transient Mark mode, so the region id never
  highlighted.)

- The body of ~copy-region-as-kill~ function starts with an ~if~
  clause.  What this clause does is distinguish between two different
  situations: whether or not this command is executed immediately
  after previous ~kill-region~ command.  In this case, the region is
  appended to the previously copied text.  Otherwise, it is inserted
  into the beginning of the kill ring as a separate piece of text from
  the previous piece.a

- The last two lines of the function prevent the region from lighting
  up if Transient Mark mode is turned on.

- The body of ~copy-region-as-kill~ merits discussion in detail.

*** The Body of ~copy-region-as-kill~

- The ~copy-region-as-kill~ function works in much the same way as the
  ~kill-region~ function. Both are written so that two or more kills
  in a row combine their text into a single entry.  If you yank back
  the text from the kill ring, you get it all in one piece.  Moreover,
  kills that kill forward from the current position of the cursor are
  added to the end of the previously copied text and commands that
  copy text backwards add it to the beginning of the previously copied
  text.  This way, the words in the text stay in the proper order.

- Like ~kill-region~, the ~copy-region-as-kill~ function makes use of
  the ~last-command~ variable that keeps track of the previous Emacs
  command.

  - [[~last-command~ and ~this-command~][last-command & this-command]]

  - [[The ~kill-append~ function][kill-append function]]

  - [[The ~kill-new~ function][kill-new function]]

**** ~last-command~ and ~this-command~

- Normally. whenever a function is executed, Emacs sets the value of
  ~this-command~ to the function being executed (which in this case
  would be ~copy-region-as-kill~).  At the same time, Emacs sets the
  value of ~last-command~ to the previous value of ~this-command~.

- In the first part of the body of the ~copy-region-as-kill~ function,
  an ~if~ expression determines whether the value of ~last-command~ is
  ~kill-region~.  If so, the ten-part of the ~if~ expression id
  evaluated; it uses the ~kill-append~ function to concatenate the
  text copied at this call to the function with text in the text
  already in the first element (the CAR) of the kill ring.  On the
  other hand, if the value of ~last-command~ is not ~kil-region~, then
  the ~copy-region-as-kill~ function a new element to the kill ring
  using the ~kill-new~ function.

- The ~if~ expression reads as follows; it use ~eq~:

  #+begin_src emacs-lisp
    (if (eq last-command 'kill-region)
        ;; then-part
        (kill-apend (filter-buffer-substring beg end) (< end beg))
      ;; else-part
      (kill-new (filter-buffer-substring beg end)))
  #+end_src

- (The ~filter-buffer-substring~ function returns a filtered substring
  of the buffer, if any.  Optionally--the arguments are not here, so
  neither is done--the function may delete the initial text or return
  the text without its properties; this function is a replacement for
  the older ~buffer-substring~ function, which came before text
  properties were implemented.)

- The ~eq~ function tests whether its first argument is the same Lisp
  object as its second argument.  The ~eq~ function is similar to the
  ~equal~ function in that it is used to test for equality, but
  differs in that it determines whether two representations are
  actually the same object inside the computer, but with different
  names.  ~equal~ determines whether the structure and contents of two
  expression are the same.

- If the previous command was ~kill-region~, then the Emacs Lisp
  interpreter calls the ~kill-append~ function.

**** The ~kill-append~ function

- The ~kill-apend~ function looks like this:

  #+begin_src emacs-lisp
    (defun kill-append (string before-p &optional yank-handler)
      "Append STRING to the end of the latest kill the kill ring.
    If BEFORE-P is non-nill, prepend STRING to the kill.
    ..."
      (let* ((cur (car kill-ring)))
        (kill-new (if before-p (concat string cur) (concat cur string))
                  (or (= (length cur) 0)
                      (equal yank-handler
                             (get-text-property 0 'yank-handler  cur)))
                  yank-handler)))
 #+end_src

- The ~kill-append~ function is fairly straightforward.  It uses the
  ~kill-new~ function, which we will discuss in more detail in a
  moment.

- (Also, the function provides aw optional argument called
  ~yanked-handler~; when invoked, this argument tells the function how
  to deal with properties added to the text, such as bold or
  italics.)

- It has a ~let*~ function to set the value of this element of the
  kill ring to ~cur~.  (I do not know why the function does not use
  ~let~ instead; only one value is set in the expression.  Perhaps
  this is a bug that produces no problem?)

- Consider the conditional that is one of the two arguments to
  ~kill-new~.  It uses ~concat~ to concatenate the new text to the CAR
  of the kill ring.  Whether it prepends or appends the text depends
  on the result of an ~if~ expression:

  #+begin_src emacs-lisp
    eif before-p                      ; if-part
        (concat string cur)           ; then-part
      (concat cur string              ; else-part
  #+end_src

- If the region being killed is before the region in the last command,
  then it should be prepend before the material that was saved in the
  previous kill; and conversely, if the killed text follows what was
  just killed, it should be appended after the previous text.  The
  ~if~ expression depends on the predict ~before-p~ to decide whether
  the newly saved text should be put before or after the previously
  saved text.

- The symbol ~before-p~ is the name of one argument to ~kill-append~.
  When the ~kill-append~ function is evaluated, it is bound to the
  value returned by evaluating the actual argument.  In this case,
  this is the expression ~(< end beg)~.  This expression does not
  directly determine whether the killed text in this command is
  located before or after the kill text of the last command; what it
  does is determine whether the value of the variable ~end~ id less
  then the value of the variable ~beg~.  If it is, it means that the
  user is most likely heading towards the beginning of the buffer.
  Also, the result of evaluating the predicate expression ~(< end
  beg)~, will be true and the text will be prepended before the
  previous text.  On the other hand, if the value of the variable
  ~end~ is greater than the value of the variable ~beg~, the text will
  appended after the previous text.

- When the newly saved text will be prepended, then the string with
  the new text will be concatenated before the old text:

  #+begin_src emacs-lisp
    (concat string cur)
  #+end_src

- Bur if the text will be appended, it will be concatenated after the
  old text:

  #+begin_src emacs-lisp
    (contat cur string))
  #+end_src

- To understand how this works, we first need to review the ~concat~
  function. The ~concat~ function links together or unites two strings
  of the text.  The result is a string.  For example:

  #+begin_src emacs-lisp
    (concat "abc" "def")
                ⇒ "abcdef"

    (concat "new "
            (car '("first element" "second element")))
                ⇒ "new first element"

    (concat (car
             '("first element" "second element")) "modified")
                ⇒ "first element modified"
  #+end_src


- We can now make sense of ~kill-append~: it modifies the contents of
  the kill ring.  The kill ring is a list, each element of which is
  saved text.  The ~kill-append~ function uses the ~kill-new~ function
  which in turns uses the ~setcar~ function.

**** The ~kill-new~ function

- In version 22 the ~kill-new~ function looks like this:

  #+begin_src emacs-lisp
    (defun kill-new (string &optional replace yank-handler)
      "Make STRING the latest kill in the kill ring.
    Set `kill-ring-yank-pointer' to point to it.

    I `interprogram-cut-function' is non-nil, apply it to STRING.
    Optional second argument REPLACE non-nil mans that STRING will replace
    the optional front of the kill ring, rather than being added to the list.
    ..."

      (if (> (length string) 0)
          (if yank-handler
              (put-text-property 0 (length string)
                                 'yank-handler yank-handler string))

        (if yank-handler
            (signal 'args-out-of-range
                    (list string "yank-hander specified for empty string")))

        (if (fbound 'menu-bar-update-yank-menu)
            (menu-bar-update-yank-menu string (and replace (car kill-ring))))

        (if (and replace kill-ring)
            (setcar kill-ring string)
          (push string kill-ring)
          (if (< length kill-ring) kill-ring-max)
          (setcdr (nthcdr (1- kill-ring-max) kill-ring nil)))

        (setq kill-ring-yank-pointer kill-ring)
        (if interprogram-cut-function
            (funcall interporgram-cut-funtion string (not replace))))
  #+end_src

- (Notice that the function id not interactive)

- As usual, we can look at this function in parts

- The function definition has an optional ~yank-handler~ argument,
  which when invoked tells the function how to deal with properties
  added to the text, such as bold or italics.  We will sip that.

- The first line of the documentation makes sense"

  #+begin_src emacs-lisp
    Make STRING the latest kill in the kill ring.
  #+end_src

- Also, let's skip over the initial ~if~ expression and those lines of
  code involving ~menu-bar-update-yank-menu~.  We will explain them
  below.

- The critical lines are these:

  #+begin_src emacs-lisp
    (if (and replace kill-ring)
        ;; then
        (setcar kill-ring string)
      ;; else
      (push string kill-ring)
      (if (< (length- kill-ring) kill-ring-max)
          ;; avoid overlay long kill ring
          (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
    (setq kill-ring-yank-pointer kill-ring)
    (if interprogram-cut-function
        (funcal interprogram-cut-function string (not replace))))
  #+end_src

- The conditional test id ~(and replace kill-ring)~.  This will be
  true when two conditions are met: the kill ring something in it, and
  the ~replace~ variable is true.

- When the ~kill-append~ function sets ~replace~ to be true and when
  the kill ring has at least one item in it, the ~setcar~ expression
  is executed:

  #+begin_src emacs-lisp
    (setcar kill-ring string)
  #+end_src

- The ~setcar~ function actually changes the first element of the
  ~kill-ring~ list to the value of ~string~.  It replace the first
  element.

- On the other hand, if the kill ring is empty, or replaces is false,
  the else-part of the condition is executed:

  #+begin_src emacs-lisp
    (push string kill-ring)
  #+end_src

- ~push~ puts its first argument onto the second.  It is similar to
  the older.

  #+begin_src emacs-lisp
    (setq kill-ring (cons string kill-ring))
  #+end_src

  or the newer

  #+begin_src emacs-lisp
(add-to-list kill-ring string)
  #+end_src

- When it is false, the expression first construct a new version of
  the kill ring by prepending ~string~ to the existing kill ring as a
  new element (that is what the ~push~ does).  Then it executes a
  second ~if~ clause.  This second ~if~ clause keeps the kill ring
  from growing too long.

- Let's look at these two expressions in order.

- The ~push~ line of the else-part sets the new value of the kill ring
  to what results from adding the string being killed to the old kill
  ring.

- We can see how this with an example

- first,
  #+begin_src emacs-lisp
    (setq example-list '("here is a clause" "another clause"))
  #+end_src

- After evaluating this expression with ~C-x C-e~, you can evaluate
  ~example-list~ and see what it returns:

  #+begin_src emacs-lisp
    example-list
        ⇒ ("here is a clause" "another clause")
  #+end_src

- Now, we can add a new element on to this list by evaluating the
  following expression:

  #+begin_src emacs-lisp
    (push "a third clause" example-list)
  #+end_src

- Thus, the third clause is added to the list by ~push~.

- Now for the second part of the ~if~ clause.  This expression keeps
  the kill ring from growing too long.  It looks like this:

  #+begin_src emacs-lisp
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
  #+end_src

- The code checks whether the length of the kill ring is greater than
  the maximum permitted length.  This is the value of ~kill-ring-max~
  (which is 60, by default).  If the length of the kill ring is too
  long, then this code sets the last element of the kill ring to
  ~nil~.  It does this by using two functions, ~nthcdr~ and ~setcdr~.

- We looked at ~setcdr~ earlier.  It sets the CDR of a list, just as
  ~setcar~sets the CAR of the list.  In this case, however, ~setcdr~
  will not be setting the CDR of the whole kill ring; the ~nthcdr~
  function is used to cause it to set the CDR of the next to last
  element of the kill ring--this means that since the CDR of the next
  to last element is the last element of the kill ring, it will set
  the last element of the kill ring.

- The ~nthcdr~ functions works by repeatedly taking the CDR of a
  list--it takes the CDR of the CDR of the CDR ... It does this /N/
  times and returns the results.  (see [[][nthcdr]].)

- Thus, if we had a four element list that was supposed to be three
  elements long, we could set the CDR of the net to last element to
  ~nil~, and thereby shorten the list.  (If you set the last element
  to some other value than ~nil~, which you could do, then you would
  not have shortened the list.  See [[][setcdr]].)

- You can see shortening by evaluating the following three expressions
  in turn.  First set the value of ~trees~ to ~(maple oak pine
  birch)~, then set the CDR of its second CDR to ~nil~ and then find
  the value of ~trees~:

  #+begin_src emacs-lisp
    (setq trees (list 'maple 'oak 'pine 'birch))
        ⇒ (maple oak pine birch)

    (setcdr (nthcdr 2 trees) nil)
        ⇒ nil

    trees
        ⇒ (maple oak pine)
  #+end_src

- (The value returned by the ~setcdr~ expression is ~nil~ since that
  is what the CDR is set to.)

- To repeat, in ~kill-new~, he ~nthcdr~ function takes the CDR a
  number times that is one less than the maximum permitted size of the
  kill ring and ~setcfr~ sets the CDR of that element (which will be
  the rest of the elements in the kill ring) to ~nil~.  This prevents
  the kill ring from growing too long.

- The next to last expression in the ~kill-new~ functions is:

  #+begin_src emacs-lisp
    (setq kill-ring-yank-pointer kill-ring)
  #+end_src

- The ~kill-ring-yank-pointer~ is a global variable that is set to be the ~kill-ring~.

- Even though the ~kill-ring-yank-pointer~ is called a '~pointer~', it
  is a variable just like the kill ring.  However, the name has been
  chosen to help humans understand how the variable is used.

- Now, to return to an early expression in the body of the function:

  #+begin_src emacs-lisp
    (id (fboundp 'menu-bar-update-yank-menu)
        (menu-bar-update-yank-menu string (and replace (car kill-ring))))
  #+end_src

- It start with an ~if~ expression

- In this case, the expression test first to see whether
  ~menu-bar-update-yank-menu~ exists as a function, and if so, calls
  it.  The ~fboundp~ function returns true if the symbol it is testing
  has a function definition that is not void.  If the symbol's
  function definition were void, we would receive an error message, as
  we did when we created errors intentionally (see [[][Generate an
  Error Message]]).

- The then-part contains an expression whose first element is the
  function ~and~.

- The ~and~ special form evaluates each of its arguments until one of
  the arguments returns a value of ~nil~, in which case the ~end~
  expression returns ~nil~; however, if none of the arguments returns
  a value of ~nil~, the value resulting from evaluating the last
  argument is returned.  (Since such a value is not ~nil~, it is
  considered true in Emacs Lisp.)  In other words, an ~and~ expression
  returns a true value only if all its arguments are true.  (See
  [[][Second Buffer Related Review]])

- The expression determines whether the second argument to
  ~menu-bar-update-yank-menu~ is true or not.

- ~menu-bar-update-yank-menu~ is one of the functions that make it
  possible to use the "Select and Paste" menu in the Edit item of a
  menu bar; using a mouse, you can look at the various pieces of text
  you have saved and select one piece to paste.

- The last expression in the ~kill-new~ function adds the newly copied
  string to whatever facility exists for copying and pasting among
  different programs running in a windowing system.  In the X
  Windowing system, for example, the ~x-select-text~ function takes
  the string ans stores it in memory operated by X.  You can paste the
  string in another program, such as an Xterm.

- The expression looks like this:

  #+begin_src emacs-lisp
    (if interprogram-cut-function
        (funcall interprogram-cut-function string (not replace))))
  #+end_src

- If an ~interprogram-cut-function~ exists, then Emacs executes
  ~funcall~, which in turns calls its first argument as a function and
  passes the remaining arguments to it.  (Incidentally, as far as I
  can see, this ~if~ expression could be replaced by ~and~ expression
  similar to the one in the first part of the function.)

- We are not going to discuss windowing systems and other program
  further, but merely note that this is a mechanism that enables GNU
  Emacs to work easily and well with other-programs.

- This code for placing text in the kill ring, either concatenated
  with an existing element or as a new element, leads us to the code
  for bringing back text that has been cut out of the buffer--the yank
  commands.  However, before discussing the yank command, i t is
  better to learn how lists are implemented in a computer.  This will
  make clear such mysteries as the use of the "pointer".  But before
  that, we will digress into C.

**  Digression into C

- The ~copy-region-as-kill~ function (see[[][copy-region-as-kill]])
  uses the ~filter-buffer-substring~ function, which in turn uses the
  ~delete-and-extract-region~ function.  It removes the contents of a
  region and you cannot get them back.

- Unlike the other code discussed here, the
  ~delete-and-extract-region~ function is not written in Emacs Lisp;
  it is written in C and is one of the primitives of the GNU Emacs
  system.  Since is very simple, I will digress briefly from Lisp and
  describe it here.

- Like many other code Emacs primitives, ~delete-and-extract-region~
  is written as an instance of a C macro, a macro being a template for
  code.  The complete macro looks like this:

  #+begin_src c
    DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
           Sdelete_and_extract_region, 2, 2, 0,
           doc: /* Delete the text between START and END and return it. */)
    (lisp_object start, lisp_Object end)
    {
        validate_region (&start, &end);
        if (XFIXNUM (start) == XFIXNUM (end))
            return empty_unibyte_string;
        return del_range_2 (XFIXNUM (start), XFIXNUM (end), 1, 1);
    }
  #+end_src

- Without going into the details of the macro writing process, let me
  point out that this macro starts with the word ~DEFUN~ was chosen
  since the code serves the same purpose as ~defun~ does in Lisp.
  (The ~DEFUN~ C macro is defined in ~emacs/src/lisp.h~.)

- The word ~DEFUN~ is followed by seven parts inside of parentheses:

    - The first part is the name given to the function in Lisp,
      ~delete-and-extract-region~.

    - The second part is the name of the function in C,
      ~Fdelete_and_extract_region~.  By convention, it start with
      '~F~'.  Since C does not use hyphens in names, underscores are
      used instead.

    - The third part is the name for the C constant structure that
      records information on this function for internal use.  It is
      the name of the function in C but begins with an '~s~' instead
      of an '~F~'.

    - The forth and fifth parts specify the minimum and maximum number
      of arguments the function can have.  This function demands
      exactly 2 arguments.

    - The sixth part is nearly like the argument that follows the
      ~interactive~ declaration in a function written in Lisp: a
      letter followed, perhaps, by a prompt.  The only difference from
      Lisp id when the macro is called with no arguments.  Then you
      write a ~0~ (which is a null string), as in this macro.

      If you were to specify arguments, you would place them between
      quotation marks.  The C macro for ~goto-char~ includes ~"NGoto
      char: "~ in this position to indicate that the function expects
      a raw prefix, in this case, a numerical location in a buffer,
      and provides a prompt.

   - The seventh part is a documentation string, just like the one for
     a function written in Emacs Lisp.  This is written as a C
     comment.  (When you build Emacs, the program
     ~lib-src/make-docfile~ extracts these comments and uses them to
     make the documentation.)

- In a C macro, the formal parameters come next, with a statement of
  what kind of object they are, followed by the body of the macro.
  For ~delete-and-extract-region~ the body consists of the following
  four lines:

  #+begin_src c
    validate_region (&start, &end);
    if (XFIXNUM (start) == XFIXNUM (end))
        return empty_unibyte_string;
    return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
  #+end_src

- The ~validate_region~ function checks whether the values passed as
  the beginning and end of the region are the proper type and are
  within a range.  If the beginning and end position are the same,
  then return empty string.

- The ~del_range_1~ function actually deletes the text.  It is a
  complex function we will look into.  It updates the buffer and does
  other things.  However, it is worth looking at the expert knowledge
  to understand, the two values are of type ~Lisp_object~, which might
  be a C pointer, a C integer, or a C ~struct~; C code ordinarily
  should not care how ~Lisp_object~ is implemented.

- ~Lisp_Object~ widths depend on the machine, and are typically 32 or
  64 bits.  A few of the bits are used to specify the type of
  information; the remaining buts are used as content.

- '~XFIXNUM~' is a C macro that extracts the relevant integer from the
  longer collection of bits; the type bits are discarded.

- The command in ~delete-and-extract-region~ looks like this:

  #+begin_src c
    del_range_1 (XFINUM (start), XFINUM (end), 1, 1);
  #+end_src

- It deletes the region between the beginning position, ~start~, and
  the ending position, ~end~.

- From the point of view of the person writing Lisp, Emacs is all very
  simple; but hidden underneath is a great deal of complexity to make
  it all work.

** Initializing a Variable with ~defvar~

- The ~copy-region-as-kill~ function is written in Emacs Lisp.  Two
  functions within, ~kill-append~ and ~kill-new~, copy a region in a
  buffer and save it in a variable called the ~kill-ring~.  This
  section describes how the ~kill-ring~ variable is created and
  initialized using the ~defvar~ special form.

- (again we note that the term ~kill-ring~ is misnomer.  The text that
  is clipped out of the buffer can be brought back; it is not a ring
  of corpses, but a ring of resurrectable text.)

- In Emacs Lisp, a variable such as the ~kill-ring~ is created and
  given an initial value by using the ~defvar~ special form.  The name
  comes from "define variable".

- The ~defvar~ special form is similar to ~setq~ in that sets the
  value of a variable.  It is unlike ~setq~ in two ways; first, it
  only sets the value of the variable if the variable does not already
  have a value.  If the variable already has a value, ~defvar~ does
  not override the existing value.  Second, ~defvar~ has a
  documentation string.

- (There is a related macro, ~defcustom~, designed for variables that
  people customize.  It has more features than ~defvar~.  (See
  [[][Setting Variables With ~defcustom~.)

  - [[Seeing the Current  Value of a Variable][See variable current value]]

  - [[~devfar~ and asterisk][defvar and asterisk]]

*** Seeing the Current  Value of a Variable

- You can see the current value of variable, by using the
  ~describe-variable~ function, which usually invoked by typing ~C-h
  v~.  If you type ~C-h v~ and then ~kill-ring~ (followed by ~RET~)
  when prompted, you will see what is in your current kill ring--this
  may be quite a lot! Conversely, if you have been doing nothing this
  Emacs session expect read this document, you may have nothing in it.
  Also you will see the documentation for ~kill-ring~:

  #+begin_src emacs-lisp
    Documentation:
    List of killed text sequences.
    Since the kill ring is supossed to interact nicely with cut-and-paste
    facilities offered by window systems, use of this variable should
    interact nicely with `interporgram-cut-function' and
    `interprogram-paste-function'.  The function `kill-new',
    `kill-append', and `current-kill' are supposed to implement this
    interaction; you may want to use them instead of manipulating the kill
    ring directly.
  #+end_src

- The kill ring is defined by a ~defvar~ in the following way:

  #+begin_src emacs-lisp
    (devfar kill-ring nill
     "list of killed trxt sequences.
    ...")
  #+end_src

- In this variable definition, the variable is given an initial value
  of ~nil~, which make sense, since if you have saved nothing, you
  want nothing back if oy give a ~yank~ command.  The documentation
  string is written just like the documentation string of a ~defun~.
  As with the documentation string of the ~defun~, the first line of
  the documentation should be a complete sentence, since some
  commands, like ~apropos~, print only the first line of
  documentation.  Succeeding lines should not be indented; otherwise
  they look odd when you use ~C-h v (describe-variable)~.

*** ~devfar~ and asterisk

- In the past, Emacs used the ~defvar~special form both for internal
  variables that you would not expect a user to change and for
  variables that you do expect a user to change.  Although you can
  still use ~devfar~ for user customizable variables, please use
  ~defcustom~ instead, since it provides a path into the Customization
  commands.  (See [[][Specifying Variables using ~defcustom~.)

- When you specified a variable using the ~defvar~ special form, you
  could distinguish a variable that a user might want to change form
  others by typing an asterisk '~*~', in the first column of its
  documentation string.  For example:

  #+begin_src emacs-lisp
    (defvar shell-command-default-error-buffer nill
      "*Buffer name for `shell-command' ... error output.
    ... ")
  #+end_src

- You could (and still can) use the ~set-variable~ command to change
  the value of ~shell-command-default-error-buffer~ temporarily.
  However, options set using ~set-variable~ are set only for the
  duration of your editing session.  The new values are not saved
  between sessions.  Each time Emacs start, it reads the original
  value, unless you change the value within your ~.emacs~ file, either
  by setting it manually or by using ~customize~.  See [[][Your .emacs
  File]].

- For me, the major use of the ~set-variable~ command is to suggest
  variables that I might want to set in my ~.emacs~ file.  There are
  now more than 700 such variables, for too many to remember readily.
  Fortunately, you can press ~TAB~ after calling ~M-x set-variable~
  command to see list of variables.  (See [[][Examining and Setting
  Variables]] in the GNU Emacs Manual.)

** Review

Here is a brief summary of some recently introduced functions.

- ~car~, ~cdr~

  ~car~ returns the first element of a list; ~cdr~ returns the second
  and subsequent element of a list.

  For example:

    #+begin_src emacs-lisp
      (car '(1 2 3 4 5 6 7))
           ⇒ 1
      (cdr '(1 2 3 4 5 6 7))
           ⇒ (2 3 4 5 6 7)
    #+end_src

- ~cons~

  ~cons~ construct a list by prepending its first argument to its second argument.

  For example:

    #+begin_src emacs-lisp
      (cons 1 '(2 3 4))
            ⇒ (1 2 3 4)
    #+end_src

- ~funcall~

  ~funcall~ evaluates its first arguments as a function.  It passes
  its remaining arguments to its first argument.

- ~nthcdr~

  Returns the result of taking CDR /n/ times on a list.  The "rest of
  the rest", as it were.

  For example:

    #+begin_src emacs-lisp
      (nthcdr 3 '(1 2 3 4 5 6 7))
            ⇒ (4 5 6 7)
    #+end_src

- ~setcar~, ~setcdr~

  ~setcar~ changes the first element of a list; ~setcdr~ changes the
  second and subsequent elements of a list.

  For example:

    #+begin_src emacs-lisp
      (setq triple (list 1 2 3))

      (setcar triple '37)

      triple
        ⇒ (37 2 3)

      (setcdr triple '("foo" "bar"))

      triple
        ⇒ (37 "foo" "bar")
    #+end_src

- ~progn~

  Evaluate each argument in sequence and then return the value of the last.

  For example:

    #+begin_src emacs-lisp
      (progn 1 2 3  4)
      ⇒ 4
    #+end_src

- ~save-restriction~

  Record whatever narrowing is in effect in the current buffer, if
  any, and restore that narrowing after evaluating the arguments.

- ~search-forward~

  Search for a string, and if the string is found, move point.  With a
  regular expression, use the similar ~re-search-forward~.  (See
  Regular Expression Searches, for an explanation of regular
  expression patterns and searches.)

  ~search-forward~ and ~re-search-forward~ take four argument:

  1. The string or regular expression to search for.

  2. Optionally, the limit of the search.

  3. Optionally, what to do if the search fails, return ~nil~ or an
     error message

  4. Optionally, how many times to repeat the search; if negative, the
     search goes back.


- ~kill-region~, ~delete-and-extract-region~, ~copy-region-as-kill~

  ~kill-region~ cuts the text between point and mark from the buffer
  and stores that text in the kill ring, so you can get it back by
  yanking.

  ~copy-region-as-kill~ copies the text between point and mark into
  the kill ring, from which you can get it by yanking.  The function
  does not cut or remove the text from the buffer.

  ~delete-and-extract-region~ removes the text between point and mark
  from the buffer and throws it away.  You cannot get it back. (This
  is not interactive command.)


* How Lists are Implemented.

- In Lisp, atoms are recorded in a straightforward fashion; if the
  implementation is not straightforward in practice, it is,
  nonetheless, straightforward in theory.  The atom '~rose~', for
  example, is recorded as the four contiguous letters, '~r~', '~o~',
  '~s~'. '~e~'.  A list, on the other hand, is kept differently.  The
  mechanism is equally simple, but it takes a moment to get used to
  the idea.  A list is kept using a series of pairs of pointers.  In
  the series, the first pointer in each pair points to an atom or to
  another list, and the second pointer in each pairs points to the
  next pair, or to the symbol ~nil~, which marks the end of the list.

- A pointer itself is quite simply the electronic address of what is
  pointed to.  Hence, a list is kept as a series of electronic
  addresses.

    - [[List diagrammed][Lists diagrammed]]

    - [[][Symbol as Chest]]             Exploring a powerful metaphor

** List diagrammed

- For example, the list ~(rose violet buttercup)~ has three elements,
  '~rose~', '~violet~', '~buttercup~'.  In the computer, the
  electronic address of '~rose~' is recorded in a segment of computer
  memory along with the address that gives the electronic address of
  where the atom '~violet~' is located; and that address (the one that
  tells where '~violet~' is located) is kept along with an address
  that tells where the address for the atom '~buttercup~' is located.


- This sound more complicated than it is and is easier seen in a diagram:

  #+begin_src emacs-lisp
     --- ---       --- ---      --- ---
    |   |   | --> |   |   | -->|   |   | --> nil
     --- ---       --- ---      --- ---
      |             |            |
      |             |            |
      --> rose      --> voilet   --> buttercup
  #+end_src

- In the diagram, each box represents a word of computer memory that
  holds a Lisp object, usually in the form of a memory address.  The
  boxes, i.e., the addresses, are in pairs.  Each arrow point to what
  the address is the address of, either an atom or another pair of
  addresses.  The first box is the electronic address of '~rose~' and
  the arrow points to '~rose~', the second box is the address of the
  next pair of boxes, the first part of which is the address of
  '~violet~' and the second part of which is the address of the next
  pair.  The very last box points to the symbol ~nil~, which marks the
  end of the list.

- When the variable is set to a list with an operation such as ~setq~,
  it stores the address of the first box in the variable.  Thus
  evaluation of the expression.

  #+begin_src emacs-lisp
    (setq bouquet '(rose violet buttercup))
  #+end_src

- creates a situation like this:

  #+begin_src emacs-lisp
    bouquet
         |
         |    --- ---        --- ---        --- ---
         --> |   |   | -->  |   |   | -->  |   |   | --> nil
              --- ---        --- ---        --- ---
               |              |              |
               |              |              |
               --> rose       --> violet     --> buttercup
  #+end_src

- In the same example, the symbol ~bouquet~ holds the address of the
  first pair of boxes.

- the same list can be illustrated in a different sort of box notation
  like this:

  #+begin_src emacs-lisp
    boquet
       |
       |     ----------------      -----------------       ----------------
       |    | car    |  cdr  |    | car     |  cdr  |     | car     | cdr  |
       -->  | rose   |   o------->| violet  |   o-------> | butter- |      |
            |        |       |    |         |       |     | cup     |      |
             ----------------      -----------------       ----------------
  #+end_src

- (Symbol consist of more than pairs of addresses, but the structure
  of a symbol is made up of addresses.  Indeed, he symbol ~bouquet~
  consist of a group of address-boxes, one of which is the address of
  the printed word '~bouquet~'. a second of which is the address of a
  function definition attach to the symbol, if any, a third of which
  is the address of the first pair of address-boxes for the list
  ~(rose violet buttercup)~, and so on.

- If a symbol is set to CDR of a list, the list itself is not changed;
  the symbol simply has an address further down the list.  (In the
  jargon, CAR and CDR are "non-destructive".) Thus, evaluation of the
  following expression.

  #+begin_src emacs-lisp
    (setq flowers (cdr boquet))
  #+end_src

 - produces this:

  #+begin_src emacs-lisp
    bouquet      flowers
      |             |
      |    --- ---  |     --- ---      --- ---
      --> |   |   |  --> |   |   |    |   |   |
          |   |   |----> |   |   |--> |   |   | --> nil
           --- ---        --- ---      --- ---
            |              |            |
            |              |            |
            --> rose       --> violet   --> buttercup
  #+end_src

- The value of ~flowers~ is ~(violet buttercup)~, which is to say, the
  symbol ~flowers~ holds of the pair of address-boxes, the first of
  which holds the address of ~violet~, and the second of which holds
  the address of ~buttercup~.

- A pair of address-boxes is called a /cons cell/ or /dotted pair/.
  See [[][Cons Cell and List Types]] in The GNU Emacs Lisp Reference
  Manual, and [[][Dotted Pair Notation]] in The GNU Emacs Lisp
  Reference Manual, for more information about cons cells and dotted
  pairs.

- The function ~cons~ adds a new pair of addresses to the front of a
  series of addresses like that shown above.  For example, evaluating
  the expression

  #+begin_src emacs-lisp
    (setq boquet (cons 'lily bouquet))
  #+end_src

- produces

  #+begin_src
    bouquet                        flowers
      |                             |
      |    --- ---        --- ---   |     --- ---      --- ---
      --> |   |   |      |   |   |   --> |   |   |    |   |   |
          |   |   |--->  |   |   |-----> |   |   |--> |   |   | --> nil
           --- ---        --- ---         --- ---      --- ---
            |              |               |            |
            |              |               |            |
            --> lily       --> rose         --> violet   --> buttercup

  #+end_src

- However, this does not changed the value of the symbol ~flowers~, as
  you can see by evaluating the following,

  #+begin_src emacs-lisp
    (eq (cdr (cdr bouquet)) flowers)
  #+end_src

  which returns ~t~ for true.

- Until it reset, ~flowers~ still has the value ~(violet buttercup)~;
  that is, it has the address of the cons cell whose first address is
  of ~violet~.  Also, this does not alter any of pre-existing cons
  cells; they are all still the same.


- Thus, in Lisp, to get the CDR of a list, you just get the address of
  the next cons cell in the series; to get the CAR of a list, you get
  the address of the first element of the list; to ~cons~ a new
  element on a list, you add a new cons cell to the front of the list.
  That is all there is to it!  The underlying structure of Lisp is
  brilliantly simple!.

- And what does the last address in a series of cons cell refer to? It
  is the address of the empty list, of ~nil~.

- In summary, when a Lisp variable is set to a value, it is provided
  with the address of the list to which the variable refers.

** Symbols as a Chest of Drawers

- In an earlier section, I suggested that you might imagine a symbol
  as being a chest of drawers.  The function definition is put in one
  drawer, the value in another, and so on.  What is put in the drawer
  holding the value can be changed without affecting the contents of
  the drawer holding the function definition, and vice versa.

- Actually, what is put in each drawer is the address of the value of
  function definition.  It is as if you found an old chest in the
  attic, and in one of its drawers you found a map giving you
  directions to where the buried the treasure lies.

- (In addition to its name, symbol definition, and variable value, a
  symbol has a drawer for a /property list/ which can be used to
  record other information. Property lists are not discussed here; see
  [[][Property list]] in The GNU Emacs Lisp Reference Manual.)

- Here is a fanciful representation:

  #+begin_src emacs-lisp
           Chest of Drawers           Content of Drawers

       --     oOoOoO      --
      /                     \
     -------------------------
    |     directions to       |            [map to]
    |      symbol name        |             bouquet
    |                         |
    +-------------------------+
    |     directions to       |
    |   symbol definition     |            [none]
    |                         |
    +-------------------------+
    |     directions to       |            [map to]
    |     variable value      |            [rose violet buttercup]
    |                         |
    +-------------------------+
    |     directions to       |
    |     property values     |            [not described]
    |                         |
    +-------------------------+
    |/                       \|

  #+end_src
