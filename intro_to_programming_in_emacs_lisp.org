#+TITLE: Summary from An Introduction to Programming in Emacs Lisp by Robert J Chassel
#+AUTHOR: Agung Tuanany
#+EMAIL: agung.tuanany@gmail.com
#+SUBJECT: Emacs, Elisp
#+KEYWORDS: Emacs, Elisp
#+PROPERTY: header-args:emacs-lisp :tangle ./intro_to_programming_in_emacs_lisp-02.el :mkdirp yes
#+OPTIONS: toc:t
#+STARTUP: content indent
#+MACRO: export-date (eval (format-time-string "%F %R %z" (current-time)))
#+MACRO: count-words (eval (count-words (point-min) (point-max)))

#+LATEX_CLASS: org-plain-latex
#+LATEX_CLASS_OPTIONS: [letterpaper]
#+SETUPFILE: ./latex-standard-export.org

#+begin_comment
#+LATEX_CLASS: article

#+SETUPFILE: ~/.emacs.d/modules/prelude-latex.el
#+LATEX_HEADER: \input{latex-standard-setup.tex}
;;;
#+LATEX_HEADER: \input{jake-latex-standard.setup}
#+end_comment

#+STARTUP: latexpreview

+ Created: 2022-02-19
+ Updated: *{{{export-date}}}*.
+ Word count: *{{{count-words}}}* (not a measure of quality, just to offer an
  idea on what to expect)
+ Git repository (part of my dotfiles for GNU/Linux):
  <https://github.com/agungTuanany/intro_to_programming_in_elips.git>

* List Processing

- To the untutored eye, Lisp is a strange programming language.  In
  Lisp code there are /parentheses everywhere/.  Some people even
  claim that the name stand for "Lots of Isolated Silly Parentheses".
  But the claim is unwarratend.

- Lisp stand for Lost processing, and the programming language handle
  /list/ (and list of list) by putting them between parentheses.  The
  parentheses mark the boundaries of the list.  Sometimes a list is
  preceded by an apostrophe '~'~', called a /single-quote/ in Lisp.

- Lists are the basic of lisps.

  - [[Lisp List & Atom][Lisp Lists]]                                            What are lists?

  - [[Lisp List & Atom][Run A program]]                                         Any list in Lisp is a program ready to run

  - [[Run A program][Making Errors]]                                            Generating an error message

  - [[Symbol Names and Function Definition][Names & Definitions]]               Names of symbol and function definitions

  e [[The Lisp Interpreter][Lisp Interpreter]]                                  What the Lisp interpreter does

  - [[Evaluation][Evaluation]]                                                  Running a program

  - [[Variables][Variables]]                                                    Returning a value from a variable

  - [[Arguments][Arguments]]                                                    Passing information to a function

  - [[Setting the Value of a Variable][set & setq]]                             Setting the value of a variable

  - [[Summary][Summary]]                                                        The major points

** Lisp List & Atom
*** Vocabularies:

- <<<apostrophe>>> : a punctuation mark (') used to indicated either
  possession.

- <<<indivisible>>> : unable to be divided or separated.

- <<<fission>>> : the action of dividing or splitting something into
  two or more parts.

- <<<sloth>>> : laziness; reluctant to work an effort.

- <<<precedes>>> : come before (something) in time.

- <<<deciphering>>> : convert (a text written in code, or coded signal)
  into normal language; decode, translate

- <<<ceases>>> :bring or come to end

- <<<esoteric>>> : intended for or likely to be understood by only a
  small of people with specialized knowledge or interest.

- <<<digression>>> : a temporary departure from which the main subject
  in speech or writing; synonyms: apostrophe, divagation.

- <<<deferment>>> : the action or fact of putting something off to a
  later time; postpone.

- <<<reconnoiter>>> : make a military observation of (a region);
  synonyms: lurk, scout, look.

*** Notes

- A list in Lisp consist of parentheses surrounding atoms separated by
  whitespace or surrounding other lists or surrounding both atoms and
  other lists.

- An empty list is considered both an atom and a list at the same
  time.

- The printed representation of atoms and list are called /symbolic
  expressions/ or more concisely */s-expressions/*.

- In Lisp, certain kind of atom, such an /array/, can be separated
  into parts; but the mechanism for doing this is different from the
  mechanism for splitting a list.

- As far as a list operation are concerned, the atoms of list are
  unsplittable.

- In Lisp, all of the quoted text including the punctuation mark and
  the blanks spaces is a single atom.  This kind of atom is called a
  /string/ (for "string characters").  Strings are different kind of
  atom than numbers or symbols and are used differently.

- A command to properly indent the code in a region is customarily
  bound to /"M-c\"/.

*** Example

- ex-1:

  #+begin_src emacs-lisp
    ;; try to comment out
    (message '(rose
               violet
               daisy
               buttercup))
  #+end_src

- ex-2:

  #+begin_src emacs-lisp
    '(this list
           looks like this)
  #+end_src

Above list is same as this:

- ex-3:

  #+begin_src emacs-lisp
    '(this list looks like this)
  #+end_src

** Run A program

- A list in Lisp--any list-- is a program ready to run.

- If you run it (for which the Lisp jargon is */evaluate/*), the
  computer will do one of three things:

  - Do nothing except return you the list itself,

  - send you an error message,

  - treat the first symbols in the list as a command to do
    something. (the last of these three things that you really want
    Lisp to expect).

- The single apostrophe, /( ' )/, that put in front of some of the
  example lists in preceding section is called a */quote/*; when it
  precedes a list, it tells Lisp to do nothing with the list, other
  than take it as it is written.  But if there is */no quote/*
  preceding a list, the first item of the list is special: it is a
  command for the computer to obey.

** Generate an Error Message

    #+CAPTION: Error Example
    #+begin_src emacs-lisp
        * ---------- Buffer: *Backtrace* ----------
        Debugger entered--Lisp error: (void-function this)
        (this is an unquoted list)
        eval((this is an unquoted list) nil)
        elisp--eval-last-sexp(nil)
        eval-last-sexp(nil)
        funcall-interactively(eval-last-sexp nil)
        call-interactively(eval-last-sexp nil nil)
        command-execute(eval-last-sexp)
        * ---------- Buffer: *Backtrace* ----------
    #+end_src

- We often try o generate error message intentionally.

- We have a jargon, /error message can be informative/.  Instead being
  called /"error"/ messages, they should be called /"help"/ messages.

- deciphering an error mesasge can be hard, but once understood, they
  can be point the way.

- You read the */=*Backtrace*=/* buffer from the *bottom--up*; it
  tells you what Emacs did.
- When you type /C-x C-e/, you made an interactive call to the command
  /eval-last-sexp/.

- /eval/ is an abbrevation for /"evaluate"/ and /sexp/ is an
  abbrevation for /"symbolic expression"/.  The command means
  /"evaluate last symbolic expression"/, which is the expression just
  before your cursor.

- At the top of the =*Backtrace*= buffer, you see the line:

  #+begin_src emacs-lisp
    *Debugger entered--Lisp error: (void-function this)*
  #+end_src

- The Lisp interpreter tried to evaluate the first atom of the list,
  the word 'this'. It is this action that generated the error message
  'void-function this'.

- The word /'function'/ was mentioned before. It was a very important
  word. For our purposes, we an define it by saying that a /function
  is a set of instructions to the computer that tell the computer to
  do something/.

- Now we can begin to understand the error message: 'void-function
  this'. The function (that is, the word 'this') does not have a
  definition of any set of instructions for the computer to carry out.

- The slightly odd word, *'void-function'*, is designed to cover the
  way Emacs Lisp is implemented, which is that when a symbol does not
  have a function definition attached to it, the place that should
  contain the instruction is void.

- It is possible to prevent Emacs entering the debugger in cases like
  above. We do not explain how to do that here, but we will mention
  what the result looks like, because you may encounter a similar
  situation if there is a bug in some Emacs code that you are using.

- In such cases, you will see only one line of error message; it will
  appear in the echo area and look like this:

  #+begin_src emacs-lisp
    Symbol's function definition is void: this
  #+end_src

- The message goes away as soon as you type a key, even just to move
  the cursor.

- We know the meaning of the word 'Symbols'. It refers to the first
  atom of the list, the word 'this'.  The word 'function' refers to
  the instructions that tell the computer what to do. (Technically,
  the symbol tell the computer where to find the instructions, but
  this is a complication we can ignore at the moment.).

- The error message can be understood: 'Symbol's function definition
  is void: this'.  The symbol (that is, the word 'this') lacks
  instructions for the computer to carry out.

** Symbol Names and Function Definition

- In Lisp, one set of instructions can be attached to several
  names. For examples, the computer instructions for adding numbers
  can be linked to the symbol plus as well as the symbol =+= (and are
  in some dialects of Lisp).

- On other hand, a symbol can have only one function attached to it at
  a time. Otherwise, the computer would be confused as to which
  definition to use.

- However, the /function definition/ to which the name refers can be
  *changed* readily.

- Since Emacs Lisp is large, it is customary to name symbols in a way
  that identifies the part of Emacs to which the function belongs.

- Thus all the names for function that deal with /Textinfo/ start with
  /'textinfo-'/, and those for function to deal with /reading mail/
  start with /'mail'/.

** The Lisp Interpreter

- Based on what we have seen, we can now start to figure out what Lisp
  interpreter does when we command it to evaluate a list.

- First, it looks to see whether there is *a quote* before the list;
  /if there is/, the interpreter looks at the first element in the
  list the interpreter just gives us the list.

- Second, if there is *no qoute*, the interpreter looks at the first
  element in the list and sees whether it has a /function
  definition/. If it does, the interpreter carries out the instruction
  in the function definition. Otherwise, the interpreter print an
  error message.

  - [[Complications][Complications]]    Variables, Special forms, list within.

  - [[Byte Compiling][Byte Compiling]]  Special processing code for speed.

*** Complications

- For the *first* - complication, in addition to list, the Lisp
  interpreter can evaluate a symbol that is not quoted and does not
  have parentheses around it.  The Lisp interpreter will attempt to
  determine a symbol's value as */variable/*.  This situation is
  described in the section (see section "Variables")

- the *second* - complication occurs because some functions are
  unusual and do not work in the usual manner.  Those that don't are
  called */special forms/*.  They are used for special jobs, like
  defining a function, and there are not many of them.

- As well as special forms, there are also /"macros"/. A /macro/ is
  construct defined in Lisp, which differs from a function in that it
  translates a Lisp expression into another expression that is to be
  evaluated in place of the original expression (see section "Lisp
  Macro").

- For the purpose of this introduction, you do not need to worry too
  much about whether something is a /special form/, /macro/, or
  /ordinary function/.

- For example, /=if=/ is a special form, but /=when=/ is a macro. In
  earlier versions of Emacs, /=defun=/ was a special form, but it is a
  macro.  It still behave the same way.

- The *final* complication is, if the function that the Lisp
  interpreter is looking at is *not* a special form, and if it is part
  of a list, the Lisp interpreter looks to see whether the list has a
  list inside of it.  If there is an inner list, the Lisp interpreter
  first figures out what it should do with the inside list, and then
  it works on the outside list.  If there is yet another list embedded
  inside inner list, it works that one first, and so on.

- The interpreter works on the innermost list first, to evaluate the
  result of that list.  The result may be used by the enclosing
  expression.

- Otherwise, the interpreter works */left to right/*, from one
  expression to the next.

*** Byte Compiling

- One other aspect of interpreting: the Lisp interpreter is able to
  interpret two kind of entity: /humanly readable code/, which we will
  focus exclusively, and special processed code, called /byte
  compiled/ code, which is not human readable.  Byte compiled code
  runs faster than humanly readable code.

- You can transform humanly readable code into byte compiled code by
  running one of the compile commands such as *=byte-compile-file=*.
  Byte compiled code is usually in a file that ends with a /=.ec=/
  extension rather than a /=.el=/ extension.

- As practical matter, for most thing you might do to customize or
  extend Emacs, you do not need to byte compile; and I will not
  discuss the topic here. See Section "Byte Compilation" in the /GNU
  Emacs Lisp Reference Manual/, for full description of byte
  compilation.

** Evaluation

- When the Lisp interpreter works on an expression, the term for the
  activity is called */=evaluation=/*.  We say that the interpreter
  "evaluates the expression".  The word comes from its use in everyday
  language, "to ascertain the value or amount of; to appraise",
  according to /Webster's New Collegiate Dictionary/.

  - [[How Interpreter acts][How Interpreter acts]]       Returns and Side Effects

  - [[Evaluating Inner Lists][Evaluating Inner Lists]]   List within lists

*** How Interpreter acts

- After evaluating an expression, the Lisp interpreter will most
  likely return the value that the computer produces by carrying out
  the instructions it found in the /function definition/, or perhaps
  it will give up on that function and produce error message.  Most
  frequently, the interpreter returns a value.

- At the same time the interpreter returns a value, it may do
  something else as well, such as move a cursor or copy a file; this
  other kind of action is called a */side effect/*.  Actions that we
  humans think are important, such as /printing results/, are often
  side effects to the Lisp interpreter.  It fairly easy to learn to
  use side effect.

- In summary, evaluating a symbolic expression most commonly causes
  the Lisp interpreter to return a value and perhaps carry out a side
  effect; or else produce an error.

*** Evaluating Inner Lists

- If evaluation applies to a list that is inside another list, the
  outer list may use the value returned by evaluation as information
  when the outer list is evaluated.  This explains why inner
  expression evaluated first: the values they returns are *used* by
  the outer expressions.

** Variables

- In Emacs Lisp, a symbol can have a /value/ attached to it just as it
  can have a /function definition/ attached to it.  *The two are
  different*.

- The /function definition/ is a set of instruction that a computer will
  obey.

- A /value/, on the other hand, is something, such a number or a name,
  that can vary (which is why such a symbol is called a variable).
  The value of symbol can be any expression in Lisp, such as a symbol,
  number, list, or string.

- A symbol that has a value is often called /variable/.

- A symbol can have both a function definition and a value attached to
  it at the same time. Or it can have just one or the other.  The two
  are separate.

- Another way to think about this is to imagine a symbol as being a
  /chest of drawers/.  The function definition is in one drawer, the
  value in another, and so on.  What is put in the drawer holding the
  value can be changed without affecting the contents of the drawer
  holding the function definition, and vise versa.

*** ~fill-column~ an Example Variable

- The variable /=fill-column=/ illustrate a symbol with a value
  attached to it: in every GNU Emacs buffer, this symbol is set to
  some value.  To find out the value of this symbol, evaluate it by
  itself.

  #+begin_src emacs-lisp
    fill-column     ;; type (C-x C-e) to evaluate the value
  #+end_src

- Notice that the value returned as a variable is printed in exactly
  the same way returned by a function carrying out its instruction.

- From the point of view of the Lisp interpreter, /a value returned is
  a value returned/.  What kind of expression it came from ceases to
  matter once the value is known.

- A symbol can have any value attached to it or, to use the jargon, we
  can *bind the variable to a value*: to a /number/, such as =72=; to
  a /string/, *"=such as this="*; to a /list/, such as *=(spruce pine
  oak)=*; we can bind a variable to a /function definition/.

- A symbol can be bound to a value in several ways, See "Setting the
  Value of a Variable".

*** Error Message for a Symbol Without a Function

- When we evaluated *=fill-column=* to find its value as a variable,
  we did not place parentheses around the word.  This is because we
  did not intend to use it as a /function-name/.

- If *=fill-column=* were the first or only element of a list, the
  Lisp interpreter would attempt to find the function definition
  attached to it. But =fill-column= has no function definition.

  #+begin_src emacs-lisp
    (fill-column)     ;; type (C-x C-e) to evaluate the value
  #+end_src

- You will create a *=*Backtrace*=* buffer that says:

  #+begin_src emacs-lisp
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function fill-column)
       (fill-column)
       eval((fill-column) nil)
       elisp--eval-last-sexp(nil)
       eval-last-sexp(nil)
       funcall-interactively(eval-last-sexp nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
  #+end_src

*** Error Message for a Symbol without value

- If you attempt to evaluate a symbol that does not have a value bound
  to it, you will receive an error message. You can see this by
  experimenting with 2 plus 2 addition.  In the following expression,
  put your cursor right after the =+=, before first number 2, type /C-x C-e/:

  #+begin_src emacs-lisp
    (+ 2 2)     ;; type (C-x C-e) to evaluate the value
  #+end_src

- You will create a *=*Backtrace*=* buffer that says:

  #+begin_src emacs-lisp
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-variable +)
       eval(+ nil)
       elisp--eval-last-sexp(nil)
       eval-last-sexp(nil)
       funcall-interactively(eval-last-sexp nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
  #+end_src

- This backtrace is different from the very first error message we
  saw, which said '~Debugger entered--Lisp error: (void-function
  this)~'.  In this case, the function does not have a value as a
  variable; while in the other error message, the function (the word
  'this') did not have a definition.

  In this experiment with the =+=, what we did was cause the Lisp
  interpreter to evaluate the =+= and look for the value right after
  the symbol rather than after the parenthesis of the enclosing list
  as we did before.  As a consequence, the Lisp interpreter evaluated
  the preceding /s-expression/ (symbol-expression), which in this case
  was =+= by itself.

  Since =+= does not have a value bound to it, just the function
  definition, the error message reported that the symbol's value as a
  variable was void.

** Arguments

- To see how information is passed to functions, let's look again at
  our old standby, the addition of two plus two.  In Lisp, this is
  written as follows:

  #+begin_src emacs-lisp
    (+ 2 2)
  #+end_src

- If you evaluate this expression, the number 4 will appear in your
  echo area.  What the Lisp interpreter does is add the numbers that
  follow the ~+~.

- The numbers added by ~+~ are called the /arguments/ of the function
  ~+~.  These numbers are the information that is given to or /passed/
  to the function.
  follows the ~+~.

- The word "argument" comes from the way it used in mathematics and
  *does not* refer to a disputation between two people; instead it
  refers to the information presented to the function, in this case,
  to the ~+~.

- In Lisp, the arguments to a function are the atoms or lists that
  follow the function.  The values returned by the evaluation of these
  atoms or lists are passed to the function.

- Different function require different numbers of arguments; some
  function require none at all.

  - [[Argument's Data Types][Data Types]]                                            Types of data passed to a function

  - [[An Argument as the Value of a Variable or List][Args as Variable or List]]     An arguments can be the value of variable or list

  - [[Variable Number of Arguments][Variable Number of Arguments]]                   Some functions may take a variable number of arguments

  - [[Using the Wrong Type Object as an Argument][Wrong Type of Argument]]           Passing an argument of the wrong type to a function

  - [[The ~message~ Function][message]]                                              A useful function for sending message

  - [[Argument's Data Types][Argument's Data Types]]                                 Types data passed to a function

*** Argument's Data Types

- The type of data that should be passed to a function depends in what
  kind of information it uses.  The arguments to a function such as
  ~+~ must have values that are numbers, since ~+~ adds numbers.
  Other function use different kinds of data for their arguments.

- For example, the ~concat~ function links together or unites two or
  more strings of text to produce a string.  The arguments are
  strings.  Concatenating the two character string ~abc~, ~def~
  produces the single string ~abcdef~.  This can be evaluating the
  following:

  #+begin_src emacs-lisp
    (concat "abc" "def")
  #+end_src

  The value produced by evaluating this expression is ~"abcdef"~.

- A function such as ~substring~ uses both a string and numbers as
  arguments.  The function returns as part of the string, a
  /substring/ of the first argument.  This function /takes three
  arguments/.  Its first arguments is the string of characters, the
  second and third arguments are numbers that indicate the beginning
  (inclusive) and end (exclusive) of the substring.  The numbers are a
  count of the number of characters (including spaces and punctuation)
  from the beginning of the string.

- Note that the characters in a string are numbered from zero, not one.

- For example, if you evaluate the following:

  #+begin_src emacs-lisp
(substring "The quick brown fox jumped." 16 19)
  #+end_src

  you will see ~"fox"~ in the echo area.  The arguments are the string
  and the two numbers.

- Note that the string passed to ~subtring~ is a single atom even
  though it is made up of several words separated by spaces.  Lisp
  counts everything between the two quotation marks as a part of the
  string, including the spaces.

- You can think of the ~substring~ function as a kind of atom smasher
  since it takes an otherwise indivisible atoms and extract a part.
  However, ~substring~ is only able to extract a substring from an
  argument that is a string, not from another type of atom such a
  number or symbol.

*** An Argument as the Value of a Variable or List

- An arguments can be a symbol that returns a value when it is
  evaluated.  For example, when the symbol ~fill-column~ by itself is
  evaluated, it returns a number.  This number can be used in an
  addition.

  #+begin_src emacs-lisp
    fill-column         ; Default value is 70

    (+ 2 fill-column)   ; The value become 72

  #+end_src

  The value will be a number two more than what you get by evaluating
  ~fill-column~ alone. For me, this is 72, because my value of
  ~fill-column~ is 72.

- as we have just seen, an arguments can be a symbol that returns a
  value when evaluated.  In addition, an argument can be a list that
  returns a value when it is evaluated. For example, on the following
  expression, the arguments to the function ~concat~ are the strings
  ~"The "~ and ~" red foxes."~ and the list ~(number-to-string (+ 2
  fill-column))~.

  #+begin_src emacs-lisp
    (concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
  #+end_src

- If you evaluate this expression--and if, as with Emacs,
  ~fill-column~ evaluates to *70--*~"The 72 red foxes."~ will appear
  in the echo area.

- Note that you must put spaces after the word ~"The"~ and before
  the word ~'red'~ so they will appear in the final string.

- The function ~number-to-string~ converts the integer that the
  addition function returns to a string.

- ~number-to-string~ is also known as ~int-to-string~.

*** Variable Number of Arguments

- Some functions, such as ~concat~, ~+~, or ~*~, take any number of
  arguments. This can be seen by evaluating each of the following
  expressions in the usual way.  What you will see in the echo area is
  printed in this text after '~=~', which you may read as /"evaluates
  to"/.

- In the first set, the function have no argument:

  #+begin_src emacs-lisp
    (+)       ⇒ 0
    (*)       ⇒ 1
  #+end_src

- In this set, the function have one argument each:

  #+begin_src emacs-lisp
    (+ 3)       ⇒ 3
    (* 3)       ⇒ 3
  #+end_src

- In this set, the function have three arguments each:

  #+begin_src emacs-lisp
    (+ 3 4 5)       ⇒ 12
    (* 3 4 5)       ⇒ 60
  #+end_src

*** Using the Wrong Type Object as an Argument

- When a function is passed an argument of the wrong type, the Lisp
  interpreter produces an error message.  For example, the ~+~
  function expects the values of its arguments to be numbers.  As an
  experiment we can pass it the quoted symbol ~hello~ instead of a
  number.

  #+begin_src emacs-lisp
    (+ 2 'hello)
  #+end_src

- When you do this you will generate an error message.  What has
  happened is that ~+~ has tried to add the 2 to the value returned by
  ~'hello~, but the value returned by ~'hello~ is the symbol ~hello~,
  not a number.  Only number can be added.  So ~+~ could not carry out
  its addition.

  #+caption: Error Example
  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
    Debugger entered--Lisp error:
    (wrong-type-argument number-or-marker-p hello)
    +(2 hello)
    eval((+ 2 'hello) nil)
    elisp--eval-last-sexp(t)
    eval-last-sexp(nil)
    funcall-interactively(eval-print-last-sexp nil)
    call-interactively(eval-print-last-sexp nil nil)
    command-execute(eval-print-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
 #+end_src

- As usual, the error message tries to be helpful and makes sense
  after you learn how to read it. (~quote-hello)~ is an expansion of
  the abbreviation ~'hello~.

- The first part of the error message is straightforward; it says
  '~wrong-type-argument~'.  Next comes the mysterious jargon word
  '~number-marker-p~'.  This word is trying to tell you what kind of
  argument the ~+~ expected.

- The symbol ~number-or-maker-p~ says that the Lisp interpreter is
  trying to determine whether the information presented (the value of
  the argument) is a number or a marker (a special object representing
  a buffer position).  What it does is test to see whether the ~+~ is
  being given numbers to add.  It also tests to see whether the
  argument is something called a marker, which is a specific feature
  in Emacs Lisp.  In Emacs Lisp, ~+~ can be used to add the numeric
  value of marker position as numbers.

- The ~'p~ of ~number-or-maker-p~ is the embodiment of a practice
  started in the early days of Lisp programming.  The ~p~ stands for
  "*predicate*".

  In the jargon used by the early Lisp researchers a predicate refers
  to a function to determine whether some property is true or false.

  So the '~p~' tells us that ~number-or-marker-p~ is the name of a
  function that determines whether it is true or false that the
  argument supplied is a number or a marker.

  Other Lisp symbol that end in '~p~' include ~zerop~, a function test
  whether its argument has the value of zero; and ~listp~, a function
  that tests whether its argument is a list.

*** The ~message~ Function

- Like ~+~, the ~message~ function takes a variable numbers of
  arguments.  It used to send messages to the user and is so useful
  that we will describe it here.

- A message is printed in the echo area.  For example, you can print a
  message in your echo area by evaluating the following list:

  #+begin_src emacs-lisp
    (message "This message appears in the echo area!")
  #+end_src

- The whole string between double quotation marks is a /single
  argument/ and is printed in /toto/.

- Note that in this example, the message itself will appear in the
  echo area within double quotes; that is because you see the value
  returned by the ~message~ function.  In most uses of ~message~ in
  program that you write, the text will be printed in the echo area as
  a side-effect, without quotes.  See ~multiply-by-seven~ in detail,
  for an example of this.

- However, if there is a '~%s~' in the quoted string of characters,
  the ~message~ function does not print the '~%s~' as such, but looks
  to the argument that follows the string.  It evaluates the second
  argument and prints the value at the location in the string where
  the '~%s~ is.

  #+begin_src emacs-lisp
    (message "The name of this buffer is: %s." (buffer-name))
  #+end_src

- In info, ~"The name of this buffer is: *info*."~ will appear in the
  echo area.  The function ~buffer-name~ returns the name of the
  buffer as a string, which the ~message~ function insert in place of
  ~%s~.

- To print a value as an integer, use '~%d~' in the same way as
  '~%s~'.  For example, to print a message in the echo area that
  states the value of the ~fill-column~, evaluate the following:

  #+begin_src emacs-lisp
    (message "The value of fill-column is %d." fill-column)
  #+end_src

- On my system, when I evaluate this list, ~"The value of fill-column
  is 70."~ appears in my echo area. (actually, you can use ~%s~ to
  print a number.  It is non-specific.  ~%d~ prints only the pat of a
  number left of a decimal point, and not anything that is not a
  number.)

- If there is more than one '~%s~' in the quoted string, the value of
  the first argument following the quoted string is printed at the
  location of the first '~%s~' and the value of the second argument is
  printed at the location of the second '~%s~', and so on.

  #+begin_src emacs-lisp
    (message "Tere are %d %s in the office!"
         (- fill-column 14) "pink elephants")
  #+end_src

  a rather whimsical message will appear in your echo area.  On my
  system it says, ~"there are 56 pink elephants in the office!"~.

- The expression ~(- fill-column 14)~ is evaluated and the resulting
  number is inserted in place of the '~%d~'; and the string in double
  quotes, ~"pink elephants"~, is treated as a single argument and
  inserted in place of the '~%s~'.  (That is to say, a string between
  double quotes evaluates itself, like a number.)

- Finally, here is somewhat complex example that not only illustrates
  the computation of a number, but also shows you how you can use an
  expression within an expression to generate the text that is
  substituted for '~%s~':

  #+begin_src emacs-lisp
    (message "He saw %d %s"
             (- fill-column 32)
             (concat "red "
                     (substring
                      "The quick brown foxes jumped." 16 21)
                     " leaping."))
  #+end_src

- In this example, ~message~ has three arguments: the string, ~"He saw
  %d %s"~, the expression, ~(- fill-column 32)~, and the expression
  beginning with the function ~concat~.  The value resulting from
  evaluation of ~(- fill-column 32)~ is inserted in place of the
  '~%d~', and the value returned by the expression beginning with
  ~concat~ is inserted in place of the '~%s~'.

- When your fill column is 70, and you evaluate the expression, the
  message ~"He saw 38 red foxes leaping."~ appears in your echo area.

** Setting the Value of a Variable

- There are several ways by which a variable can be given a value. One
  of the ways is to use either the function ~set~, or the special form
  ~setq~.  Another way is to use ~let~.

- The jargon for this process is to /bind/ a variable to a value.

  - [[Using set][Using set]]         Setting values.
  - [[Using ~setq~][Using ~setq~]]   Setting a quoted value.
  - [[Counting][Counting]]           Using ~setq~ to count.

*** Using set

- To set the value of the symbol ~flowers~ to the list ~'(rose violet
  daisy buttercup)~, evaluate the following expression by positioning
  the cursor after the expression and typing ~C-x C-e~.

  #+begin_src emacs-lisp
    (set 'flowers '(rose violet daisy buttercup))
  #+end_src

- When you evaluate ~flowers~, the list ~(rose violet daisy
  buttercup)~ appears in the echo area.

- Incidentall y, if you evaluate ~'flowers~, the variable with a quote
  in front of it, what you will see in the echo area is the symbol
  itself, ~flowers~.  Here is the quoted symbol, so you can try this:

  #+begin_src emacs-lisp
    'flowers
  #+end_src

- Note also, that when you use ~set~, you need to *quote both
  arguments* to ~set~.  Unless you want them evaluated.

- Since we do not want either argument evaluated, neither the variable
  ~flowers~ nor the list ~(rose violet daisy buttercup)~, both are
  quoted.

- When you use ~set~ *without quoting* it first argument, the first
  argument is evaluated before anything else is done.  If you did this
  and ~flowers~ did not have a value already, you would get an error
  message that the ~'Symbol's value as variable is void'~; on the
  other hand, if ~flowers~ did return a value after it was evaluated,
  the ~set~ would attempt to set value that was returned.  There are
  situations where this is the right thing for the function to do; but
  such situation are *rare*.

*** Using ~setq~

- As a practical matter, you almost always quote the first argument to
  ~set~.  The combination of ~set~ and a quoted first argument is /so
  common/ that is has its own name: the special form ~setq~.  This
  special form is just like ~set~ except that the first argument
  is *quoted automatically*, so you don't need to type the quote mark
  yourself.

- Also, as an added convenience, ~setq~ permits you to set several
  different variables to different values, all in one expression.

- To set the value of the variable ~carnivores~ to the list ~'(lion
  tiger leopard)~ using ~setq~, the following expression is used

  #+begin_src emacs-lisp
    (setq carnivores '(lion tiger leopard))
  #+end_src

- This is exactly the same as using ~set~ except the first argument is
  automatically quoted by ~setq~

- The '~q~' in ~setq~ means *quote*.

- With ~set~, the expression would look like this:

  #+begin_src emacs-lisp
    (set 'carnivores '(lion tiger leopard))
  #+end_src

- Also, ~setq~ can be used to assign /different values to different
  variables/.  The first argument is bound to the value of the second
  argument, the third argument is bound to the value of the forth
  argument, and so on.

- For example, you could use the following to assign a list of trees to
  the symbol ~trees~ and list of herbivores to the symbol ~herbivores~:

  #+begin_src emacs-lisp
    (setq trees '(pine fir oak maple)
          herbivores '(gazelle antelope zebra))
  #+end_src

- The expression could just as well been on one line, but it might not
  have fit on a page; and humans find it easier to read nicely
  formatted lists.

  Although I have been using the term "*assign*", there is another way
  of thinking about the workings of ~set~ and ~setq~; and that is to
  say that ~set~ and ~setq~ make the symbol /point/ to the list.  This
  latter way of thinking is very common and in forthcoming chapters we
  shall come upon at least one symbol that has "*pointer*" as part of
  its name.  The name is chosen because the symbol has a value,
  specifically a list, attached to it; or, expressed another way, the
  symbol is set to point to the list.

*** Counting

- Here is an example that show how to use ~setq~ in a counter. You might
  use this to count how many times a part of your program repeats
  itself.  First set a variable to zero; then add one to the number
  each time the program repeat itself.  To do this, you need a
  variable that serves as a counter, and two expression; an initial
  ~setq~ expression that sets the counter variable top zero; and a
  second ~setq~ expression that increment the counter each time it is
  evaluated.

  #+begin_src emacs-lisp
    (setq counter 0)              ;; let's call this initializer

    (setq counter (+ counter 1))  ;; This is the increment

    counter                       ;; This is the counter
  #+end_src

- If you evaluate the first of these expression, the initialize,
  ~(setq counter 0)~, and then evaluate the third expression,
  ~counter~, the number ~0~ will appear in the echo area.

  If you then evaluate the second expression, the incremented, ~(setq
  counter (+ counter 1))~, the counter will get the value of ~1~.

  So if you again evaluate ~counter~, the number ~1~ will appear in
  the echo area.

  Each time you evaluate the second expression, the value of the
  counter will be increased.

- When you evaluate the incrementer, ~(setq counter (+ counter 1))~, the
  Lisp interpreter first evaluates the innermost list; this is the
  addition.  In order to evaluates this list, it must evaluates the
  variable ~counter~ and the number ~1~.  When it evaluates the
  variables ~counter~, it receives its current values.  It passes this
  values and the number ~1~ to the ~+~ which adds them together.  The
  sum is then returned as the value of the inner list and passed to
  the ~setq~ which sets the variables ~counter~ to this new values.
  Thus, the value of the variable, ~counter~, is changed.

** Summary

- Learning Lisp is like climbing a hill in which the first part is the
  steepest.  You have now climbed the most difficult part; what
  remains becomes easier as you progress inwards.

- Lisp programs are made up of /expression/, which are /lists/ or
  /single atoms/.

- List are made up of /zero/ or /more atoms/ or /inner list/,
  separated by whitespace and surround by parentheses.  A list can be
  empty.

- Atoms are /multi-character symbols/, like ~forward-paragraph~,
  /single character symbol/ like ~+~, /string of characters/ between
  double quotes marks, or numbers.

- A number evaluates to itself.

- A string between double quotes also evaluates itself.

- When you evaluate a symbol by itself, its value is returned.

- When you evaluate a list, the Lisp interpreter looks at the first
  symbol in the list and then at the function definition bound to that
  symbol.  Then the instruction in the function definition are carried
  out.

- A single-quote *~'~*, tells the Lisp interpreter that it should
  returns the following expression as written, and not evaluate it as
  it would if the quote were not there.

- Arguments are the information passed to a function.  The arguments
  to a function are computed by evaluating the rest of the elements of
  the list of which the function is the first elements.

- A function always returns a value when it is evaluated (unless it
  gets an error); in addition, it may also carry out some action that
  is a /side effect/.

- In many cases, *a function's primary purpose is to create a side
  effect*.


* Practicing Evaluation

- It is useful to spend a little time evaluating various expression that
  have already written.  Theses expression will be lists with the
  functions as their first (and often only) element.  Since some of the
  *functions associated with buffers* are both simple and interesting,
  we will start with those.

- In this section, we will evaluate a few of these. In another section,
  we will study the code of several other buffer-related function, to
  see how they were written.

 - [[How to Evaluate][How to Evaluate]]                               Typing editing or ~C-x C-e~ causes evaluation

 - [[Buffer Names][Buffer Names]]                                     Buffers and files are different.

 - [[Getting Buffers][Getting Buffers]]                               Getting a buffer itself, not merely its name.

 - [[Switching Buffers][Switching Buffers]]                           How to change to another Buffer.

 - [[Buffer Size and the location of Point][Buffer Size & Location]]  Where point is located and the size of the buffer

** How to Evaluate

- /Whenever you give an editing command/ to Emacs Lisp, such as the
  command to move the cursor or to scroll the screen, you are
  /evaluating an expression/, he first element of which is a
  function. /This is how Emacs works/.

- When you type keys, you cause the Lisp interpreter to evaluate an
  expression and that is how you get your result.

- Even typing plain text involves evaluating an Emacs Lisp function, in
  this case, one that use ~self-inserted-command~, which simply inserts
  the character you typed.

- The functions you evaluate by typing keystrokes are called
  /interactive/ function, or /commands/; how you make a function
  interactive will be illustrated in the chapter on how to write
  function definitions.

- In addition to typing keyboard commands, we have seen a second way to
  evaluate an expression: by positioning the cursor after a list and
  typing ~C-x C-e~.  This is what we will do in the rest of this
  section.  There are other ways to evaluate an expression as well;
  these will be described as we come to them.

- Beside being used for practicing evaluation, the functions shown in
  the next few section are important in their own right.  A study of
  these functions makes clear the distinction between /buffers/ and
  /files/, how to switch to a buffer, and how to determine a location
  with it.

** Buffer Names

- The two function, ~buffer-name~ and ~buffer-file-name~, show the
  difference between a file and a buffer.  When you evaluate the
  following expression, ~(buffer-name)~, the name of the buffer appears
  in the echo area. When you evaluate ~(buffer-file-name)~, the name of
  the file which the buffer refers appears in the echo area.  Usually,
  the name returned by ~(buffer-name)~ is the same as the name of the
  file to which it refers, and the name returned by ~(buffer-file-name)~
  is the full path-name of the file.

- A file and a buffer are two different entities.  A file is
  information recorded permanently in the computer (unless you delete
  it).

- A buffer, on the other had, is information inside of Emacs that will
  vanish at the end of the editing session (or when you kill the
  buffer).

- Usually a buffer contains information that contains information that
  you have copied from a file; we say that buffer is /visiting/ that
  file.  This copy is what you work on and modify.  Changes to the
  buffer do not change the file, until you save the buffer.  When you
  save the buffer is copied to the file and is thus saved permanently.

  #+begin_src emacs-lisp
    (buffer-name)
    (buffer-file-name)
  #+end_src

- In spite of the distinction between files and buffers, you will often
  find that people refer to a file when they mean a buffer and vice
  versa.  Indeed most say "I am editing a file," rather than saying,
  "I am editing a buffer which I will soon save to a file".  It is
  almost always clear from context what people mean.

  When dealing with computer programs, however, it is important to
  keep the distinction in mind, since the computer is not as smart as
  a person.

- The word "buffer", by the way, comes from the meaning of the word as a
  cushion that deadens the force of a collision.  In early computers,
  a buffer cushioned the interaction between files and computers
  central processing unit.  The drums or tapes that held a file and
  the central processing unit were pieces of equipment that were very
  different from each other, working at their own speed, in spurts.
  The buffer made it possible for them to work together effectively.
  Eventually, the buffer grew from being an intermediary, a temporary
  holding place, to being the place where work is done.  this
  transformation is rather like that of a small seaport that grew into
  a great city; once it was merely the place where cargo was
  warehoused temporarily before being loaded onto ship; then it became
  a business and cultural center in its own right

- Not all buffers are associated with files. For example, a ~*scratch*~
  buffer does not visit any files.  Similarly, a ~*Help*~ buffer is
  not associated with any file.

- In the old days, when you lacked a ~~/.emacs~ file and started an
  Emacs session by typing the command ~emacs~ alone, without naming
  any files, Emacs started with the ~*scratch*~ buffer visible.
  Nowadays, you will see a splash screen.  You can follow one of the
  command suggested on the splash screen, visit a file, or press ~q~
  to quit the splash screen and reach the ~*scratch*~ buffer.

- If you switch to the ~*scratch*~ buffer, type ~(buffer-name)~,
  position the cursor after it, and then type ~C-x C-e~ to evaluate
  the expression. The name ~"*scratch*"~ will returned and will appear
  in echo area.  ~"*scratch*"~ is the name of the buffer.  When you
  type ~(buffer-file-name)~ in the ~*scratch*~ buffer and evaluate
  that, ~nil~ will appear in the echo area, just as it does when you
  evaluate ~(buffer-file-name)~ in Info.

- Incidentally, if you are in the ~*scratch*~ buffer and want the value
  returned by an expression to appear in the ~*scratch*~ buffer itself
  rather than in the echo area, type ~C-u C-x C-e~ instead of ~C-x
  C-e~.  This causes the value returned to appear after the
  expression. The buffer will look like this:

  #+begin_src emacs-lisp
  ;; in *scratch* buffer
    (buffer-name)"*scratch*"
  #+end_src

- You cannot do this in Info since Info is read-only, and it will not
  allow you to change the contents of the buffer.  But you can do this
  in any buffer you can edit; and when you write code for
  documentation (such as this book), this feature is useful.

** Getting Buffers

- The ~buffer-name~ function returns the /name/ of the buffer; to get
  the buffer /itself/, a different function is needed; the
  ~current-buffer~ function.  If you use this function in code, what
  you get is the buffer it self.

- A name and the object or entity to which the name refers are different
  from each other.  The name of the scratch buffer is ~*scratch*~, but
  the name is *not* the buffer.  To get a buffer itself, you need to
  use a function such as ~current-buffer~.

- However, there is a slight complication: if you evaluate
  ~current-buffer~ in an expression on its own, as we will do here,
  what you see is a printed representation of the name of the buffer
  without the contents of the buffer.  Emacs work this way for *two
  reason*:

  - the buffer may be thousand of line log--too long to be
    conveniently displayed

  - Another buffer may have the same contents but a different name,
    and it is important to distinguish between them.

- Here is an expression containing the function:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (current-buffer)
  #+end_src

- If you evaluate this expression in ~*scratch*~ buffer in the usual
  way, ~#<buffer *scratch*>~ will appear in the echo area.  The
  special format indicates the buffer itself is being returned, rather
  than just its name.

- Incidentally, while you can type a number or symbol into a program,
  you cannot do that with the printed representation of a buffer; the
  only way.

- A related function is ~other-buffer~.  This returns the most recently
  selected buffer other than one you are in currently, bit a printed
  representation of its name.  If you have recently switched back and
  forth from the ~*scratch*~ buffer, ~other-buffer~ will return that
  buffer.

- You can see this by evaluating the expression:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (other-buffer)
  #+end_src

- You should see ~#<buffer *scratch*>~ appear in the echo area, or the
  name of whatever other buffer you switched back from most recently.

** Switching Buffers

- The ~other-buffer~ function actually provides a buffer when it us
  used an argument to a function that requires one.  We can see this
  by using ~other-buffer- and ~switch-to-buffer~ to switch to a
  different buffer.

- But first, a brief introduction to the ~switch-to-buffer~ function.
  When you switched back and forth from Info to the ~*scratch*~ buffer
  to evaluate ~(buffer-name)~, you most likely typed ~C-x b~ and then
  typed ~*scratch*~ when prompted in the minibuffer for the name of
  the buffer to which you wanted to switch.  The keystroke ~C-x b~,
  cause the Lisp interpreter to evaluate the interactive function
  ~switch-to-buffer~.  As we said before, this is how Emacs works:
  /different keystrokes call or run different function/.  For example,
  ~C-f~ calls ~forward-char~, ~M-e~ calls ~forward-sentence~, and so
  on.


- By writing ~switch-to-buffer~ in an expression, and giving it a buffer
  to switch to, we can switch buffers just the way ~C-x b~ does:

  #+begin_src emacs-lisp
    ;; in *scratch* buffer
    (switch-to-buffer (other-buffer))
  #+end_src

- The symbol ~switch-to-buffer~ is the first element of the list, so the
  Lisp interpreter will treat it as a function and carry out the
  instruction that are attached to it.  But before doing that, the
  interpreter will note that ~other-buffer- is inside parentheses and
  work on that symbol first.

  ~other-buffer- is the first (and in this case, the only) element of
  the list, so the Lisp interpreter calls or runs the function.  It
  returns another buffer.

  Next the interpreter runs ~switch-to-buffer~, passing to it, as an
  argument, the other buffer, which is what Emacs will switch to. If
  you are reading this in Info, try this now.  Evaluate the
  expression.

- In the programming examples in later section of this document, you
  will see the function ~set-buffer~ more often than
  ~switch-to-buffer~.  This because of a difference between computer
  program and humans: /Humans eyes and expect to see the buffer on
  which they are working on their computer terminals/.  This is so
  obvious, it almost goes without saying.  However program do not have
  eyes.  /When a computer program work on a buffer, that buffer does
  not have to be visible on the screen/.

- ~switch-to-buffer~ is designed for humans and does two different
  things:

  - It switches the buffer to which Emacs's attention is directed;

  - It switches the buffer in the window to the new buffer.

- ~set-buffer~ on other hand does only one thing:

  - It switches the attention of the computer program to a different
    buffer.  The buffer on screen remain unchanged (of course,
    normally nothing happens there until the command finished
    running).

- Also, we have just introduced another jargon term, the word
  */call/*.  When you evaluate a list in which the first symbol is a
  function, you are calling that function.  The use of the term comes
  from the notion of the function as an entity that can do something
  for you if you call it--just a plumber is an entity who can fix a
  leak if you call him or her.

** Buffer Size and the location of Point

- Finally, let's look at several rather simple function,
  ~buffer-size~, ~point~, ~point-min~, and ~point~max~.  These give
  information about the size of a buffer and the location of point
  within it.

- The function ~buffer-size~ tells you the size of the current buffer,
  that is, the function returns a count of the number of characters in
  the buffer

  #+begin_src emacs-lisp
    (buffer-size)
  #+end_src

- In Emacs, the */current position of the cursor/* is called
  */point/*.  The expression ~(point)~ returns a number that tells you
  where the cursor is located as a count of the number of characters
  from the beginning of the buffer up to point.

  You can see character count for point in this buffer by evaluating
  the following expression in the usual way:

  #+begin_src emacs-lisp
    (buffer-size)49770 ; C-u C-x C-e
  #+end_src

  As I write this, the value of point is 49770. The ~point~ function is
  frequently used in some of the examples later in this book.

- The value of point depends, of course, on its location within the
  buffer. If you evaluate point in this spot, the number will be
  larger

  #+begin_src emacs-lisp
    (buffer-size)49775  ; C-u C-x C-e
  #+end_src

- For me, the value of point in this location is 49775, which means that
  there 49855 characters (including spaces) between the two
  expression. (Doubtles, you will see different numbers, since I will
  have edited this since I first evaluated point.

  #+begin_src emacs-lisp
    (point-min)1  ; C-u C-x C-e

    (point-max)50296  ; C-u C-x C-e
  #+end_src

- The function ~point-min~ is somewhat similar to ~point~, but it
  returns the value of the /minimum permissible/ value of point in the
  current buffer.  This is the number ~1~ unless /narrowing/ is in
  effect.  (Narrowing is a mechanism whereby you can restrict
  yourself, or a program, to operations on juts a part of a
  buffer. See Narrowing and Widening).

- Likewise, the function ~point-max~ returns the value of the maximum
  permissible value of point in the current buffer.


* How To Write Function Definition

- When the Lisp interpreter evaluates a list, it looks to see whether
  the first symbol on the list has a function definition attached to
  it; or, put another way, whether the symbol points to a function
  definition.  If it does, the computer carries out the instruction in
  the definition.  A symbol that has a function definition is called,
  simply, a function (although, properly speaking, the definition is
  the function and the symbol refers to it).

  - [[An Aside about Primitive Function][Primitive Function]]

  - [[The ~defun~ Macro][~defun~]]                                 The ~defun~ macro.

  - [[Install A Function Definition][install]]                     Install a function definition.

  - [[Make a Function Interactive][Interactive]]                   Making a function interactive.

  - [[Different Options for interactive][Interactive Options]]     Different options for ~interactive~.

  - [[Install Code Permanently][Permanent Installation]]           Installing code permanently.

  - [[let][let]]                                                   Creating and initializing local variables.

  - [[The ~if~ Special Form][if]]                                  What if?

  - [[If-then-else Expression][else]]                              if-then-else expression.

  - [[Truth & Falsehood in Emacs Lisp][Truth & Falsehood]]         What Lisp considered false and true.

  - [[~save-excursion~][~save-excursion~]]                         Keeping track of point and buffer.

  - [[Review][Review]]

** An Aside about Primitive Function

- /All function are defined in terms of other functions/,*except* for
  a few */primitive/* functions that are written in the C programming
  language.

- When you write functions' definitions, you will write them in Emacs
  Lisp and use other functions as your building blocks.  Some of the
  function you will use will themselves be written in Emacs Lisp
  (perhaps by you) and some will be primitives written in C.

- When you write code in Emacs Lisp, you d not distinguish between the
  use of function written in C and the use of functions written in
  Emacs Lisp.  The difference is irrelevant.  I mention the
  distinction only because it is interesting to know.  Indeed, unless
  you investigate, you won't know whether an already-written function
  is written in Emacs Lisp or C.

** The ~defun~ Macro

- In Lisp, a symbol such as ~mark-whole-buffer~ has code attached to
  it that tells the computer what to do when the function is called.
  This code is called the /function definition/ and is created by
  evaluating a Lisp expression that start with the symbol /defun/
  (which abbreviation for /define function/).

  In Subsequent sections, we will look at function definitions from
  the Emacs source code, such as ~mark-whole-buffer~.  In this
  section, we will describe a simple function definition so you can
  see how it looks.

  This function definition uses arithmetic because it makes for a
  simple example.  Some people dislike example using arithmetic;
  however, if you are such a person, do not despair.  Hardly any of
  the code we will study in the remainder of this introduction
  involves arithmetic or mathematics.  The examples mostly involve
  text in one way or another.

- A function definition has up to *five* parts following the word
  ~defun~:

  - The name of the symbol to which the function definition should be
    attached

  - A list of the /arguments/ that will be passed to the function.  If
    no arguments will be passed to the function, this is an empty list
    ~()~

  - Documentation describing the function. (Technically optional, but
    strongly recommended).

  - Optionally, an expression to make the function *interactive* so
    you can use it by typing ~M-x~ and then the name of the function;
    or by typing an appropriate key or key chord.

  - The code that instruct the computer what to do; the /body/ of the
    function definition.

- It is helpful to think of the /five parts/ of a function definition
  as being organized in a template, with slots for each part:

  #+begin_src emacs-lisp
    (defun function-name (arguments...)
      "optional-documentaion.."
      (interactive argument-passing-info)      ; optional
      body..)
  #+end_src

- As an example, here is the code for a function that multiplies its
  arguments by 7. (This example is *not interactive*)

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))
  #+end_src

  - The definition begin with a parenthesis and the symbol ~defun~,
    followed by the name of the function.

  - The name of the function is followed by a list that contains the
    arguments that will be passed to the function.  This list is
    called the /argument list/.  In this example, the list has only
    one element, the symbol, ~number~.  When the function is used, the
    symbol will be bound to the value that is used as argument to the
    function.

  - The argument list is followed by the documentation string that
    describes the function.  This is what you see when you type ~C-h
    f~ and the name of a function.  Incidentally, when you write a
    documentation string like this, you should make the first line a
    complete sentence since some commands, such /apropos/, print only
    the first line of a multi-line documentation string.  Also, you
    should not indent the second line of a documentation string, if
    you have one, because that looks odd when you use ~C-h f
    (describe-function)~.

  - The documentation string is optional, but it is so useful, it
    should be included in almost every function you write.

  - The third line of the example consist of the body of the function
    definition.  In this function, the body is the list, ~(* 7
    number)~, which says to multiply the value of /number/ by 7.

- When you use the ~multiply-by-seven~ function, the argument ~number~
  evaluates to the actual number you want used.  Here is an example
  that shows ~multiply-by-seven~ is used; but don't try to evaluate
  this yet!!.

  #+begin_src emacs-lisp
    (multiply-by-seven 3)
  #+end_src

  - The symbol ~number~, specified in the function in the next
    section, is bound to the value 3 in the actual use of the
    function.

  - Note that although ~number~ was inside parentheses in the function
    definition, the argument passed to the ~multiply-by-seven~ is not
    parentheses.  The parentheses are written in the function
    definition so the computer can figure out where argument list ends
    and the rest of the function definition begins.

- If you evaluate this example, you are likely to get an error
  message.  This is because we have written the function definition,
  but not yet told the computer about the definition--we have *not yet
  loaded the function definition in Emacs*.  Installing a function is
  the process that tells the Lisp interpreter the definition of the
  function.

** Install A Function Definition

- If you are reading this inside Info in Emacs, you can try out the
  ~multiply-by-seven~ function by first evaluating the function
  definition and then evaluating ~(multiply-by-seven 3)~.  A copy of
  the function definition follows.

- Place the cursor after the last parenthesis of the function
  definition and type ~C-x C-e~.  When you do this,
  ~multiply-by-seven~ will appear in the echo area.  (What this means
  is that when a function definition is evaluated, the value it
  returns is the name of the defined function).  At the same time,
  this action installs the function definition.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))
  #+end_src

- By evaluating this ~defun~, you have just *installed*
  ~multiply-by-seven~ in Emacs.  The function is now just as much as
  part of Emacs as ~forward-word~ or any other editing function you
  use.

- ~multiply-by-seven~ will stay installed until you quit Emacs.  To
  reload code automatically whenever you start Emacs, see Installing
  Code Permanently.

  - [[The effect of installation][Effect of installation]]

  - [[Change a Function Definition][Change a defun]]        How to change a function definition

*** The effect of installation

- You can see the effect of installing ~multiply-by-seven~ by evaluating
  the following sample.  Place the cursor after the following expression
  and the ~C-x C-e~.  The number 21 will appear in the echo area.

  #+begin_src emacs-lisp
    (multiply-by-seven 3)
  #+end_src

- If you wish, you can read the documentation for the function by
  typing ~C-h f (describe-function)~ and then the name of the
  function, ~multiply-by-seven~.  When you do this, a ~*Help*~ window
  will appear on your screen that says

  #+begin_src emacs-lisp
  multiply-by-seven is a Lisp function.

  (multiply-by-seven NUMBER)

  Multiply NUMBER by seven.
  #+end_src

*** Change a Function Definition

- If you want to change the code in ~multiply-by-seven~, just rewrite
  it.  To install the new version in place of the old one, evaluate
  the function definition again.  This is how you modify code in
  Emacs.  It is very simple.

- As an example, you can change the ~multiply-by-seven~ function to
  add the number to itself seven times instead of multiplying the
  number by seven.  It produces the same answer, but by a different
  path.  At the same time, we will add comment to the code; a comment
  is text that Lisp interpreter ignores, but that a human reader may
  find useful or enlightening.

- The comment is that this is the second version.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)         ; Second version
      "Multiply NUMBER by seven."
      (+ number number number number number number number))
  #+end_src

- The comment follows a semicolon '~;~'.  In Lisp, everything on a
  line that follows a semicolon is a comment.  The end of the line is
  the end of the comment.  To stretch a comment or two or more lines,
  begin each lines with a semicolon.

- See Beginning a .emacs File, and Comments in The GNU Emacs Lisp
  Reference Manual, for more about comments.

- You can install the version of the ~multiply-by-seven~ function by
  evaluating it in the same way you evaluated the first function:
  place the cursor after the last parenthesis and type ~C-x C-e~.

- In summary, this is how you write code in Emacs Lisp: you write a
  function; install it; test it; and then make fixes or enhancements
  and install it again.

** Make a Function Interactive

- You make a function interactive by placing a list that begins with the
  special form ~interactive~ immediately after the documentation.  A
  user can invoke an interactive function by typing ~M-x~ and then the
  name of the function; or by typing the keys to which it is bound;
  for example, by typing ~C-n~ for ~next-line~ or ~C-x h~ for
  ~mark-whole-buffer~.

- Interestingly, when you call an interactive function interactively,
  the value returned is not automatically displayed in the echo area.
  This is because you often call an interactive function for its side
  effects, such as moving forward by a word or line, and /not for the
  value returned/.  If the returned value were displayed in the echo
  area each time you typed a key, it would be very distracting.


  - [[An Interactive multiply-by-seven, An Overview][ An Interactive multiply-by-seven]]       An overview

  - [[An Interactive ~multiply-by-seven~][multiply-by-seven in detail]]                        The interactive version

*** An Interactive multiply-by-seven, An Overview

- Both the use of the special form ~interactive~ and one way to display
  a value in the echo area can be illustrated by creating an interactive
  version of ~multiply-by-seven~.

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)           ; Interactive version
      "Multiply NUMBER by seven."
      (interactive "p")
      (message "the result is %d" (* 7 number)))
  #+end_src

- You can install this code by placing your cursor after it and typing
  ~C-x C-e~. The name of the function will appear in your echo area.
  Then, you can use this code by typing ~C-u~ and a number and then
  typing ~M-x multiply-by-seven~ and pressing ~RET~.  The phrase '~The
  result is ...~' followed by the product will appear in the echo
  area.

- Speaking more generally, you invoke a function like this in either
  of two ways:

  1. By typing a prefix argument that contains the number to be
     passed, and then typing ~M-x~ and the name of the function, as
     which "~C-u 3 M-x forward-sentence~"; or,

  2. By typing whatever key or key chord the function is bound to,
     with ~C-u 3 M-e~.

- Both the examples just mentioned work identically to move point
  forward three sentences. (Since ~multiply-by-seven~ is not bound
  to any key, it could not be used as an example of key binding.).

- (See [[][Some Keybindings]], to learn how to bind a command to a
  key/]

- A /prefix argument/ is passed to an interactive function by typing
  the ~META~ key followed by a number, for example, ~M-3 M-e~, or by
  typing ~C-u~ and then a number, for example, ~C-u 3 M-e~ (if you
  type ~C-u~ without a number, it defaults to 4).

*** An Interactive ~multiply-by-seven~

- Let's look at the use of the special from ~interactive~ and then at
  the function ~message~ in the interactive version of
  ~multiply-by-seven~.  You will recall that the function definition
  looks like this:

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)           ; Interactive version
      "Multiply NUMBER by seven."
      (interactive "p")
      (message "The result is %d" (* 7 number)))
  #+end_src

- In this function, the expression, ~(interactive "p")~, is a list of
  two elements.  The ~"p"~ tells Emacs to pass the prefix argument to
  the function and use its value for the argument of the function.

- The argument will be a number.  This means that the symbol ~number~
  will be bound to a number in the line:

  #+begin_src emacs-lisp
    (message "The result is %d" (* 7 number))
  #+end_src

- For example, if you prefix argument is 5, the Lisp interpreter will
  evaluate the line as if it were:

  #+begin_src emacs-lisp
    (message "The result is %d" (* 7 5))
  #+end_src

- (If you are reading this in GNU Emacs, you can evaluate this
  expression yourself). First, the interpreter will evaluate the inner
  list, which ~(* 7 5)~.  This returns a value of 35.  Next, it will
  evaluate the outer list, passing the values of the second and
  subsequent elements of the list to the function ~message~.

- As we have seen, ~message~ in Emacs Lisp function especially
  designed for sending a one line message to a user.  In summary, the
  ~message~ function prints its first argument in the echo area as is,
  except for occurrences of '~%d~' and '~%s~' (and various other
  %-sequences which we have not mentioned).  When it sees a control
  sequence, the function looks to the second or subsequent arguments
  and prints the value of the argument in the location in the string
  where the control sequence is located.

- In the interactive ~multiply-by-seven~ function, the control string
  is '~%d~', which requires a number, and the value returned by
  evaluating ~(* 7 5)~ is the number 35.  Consequently, the number 35
  is printed in place of the '~%d~' and the message is '~The result is
  35~'.

- Note that when you call the function ~multiply-by-seven~, the
  message is printed without quotes, but when you call ~message~, the
  text is printed in double quotes.  This is because the value
  returned by ~message~ is what appears in the echo area when you
  evaluate an expression whose first element is ~message~; but when
  you embedded in a function, ~message~ prints the text as a /side
  effect/ without quotes.

** Different  Options for interactive

- In the example, ~multiply-by-seven~ used ~"p"~ as the argument to
  ~interactive~.  This argument told Emacs to interpret your typing
  either ~C-u~ followed by number or ~META~ followed by a number as a
  command to pass that number to the function argument.  Emacs has
  more that twenty characters predefined for use with ~interactive~.
  In almost case, one of these options will enable you to pass the
  right information interactively to a function.  (See Code Characters
  for ~interactive~) in the GNU Emacs Lisp Reference Manual.)

- Consider the function ~zap-to-char~. Its interactive expression is

  #+begin_src emacs-lisp
    (interactive "p/ncZap to char: ")
  #+end_src

- The first part of the argument to ~interactive~ is '~p~', with
  which you are already familiar.  This argument tells Emacs to
  interpret a prefix, as a number to be passed to a the function.
  You can specify a prefix either by typing ~C-u~ followed by a
  number or by typing ~META~ followed by a number.

- The prefix is the number of specified characters.  Thus, if your
  prefix is three and the specified character is '~x~', then you
  will delete all the text up to and including the third next '~x~'.
  If you do not set a prefix, then you delete all the text up to an
  including the specified character, but no more.

- The '~c~' tells the function the name of the character to which to
  delete.

- More formally, a function with two or more arguments can have
  information passed to each argument by adding parts to the string
  that follows ~interactive~.  When you do this, the information is
  passed to each arguments in the same order it is specified in the
  ~interactive~ list.  In the string, each part is separated from
  the next part by a '~\n~', which is a newline.  For example, you
  can follow '~p~' with a '~/n~' and an '~cZap to char: ~'. This
  causes Emacs to pass the value of the prefix argument (if there is
  one) and the character.

- In this case, the function definition looks like the following,
  where ~arg~ and ~char~ are the symbol to which ~interactive~ binds
  the prefix argument and the specified character:

  #+begin_src emacs-lisp
    (defun name-of-function (arg char)
      "Documentation..."
      (interactive "p/ncZap to char: ")
      body-of-function...)
  #+end_src

- (The space after the colon in the prompt makes it look better when
  you are prompted. See The Definition of ~copy-to-buffer~, for an
  example)

- When a function does not take arguments, ~interactive~ does not
  require any.  Such a function contains the simple expression
  ~(interactive)~.  The ~mark-whole-buffer~ function is like this.

- Alternatively, if the special letter-codes are not right for your
  application, you can pass your own arguments to ~interactive~ as a
  list.

- See The Definition of ~append-to-buffer~, for an example.  See
  Using Interactive in The GNU Emacs Lisp Reference Manual, for a
  more explanation about this technique.

** Install Code Permanently

- When you install a function definition by evaluating it, it will
  stay installed until you quit Emacs.  The next time you start a new
  session of Emacs, the function will not be installed unless you
  evaluate the function definition again.

- At some point, you may want to have code installed automatically
  whenever you start a new session of Emacs.  There are several ways
  of doing this:

  * If you have code that is just for yourself, you can put the code
    for the function definition in your ~.emacs~ initialization file.
    When you start Emacs, your ~.emacs~ file is automatically
    evaluated and all the function definition within it are
    installed. See Your ~.emacs~ File.

  * Alternatively, you can put the function definitions that you want
    installed in one or more files of their own and use the ~load~
    function to cause Emacs to evaluate and thereby install each of
    the function in this files.  See Loading Files.

  * Thirdly, if you have code that your whole site will use, it is
    usual to put it in a file called ~site-init.el~ that is loaded
    when Emacs is built.  This makes the code available to everyone
    who use your machine.  (See the ~INSTALL~ file that is part of the
    Emacs distribution.)

- Finally, if you have a code that everyone who use Emacs may want,
  you can post it on a computer network or send a copy to Free
  Software Foundation.  (When you do this, please license the code and
  its documentation under a license that permit other people to run,
  copy, study, modify, and redistribute the code and which protects
  you from having your work taken from you.)

- If you send a copy of your code to the Free Software Foundation, and
  properly protect yourself and others, it may be included in the next
  release of Emacs. In large part, this is how Emacs has grown over
  the past years, by donations.

** let

- The ~let~ expression is a special form in Lisp that you will need to
  use in most function definitions.

- ~let~ is used to attach or bind a symbol to a value in such a way
  the Lisp interpreter will not confuse the variable with a variable
  of the same name that is not part of the function.

- To understand why the ~let~ special form is necessary, consider the
  situation in which you own a home that you generally refer to as
  "the house", as in the sentence, "The house needs painting."  If you
  are visiting a friend and your host refer to "the house", he is
  likely to be referring to /his/ house, not yours, that is, to a
  different house.

- If your friend is referring to his house and you think he is
  referring to your house, you may be in for some confusion.  The same
  thing could happen in Lisp if a variable that is used inside of one
  function has the same name as a variable that is used of another
  function, and the two are not intended to refer to the same value.
  The ~let~ special form prevents this kind of confusion.

  - [[~let~ Prevent confusion][Prevent confusion]]

  - [[The Parts of a ~let~ Expression][Parts of let Expression]]

  - [[Sample ~let~ Expression][Sample let Expression]]

  - [[Uninitialized Variables in a ~let~ Statement][Initialized let Variables]]

*** ~let~ Prevent confusion

- The ~let~ special form prevent confusion. ~let~ creates a name for a
  /local variable/ that overshadows any use of the same name outside
  the ~let~ expression.  This is like understanding that whenever your
  host refers to "the house", he means his house, not yours.  (Symbol
  used in argument list work the same way. See The ~defun~ Macro).

- Local variables created by ~let~ expression retain their value
  /only/ within the ~let~ expression itself (and within expression
  called within the ~let~ expression); the local variables have no
  effect outside the ~let~ expression.

- Another way to think about ~let~ is that it is like a ~setq~ that is
  temporary and local.  The value set by ~let~ are automatically
  undone when the ~let~ is finished.  The setting only affects
  expressions that are inside the bounds of the ~let~ expression.

- In computer jargon, we would say the binding of a symbol is visible
  only in functions called in the ~let~ form; in Emacs Lisp, the
  default scoping is dynamic, not lexical. (The non-default lexical
  binding is not discussed in this manual.)

- ~let~ can create more than one variable at once.  Also, ~let~ gives
  each variable it creates an initial value, either a value specified
  by you, or ~nil~.  (In the jargon, this is binding the variable to
  the value.).

- After ~let~ has created and bound the variables, it /executes/ the
  code in the body of the ~let~, and returns the value of the last
  expression in the body, as the value of the whole ~let~ expression.

- "Execute", is a jargon term that means to evaluate a list; it comes
  from the use of the word meaning "to give practical effect to"
  (Oxford English Dictionary).  Since you evaluate an expression to
  perform an action, "execute" has evolved as a synonym to "evaluate".

*** The Parts of a ~let~ Expression

- A ~let~ expression is list of *three parts*.  The first part is the
  symbol ~let~, The second part is a list, called a /varlist/, each
  element of which is either a symbol by itself or two-element list,
  the first element of which is a symbol.  The third part is the body
  of the ~let~.  The body usually consists of one or more lists.

- A template for a ~let~ expression looks like this:

  #+begin_src emacs-lisp
    (let varlist body...)
  #+end_src

- If the varlist is composed of two-element lists, as is often the
  case, the template for the ~let~ expression looks like this:

  #+begin_src emacs-lisp
    (let ((varlist value)
          (varlist value)
          ..)
      body...)
  #+end_src

*** Sample ~let~ Expression

- The following expression creates and gives initial value to the two
  variables ~zebra~ and ~tiger~.  The body of the ~let~ expression is
  a list which calls the ~message~ function.

  #+begin_src emacs-lisp
    (let ((zebra "stripes")
          (tiger "fierce"))
      (message "One kind of animal has %s and another is %s."
               zebra tiger))
  #+end_src

- Here, the varlist is ~(zebra "stripes") (tiger "fierce"))~.

- The two variables are ~zebra~ and ~tiger~.  Each variable is the
  first element of a two-element list and each value is the second
  element of its two-element list.

- In the varlist, Emacs binds the variable ~zebra~ to the value
  "~stripes~", and binds the variable ~tiger~ to the value "~fierce~".
  In this example, both values are strings.  The value could just as
  well have been another list or a symbol.

- The body of the ~let~ follows after the list holding the variables.
  In this example, the body is a list that uses the ~message~ function
  to print a string in the echo area.

- You many evaluate the example in the usual way, by placing the
  cursor after the last parenthesis and typing ~C-x C-e~.  When you do
  this, the following will appear in the echo area:

  #+begin_src emacs-lisp
    "One kind of animal has stripes and another is fierce"
  #+end_src

- As we have seen before, the ~message~ function prints its first
  argument, except for '~%s~'.  In this example, the value of the
  variable ~zebra~ is printed at the location of the first '~%s~' and
  the value of the variable ~tiger~ is printed at the location of the
  second '~%s~'.

*** Uninitialized Variables in a ~let~ Statement

- If you do not bind the variables in a ~let~ statement to specific
  initial values, they will automatically be bound to an initial value
  of ~nil~, as the following expression:

  #+begin_src emacs-lisp
    (let ((birch 3)
          pine
          fir
          (oak 'some))
      (message
       "Here are %d variables with %s, %s, and %s value."  birch
       pine fir oak))
  #+end_src

- Here, the varlist is ~(birch 3) pine fir (oak 'some))~.

- If you evaluate this expression in the usual way, the following will
  appear in your echo area:

  #+begin_src emacs-lisp
    "Here are 3 variabels with nil, nil, and some value."
  #+end_src

- In this example, Emacs binds the symbol ~birch~ to the number 3,
  binds the symbol ~pine~ and ~fir~ to ~nil~, and binds the symbol
  ~oak~ to the value ~some~.

- Note that in the first part of the ~let~, the variables ~pine~ and
  ~fir~ stand alone as atoms that are not surrounded by parentheses;
  this is because they are being bound to ~nil~, the empty list.  But
  ~oak~ is bound to ~some~ and so is a part of the list ~(oak 'some)~.
  Similarly, ~birch is bound to the number 3 and so is in a list with
  that number.  (Since a number evaluates to itself, the number does
  not need to be quoted.  Also, the number is printed in the message
  using a '~%d~' rather than a '~%s~'.) The four variables as a group
  into a list to delimit them from the body of the ~let~.

** The ~if~ Special Form

- Another special form is the condition ~if~.  This form is used to
  instruct the computer to make decisions.  You can write function
  definitions without using ~if~, but it is used often enough, and is
  important enough, to be included here.  It is used, for example, in
  the code for the function ~beginning-of-buffer~.

- The basic idea behind and ~if~, is that /if/ a test is *true*,
  /then/ an expression is *evaluated*.  If the test is *not true*, the
  expression is *not evaluated*.  For example, you might make a
  decision such as, "if it is warn and sunny, then go to the beach!"

  - [[~if~ in more detail][~if~ in more detail]]

  - [[The ~type-of-animal~ Function in Detail][~type-of-animal~ in detail]]     An example of an ~if~ expression.

*** ~if~ in more detail

- An ~if~ expression written in Lisp does not use the word "then"; the
  test and the action are the second and third elements of the list
  whose first element is ~if~.  Nonetheless, the test part of an ~if~
  expression is often called the /if-part/ and the second argument is
  often called the /then-part/.

- Also, when an ~if~ expression is written, the true-or-false is
  usually written on the same lines as the symbol ~if~, but the action
  to carry out if the test is true, the then-part, is written on the
  second and subsequent lines.  This makes the ~if~ expression is
  easier to read.

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-test-is-true)
  #+end_src

- The true-or-false test will be an expression that is evaluated by
  the Lisp interpreter.

- Here is an example that you can evaluate in the usual manner.  The
  test is whether the number 5 is greater than the number 4.  Since it
  is, the message "~5 is greater than 4!~' will be printed.

  #+begin_src emacs-lisp
    (if (> 5 4)                                 ; if-part
        (message "5 is greater than 4!"))       ; then-part
  #+end_src

  - The function ~>~ test whether its first argument is greater than
    its second argument and returns true if it is.

- Of course, in actual use, the test in an ~if~ expression will not be
  fixed for all time as it is by the expression ~(< 5 4)~.  Instead,
  at least one of the variables used in the test will be bound to a
  value that is not known ahead of time.  (If the value were known
  ahead of time, we would not need to run the test!)

- For example, the value may be bound to an argument of a function
  definition.  In the following function definition, the character of
  the animal is a value that is passed to the function. If the value
  bound to ~characteristic~ is "~fierce~", then the message, '~it is a
  tiger!~' will printed; otherwise, ~nil~ will be returned.

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)
      "Print message in echo area depending on CHARACTERISTIC.
        If the CHARACTERISTIC is the string \"fierce\",
    then warn of a tiger"
      (if (equal characteristic "fierce")
          (message "It is a tiger!")))
  #+end_src

- If you are reading this inside of GNU Emacs, you can evaluate the
  function definition in the usual way to install it in Emacs, and
  then you can evaluate the following two expression to see the
  results:

  #+begin_src emacs-lisp
    (type-of-animal "fierce")

    (type-of-animal "striped")
  #+end_src

- When you evaluate ~(type-of-animal "fierce")~, you will see the
  following message printed in the echo area: ~"it is a tiger!"~; and
  when you evalute ~(type-of-animal "stripe")~ you will see ~nil~
  printed in the echo area.

*** The ~type-of-animal~ Function in Detail

- Let's looks at the ~type-of-animal~ function in detail.

- The function definition for ~type-of-animal~ was written by filling
  the slots of two templates, one for a function definition as a
  whole, and a second for an ~if~ expression.

- The template for every function that is not /interactive/ is:

  #+begin_src emacs-lisp
    (defun name-of-function (argument-list)
      "documentation.."
      body..)
  #+end_src

- The part of the function that match this templates look like this:

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)
      "Print message in echo area depending on CHARACTERISTIC.
        If the CHARACTERISTIC is the string \"fierce\",
    then warn of a tiger."
      body: the if expression)
  #+end_src

- The name of function is ~type-of-animal~; it is passed the value of
  one argument.  The argument list is followed by a multi-line
  documentation string.  The documentation string is included in the
  example because it is a good habit to write documentation string for
  every function definition.  The body of the function definition
  consists of the if~ expression.

- The template for an ~if~ expression looks like this:

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-the-test-returns-true)
  #+end_src

- In the ~type-of-animal~ function, the code for the ~if~ looks like this:

  #+begin_src emacs-lisp
    (if (equal characteristic  "fierce")
        (message "It is a tiger!"))
  #+end_src

- Here, the true-or-false-test is the expression:

  #+begin_src emacs-lisp
    (equal characteristic "fierce")
  #+end_src

- In Lisp, ~equal~ is a function that determines whether its first
  argument is equal to its second argument.  The second argument is
  the string ~"fierce"~ and the first argument is the value of the
  symbol ~characteristic~--in other words, the argument passed to this
  function.

- In the first exercise of ~type-of-animal~, the argument ~"fierce"~
  is passed to ~type-of-animal~.  Since ~"fierce"~ is equal to
  ~"fierce"~, the expression, ~(equal characteristic "fierce")~,
  returns a value of /true/.  When this happens, the ~if~ evaluates
  the second argument or then-part of the ~if~: ~(message "It is a
  tiger!")~.

- On the other hand, in the second exercise of the ~type-of-animal~,
  the arguments ~"striped"~ is passed to
  ~type-of-animal"~. ~"striped"~ is not equal to ~"fierce"~, so the
  then-part is not evaluated and ~nil~ is returned by the ~if-
  expression.

** If-then-else Expression

- An ~if~ expression may have an optional third argument, called the
  /else-part/, for the case when the true-or-false-test returns false.
  When this happens, the second argument or then-part of the overall
  ~if~ expression is /not/ evaluated, but the third or else-part /is/
  evaluated.  You might think of this as cloudy day alternative for
  the decision "if it warn and sunny, then go to the beach, else read
  a book!".

- The word "else" is not written in the Lisp code; the else-part of an
  ~if~ expression comes after the then-part.  In the written Lisp, the
  else-part is usually written to start on a line of its own and is
  indented less than the then-part:

  #+begin_src emacs-lisp
    (if true-or-false-test
        action-to-carry-out-if-the-test-returns-true
      action-to-carry-out-if-the-test-returns-false)
  #+end_src

- For example, the following ~If~ expression prints the message ~"4
  not greater than 5!"~ when you evaluate it in the usual way:

  #+begin_src emacs-lisp
    (if (> 4 5)                                 ; if-part
        (message "4 falsely greater than 5!")   ; then-part
      (message "4 is not greater than 5!"))     ; else-part
  #+end_src

- Note that the /different levels of indentation/ make it easy to
  distinguish the then-part from the else-part.

- We can extend the ~type-of-animal~ function t include an else-part by
  simply incorporating an additional part of the ~if~ expression.

- You can see the consequences of doing this if you evaluate the
  following version of the ~type-animal- function to install it and
  then evaluate the two subsequent expression to pass different
  argument to the function.

  #+begin_src emacs-lisp
    (defun type-of-animal (characteristic)              ; Second version
      "Print message in echo area depending on CHARACTERISTIC.
              If the CHARACTERISTIC is the string \"fierce\",
              then warn of a tiger; else say it is not fierce."
      (if (equal characteristic "fierce")
      (message "It is a tiger!")
      (message "It is not fierce!")))
  #+end_src

  #+begin_src emacs-lisp
    (type-of-animal "fierce")

    (type-of-animal "striped")
  #+end_src

- When you evaluate ~(type-of-animal "fierce")~, you will see the
  following message printed in the echo area: ~"It is a tiger!"~; but
  when you evaluate ~(type-of-animal "stripes")~, you will see ~"It is
  not fierce!"~.

- Of course, i the /characteristic/ were ~"ferocious"~, the message
  ~"It is not fierce!"~ would be printed; and it would be misleading!
  When you write code, you need to take into account the possibility
  that some such argument will be tested by the ~if~ and write your
  program accordingly

** Truth & Falsehood in Emacs Lisp

- There is an important aspect to the truth test in an ~if~
  expression.  So far, we have spoken if "true" and "false" as values
  of predicates as if they were new kinds of Emacs of Emacs Lisp
  objects.  In fact, "false" is just our old friend ~nil~.  Anything
  else--anything at all--is "true".

- The expression that test for truth is interpreted as /true/ if the
  result of evaluating it is a value that is not ~nil~.  In other
  words, the result of the test is considered true if the value
  returned is a /number/ such as 47, a /string/ such as ~"hello"~, or
  a /symbol/ (other than ~nil~) such as ~flowers~, or a /list/ (so
  long as it is not empty) or even a /buffer/!.

  - [[An explanation of ~nil~][nil explained]]          ~nil~ has two meaning

*** An explanation of ~nil~

- Before illustrating a test for truth, we need an explanation of
  ~nil~.

- In Emacs Lisp, the symbol ~nil~ has two meanings. First, it means
  the empty list.  Second, it means false and is the value returned
  when a true-or-false-test tests false.  ~nil~ can be written as an
  empty list, ~()~, or as ~nil~.  As far as the Lisp interpreter is
  concerned, ~()~ and ~nil~ are the same.  Humans, however, tend to
  use ~nil~ for false and ~()~ for the empty list,

- In the first example, the number 4 is evaluated as the test in the
  ~if~ expression and returns itself; consequently, the then-part of
  the expression is evaluated and returned: ~'true'~ appears in the
  echo area.  In the second example, the ~nil~ indicates false,
  consequently, the else-part of the expression is evaluated and
  returned: ~'false'~ appears in the echo area.

  #+begin_src emacs-lisp
    (if 4
        'true
      'false)

    (if nil
        'true
      'false)
  #+end_src

- Incidentally, if some other useful value is not available for a test
  that returns true, then the Lisp interpreter will return the symbol
  ~t~ for true.  For example, the expression ~(> 5 4)~ returns ~t~
  when evaluated, as you can see by evaluating it in the usual way:

  #+begin_src emacs-lisp
    (> 5 4)
  #+end_src

  on the other hand, this function ~nil~ if the else is false.

  #+begin_src emacs-lisp
    (> 4 5)
  #+end_src

** ~save-excursion~

- The ~save-excursion~ function is the final special form that we will
  discuss in this chapter.

- In Emacs Lisp programs used for editing, the ~save-excursion~
  function is very common.  It saves the location of point, executes
  the body of the function, and the restores point to its previous
  position if its location was changed.  It primary purpose is to keep
  the user being surprised and disturbed by unexpected movement of
  point.

  - [[Point and Mark][Point and Mark]]

  - [[Template for a ~save-excursion~ Expression][Template for save-excursion]]

*** Point and Mark

- Before discussing ~save-excursion~, however, it may be useful first
  to review what point and mark are in GNU Emacs.  /Point/ is the
  *current location of the cursor*.  Whenever the cursor is, that is
  point.  More precisely, on terminals where the cursor appears to be
  on top of a character, point is immediately before the character.
  In Emacs Lisp, point is an *integer*.  The first character in a
  buffer is number one, the second is number two, and so on.  The
  function ~point~ returns the current position of the cursor as a
  number.  Each buffer has its own value for point.

- The /mark/ is another position in the *buffer*; its value can be set
  with a command such as ~C-SPC (set-mark-command)~.  If a mark has
  been set, you can use the command ~C-x C-x
  (exchange-point-and-mark)~ to cause the cursor to jump to the mark
  and set the mark to be the previous position of point.  In addition,
  if you set another mark, the position of the previous mark is saved
  in the mark ring.  Many mark positions can be saved this way.  You
  can jump the cursor to a saved mark by typing ~(C-u C-SPC)~ one or
  more times.

- The part of the buffer between point and mark is called /the
  region/.  Numerous commands work on the region, including
  ~center-region~, ~count-lines-region~, ~kill-region~, and
  ~print-region~.

- The ~save-excursion~ special form saves the location point and
  restore this point and restore this position after the code within
  the body of the special form is evaluated by the Lisp interpreter.
  Thus if point were in the beginning of a piece of text and some code
  moved point to the he end of the buffer, the ~save-excursion~ would
  put point back to where it was before, after the expression in the
  body of the function were evaluated.

- In Emacs, a function frequently moves point as part of its internal
  workings even though a user would not expect this.  For example,
  ~count-lines-region~ moves point.  To prevent the user from being
  bothered by jumps that are both unexpected and (from the user's
  point of view) unnecessary, ~save-excursion~ is often used to keep
  point in the location expected by the user.  The use of
  ~save-excursion- is *good housekeeping*.

- To make sure the house stays clean, ~save-excursion~ restores the
  value of point even if something goes wrong in the code inside of it
  (or, to be more precise and to use the proper jargon, "in case of
  abnormal exit").  This is feature is very helpful.

- In addition to recording the value of point, ~save-excursion~ keeps
  track of the current buffer, and restore it, too.  This means you
  can write code that will change the buffer and have ~save-excursion~
  switch you back to the original buffer.  This is how
  ~save-excursion~ is used in ~append-to-buffer~.  (See The Definition
  of ~append-to-buffer~).

*** Template for a ~save-excursion~ Expression

- The template for a ~save-excursion~ is simple:

  #+begin_src emacs-lisp
    (save-excursion
      body...)
  #+end_src

- The body of the function is one or more expressions that will be
  evaluated in sequence by the Lisp interpreter.  If there is more
  than one expression in the body, the value of the last one will be
  returned as the value of the ~save-excursion~ function.  The order
  expressions in the body are evaluated only for their side effects;
  and ~save-excursion~ itself is used only for its side effect (which
  is restoring the position of point).

- In more detail, the template for a ~save-excursion~ expression looks
  like this:

  #+begin_src emacs-lisp
    (save-excursion
      first-expression-in-body
      secon-expression-in-body
      third-expression-in-body
      ...
      last-expression-in-body)
  #+end_src

- An expression, of course, may be a symbol on its own or a list.

- In Emacs Lisp code, a ~save-excursion~ expression often occurs
  within the body of a ~let~ expression. It looks like this:

  #+begin_src emacs-lisp
    (let varlist
      (save-excursion
        body..))
  #+end_src

** Review

- In the last few chapter we have introduced a macro and a fair number
  of function and special forms.  Here they are describe in brief,
  along with a few similar function that have not been mentioned yet.

- ~eval-last-sexp~

  Evaluates the last symbolic expression before the current location
  of point.  The value is printed in the echo area unless the function
  is invoked with an argument; in the case, the output is printed in
  the current buffer.  This command is normally bound to ~C-x C-e~.

- *~defun~*

  Define function.  This macro has up to five parts: /the name/, /a
  template/ for arguments that will be passed to the function,
  /documentation/, an optional /interactive declaration/, and the
  /body/ of the definition.

  For example, in Emacs the function definition of
  ~dired-unmark-all-marks~ is as follows.

  #+begin_src emacs-lisp
    (defun dired-unmark-all-marks ()
      "Remove all marks from all files in the Dired buffer."
      (interactive)
      (dired-unmark-all-files ?\r))
  #+end_src

- *~interactive~*

  Declare to the interpreter that the function can be used
  interactively.  This special form my be followed by a string with
  one or more parts that pass in the information to the arguments of
  the function, in sequence.  These parts may be also tell the
  interpreter to prompt for information.  Parts of the string are
  separated by newlines, ~'\n'~.

  Common code characters are:

  - *~b~*

     The name of existing buffer

  - *~f~*

     The name of existing file

  - *~p~*

     The numeric prefix argument. (Note that this ~p~ is lower
    case.)

  - *~r~*

    Point and the mark, as two arguments, smallest first.  This is
    the only code letter that specified two successive argument rather
    than one.

- *~let~*

  Declare that a list of variables is for use within the body of the
  ~let~ and give them an initial value, either ~nil~ or a specified
  value; then evaluate the rest of the expression in the body of the
  ~let~ and return the value of the last one.  Inside the body of the
  ~let~, the Lisp interpreter does not see the values of the variables
  of the same names that are bound outside of the ~let~.

  For example,

  #+begin_src emacs-lisp
    (let ((foo (buffer-name))
          (bar (buffer-size)))
      (message
       "This buffer is %s and has %d characters."
       foo bar))
  #+end_src

- *~save-excursion~*

  Record the values of point and the current buffer before evaluating
  the body of this special form.  Restore the value of point and
  buffer afterward.

  For example,

  #+begin_src emacs-lisp
    (message "We are %d characters into this buffer."
             (- (point)
                (save-excursion
                  (goto-char (point-min)) (point))))
  #+end_src

- *~if~*

  Evaluate the first argument to the function; if is true, evaluate
  the second argument; else evaluate the third argument, if there is
  one.

  The ~if~ special form is called a /conditional/.  There are other
  conditional in Emacs Lisp, but ~if~ is perhaps the most commonly
  used.

  for example,

  #+begin_src emacs-lisp
    (if (= 27 emacs-major-version)
        (message "This is version 27 Emacs")
      (message "This is not version 27 Emacs"))
  #+end_src

- *~<~*, *~>~*, *~<=~*, *~>=~*

  The ~<~ function test whether its first argument is smaller than its
  second argument.  A corresponding function, ~>~, tests whether the
  first argument is greater than the second.  Likewise ~<=~ test
  whether the first argument is less than or equal to the second and
  ~>=~ test whether the first argument is greater than or equal to the
  second .  In all cases, both arguments must be /numbers/ or
  /markers/ (markers indicate position in buffers).

- *~=~*

  The ~=~ function test whether two arguments, both numbers or
  markers, are equal.

- *~equal~*, *~eq~*

  Test whether two objects are the same. ~equal~ uses one meaning of
  the word "same" and ~eq~ uses another; ~equal~ returns true if the
  two objects have a similar structure and contents, such as two
  copies of the same book.  On the other hand, ~eq~, returns true if
  both arguments are actually the same /object/.

- *~string<~*, *~string-lessp~*, *~string=~*, *~string-equal~*

  The ~string-lessp~ function tests whether its first arguments is
  smaller than the second argument.  A shorter, alternative name for
  the same function (a ~defalias~) is ~string<~.

  The arguments to ~string-lessp~ must be /strings/ or /symbols/; the
  ordering is lexicographic, so case is significant.  The print names
  of symbols are used instead of the symbol themselves.

  An empty string, ~""~, a string with no characters in it, is smaller
  than any string of characters.

- *~message~*

  Print a message in the echo area. The first argument is string that
  can contain '~%s~', '~$d~', or '~%c~' to print the value of
  arguments that follow the string.  The argument used by '~%s~' must
  be a string or a symbol; the argument '~%d~' must be a number.  The
  argument '~%c~' must be an ASCII code number; it will be printed as
  the character with that ASCII code.  (Various other %-sequence have
  not been mentioned.)

- *~setq~*, *~set~*

  The ~setq~ special form sets the value of its first argument to the
  value of the second argument.  The first argument is automatically
  quoted by ~setq~.  It does the same for succeeding pairs of
  arguments.  An other function, ~set~, takes only two arguments and
  evaluates both of them before setting the value returned by its
  first argument to the value returned by its second argument.

- *~buffer-name~*

  Without an argument, return the name of the buffer, as a string.

- *~buffer-file-name~*

  Without an argument, return the name of the buffer, as a string.

- *~current-buffer~*

  Return the buffer in which Emacs is active; it may not the buffer is
  visible on the screen

- *~other-buffer~*

  Return the most recently selected buffer (other than the buffer
  passed to ~other-buffer~ as an argument and other than the current
  buffer).

- *~switch-buffer~*

  Select a buffer for Emacs to be active in and display in the current
  window so users can look at it.  Usually bound to ~C-x C-b~

- *~set-buffer~*

  Switch Emacs's attention to a buffer on which programs will run.
  Don't alter what the window is showing.

- *~buffer-size~*

  Return the number of character in the current buffer.

- *~point~*

  Return the value of the current position of the cursor, as an
  integer counting the number of characters from the beginning of the
  buffer.

- *~point-min~*

  Return the minimum permissible value of point in the current buffer.
  This is 1, unless narrowing is in effect.

- *~point-max~*

  Return the value of the maximum permissible value of point in the
  current buffer.  This is the end of the buffer, unless narrowing is
  in effect.


* A few Buffer-Related Functions

- In This chapter we study in detail several of the function used in
  GNU Emacs.  This is called a "walk-through".  These functions are
  used as example of Lisp code, but are not imaginary examples; with
  the exception of the first, simplified function definition, these
  functions show the actual code used in GNU Emacs.  You can learn a
  great deal from these definitions.

- These function described here are all related to *buffers*. Later,
  we will study other function.

  - [[Finding More Information][Finding More]]                                               How to find more information.

  - [[A Simplified ~beginning-of-buffer~ Definition][simplified-beginning-of-buffer]]        Show ~goto-char~, ~point-min~,and ~push-mark~.

  - [[The Definition of ~mark-whole-buffer~][mark-whole-buffer]]                             Almost the same as ~beginning-of-buffer~.

  - [[the definition of ~append-to-buffer~][append-to-buffer]]                               Uses ~save-excursion~ and ~insert-buffer-substring~.

  -[[Review][Buffer Related Review]]                                                         Review

** Finding More Information

- In this walk-through, I will describe each new function as we come
  to it, sometimes in detail and sometimes briefly.  If you are
  interested, you can get the full documentation of any Emacs Lisp
  function at any time by typing ~C-h f~ and then the name of the
  function (and then ~RET~).  Similarly, you can get the full
  documentation for a variable by typing ~C-h v~ and then the name of
  the variable (and then ~RET~).

- Also, ~describe-function~ will tell you the location of the function location.

- Put point into the name of the file that contains the function and
  press the ~RET~ key.  In this case, ~RET~ means ~push-button~ rather
  than "return" or "enter".  Emacs will take you directly to the
  function definition.

- More generally, if you want to see a function in it s original
  source file, you can use the ~xref-find-definitions~ function to
  jump to it.  ~xref-find-definition~ works with a wide variety of
  languages, not just Lisp, and C, and it works with non-programming
  text as well.  For example, ~xref-find-definitions~ will jump to the
  various nodes in the Tex info source file f this document (provided
  that you've run the ~etags~ utility to record all the nodes in the
  manual that come with Emacs; see Create Tags Table in the GNU Emacs
  Manual).

- To use the ~xref-find-definitions~ command, type ~M-.~ (i.e., press
  the period key while holding down the ~META~ key, or else type the
  ~ESC~ key and then type the period key), and then, at the prompt,
  type in the name of the function whose source you want to see, such
  as ~mark-whole-buffer~, and then type ~RET~.  (If the command
  doesn't prompt, invoke it with an argument: ~C-u M-.~; see
  Interactive Options.)

  Emacs will switch buffers and display the source code for the
  function on your screen (If instead of showing the source code for a
  Lisp function, Emacs ask you which tags table to visit, invoke ~M-.~
  from a buffer whose major mode is Emacs Lisp or Lisp interaction.).

  To switch back to your current buffer, type ~M-~, or ~C-c b RET~.
  (On some keyboards, the ~META~ key is labeled ~ALT~.).

- Incidentally, the files that contain Lisp code are conventionally
  called /libraries/.  The metaphor is derived from that if
  specialized library, such as a law library or an engineering
  library, rather than a general library.

  Each library, or file, contains functions that relate to a
  particular topic or activity, such as ~abbrev.el~ for handling
  abbreviations and other typing shortcuts, and ~help.el~ for help.
  (Sometimes several libraries provide code for a single activity, as
  the various ~remail...~ files provide code for reading electronic
  mail.)  In the GNU Emacs Manual, you will see sentences such as "The
  ~C-h p~ commands lets you search the standard Emacs Lisp libraries
  by topic keywords."

** A Simplified ~beginning-of-buffer~ Definition

- The ~beginning-of-buffer~ command is a good function to start with
  since you are likely to be familiar with it and it is easy to
  understand.  Used as an interactive command, ~beginning-of-buffer~
  moves the cursor to the beginning of he buffer command is a good
  function to start with since you are likely to be familiar with it
  and it is easy to understand.  Used as an interactive command,
  ~beginning-of-buffer~ moves the cursor to the beginning of the
  buffer, leaving the mark at the previous position.  It is generally
  bound to ~M-<~.

- In this section, we will discuss a shortened version of the function
  that shows how it is most frequently used.  This shortened function
  work as written, but it does not contain the code for a complex
  option.  In another section, we will describe the entire
  function. (See Complete Definition of ~beginning-of-buffer~)

- Before looking at the code, let's consider what the function
  definition has to contain: it must include an expression that makes
  the function interactive so it can be called by typing ~M-x
  beginning-of-buffer~ or by typing a coached such as ~M-<~; it must
  include code to leave a mark at the original position in the buffer,
  and it must include code to move the cursor to the beginning of the
  buffer.

- Here is the complete text of the shortened version of the function

  #+begin_src emacs-lisp
    (defun simplified-beginning-of-buffer ()
      "Move point to the beginning of the buffer;
              leave mark at previous position."
      (interactive)
      (push-mark)
      (goto-char (point-min)))
  #+end_src

  - Like all the function definitions, this definition has /five/
    parts following the macro ~defun~:

    - The name: in this example, ~simplified-beginning-of-buffer~.

    - A list of arguments; in this example, an empty list, ~()~,

    - The documentation string.

    - The interactive expression

    - The body

- In this function definition, the argument list is empty; this means
  that this function does not require any arguments.  (When we look at
  the definition for the complete function, we will see that it may be
  passed an optional argument.)

- The body of the function consist of the two lines:

  #+begin_src emacs-lisp
    (push-mark)
    (goto-char (point-min))
  #+end_src

  - The first of these line is the expression, ~(push-mark)~.  When
    this expression is evaluated by the Lisp interpreter, it sets a
    mark at the current position of the cursor, wherever that may be.
    The position of this mark is saved in the mark ring.

  - The next line is ~(goto-char (point-min))~.  This expression jumps
    the cursor to the minimum point in the buffer, that is, to the
    beginning of the buffer (or to the beginning of accessible portion
    of the buffer if it is narrowed.  See Narrowing and Widening.)

  - The ~push-mak~ command sets a mark at the place where the cursor
    was located before it was moved to the beginning of the buffer by
    the ~(goto-char (point-min))~ expression.  Consequently, you can,
    if you wish, go back to where you were originally by typing ~C-x
    C-x~.

  - That is all there is to the function definition!.

- When you are reading code such as this and come upon an unfamiliar
  function, such as ~goto-char~, you can find out what it does by
  using the ~describe-function~ command.  To use this command, type
  ~C-h f~ and then type in the name of the function and press ~RET~.
  The ~describe-function~ command will print the function's
  documentation string in a ~*Help*~ window.  For example, the
  documentation for ~goto-char~ is:

  #+begin_src emacs-lisp
    Set point to Position, a number or marker.
    Beginning of buffer is position (Point-min), end is (point-max).
  #+end_src

  - The function's one argument is the desired position.

- The prompt for ~describe-function~ will offer you the symbol under
  or preceding the cursor, so you can typing by positioning the cursor
  right after the function and then type ~C-h f RET~.

- The ~end-of-buffer~ function definition is written in the same way
  as the ~beginning-of-buffer~ definition except that the body of the
  function contains the expression ~(goto-char (point-max))~ in place
  of ~(goto-char (point-min))~.

** The Definition of ~mark-whole-buffer~

- The ~mark-whole-buffer~ function is no harder to understand than the
  ~simplified-beginning-of-buffer~ function.  In this case, however,
  we will look at the complete function, not a shortened version.

- The ~mark-whole-buffer~ function is not as commonly used as the
  ~beginning-of-buffer~ function, but is useful nonetheless; it marks
  whole buffer as a region by putting at the beginning and a mark at
  the end of the buffer. It is generally bound to ~C-x h~.

  - [[An overview of ~mark-whole-buffer~][mark-whole-buffer-overview]]

  - [[Body of ~mark-whole-buffer~][Body of mark-whole-buffer]]

*** An overview of ~mark-whole-buffer~

- In GNU Emacs 22, the code for the complete function looks like this:

  #+begin_src emacs-lisp
    (defun mark-whole-buffer ()
      "Put point at the beginning and mark at end of buffer.
    You probably should not use this function in Lisp programs;
    it is usually a mistake for a Lisp function touse any subroutine
    that mark uses or sets the mark."
      (interactive)
      (push-mark (point))
      (push-mark (point-max) nil t)
      (goto-char (point-min)))
  #+end_src

- Like other functions, the ~mark-whole-buffer~ function fits into the
  template of a function definition. The template looks like this:

  #+begin_src emacs-lisp
    (defun name-of-function (argument-list)
      "documentation..."
      (interactive-expression...)
      body)
  #+end_src

- Here is how the function works: the name of the function is
  ~mark-whole-buffer~; it is followed by an empty argument list,
  '~()~', which means that the function does not require
  arguments. The documentation comes next.

- The next line is an ~(interactive)~ expression that tells Emacs that
  the function will be used interactively.  These details are similar
  to the ~simplified-beginnig-of-buffer~ function described in the
  previous section.

*** Body of ~mark-whole-buffer~

- The body of the ~mark-whole-buffer~ function consist of three lines
  of code:

  #+begin_src emacs-lisp
    (push-mark (point))
    (push-mark (point-max) nil t)
    (goto-char (point-min))
  #+end_src

- The first of these line is the expression, ~(push-mark (point))~.

- The line does not exactly the same job as the first line of the body
  of the ~simplified-beginning-of-buffer~ function, which is written
  ~(push-mark)~.  In both cases, the Lisp interpreter sets a /mark/ at
  the current position of the cursor.

- I don't know why the expression in ~mark-whole-buffer~ is written
  ~(push-mark (point))~ and the expression in ~beginning-of-buffer~ is
  written ~(push-mark)~.  Perhaps whoever wrote the code did not know
  that the argument for ~push-mark~ are optional and that if
  ~push-mark~ is not passed an argument, the function automatically
  sets mark at the location of point by default.  Or perhaps the
  expression was written so as to parallel the structure of the next
  line.  In any case, the line cause Emacs to determine the position
  of point and set a mark there.

- In earlier version of GNU Emacs, the next line of
  ~mark-whole-buffer~ was ~(push-mark (point-max))~.  This expression
  sets a mark at the point in the buffer that has the highest number.
  This will be the end of the buffer (or, if the buffer is narrowed,
  the end of the accessible portion of the buffer. See Narrowing and
  Widening, for more about narrowing.).  After this mark has been set,
  the previous mark, the one set at point, is no longer set, but Emacs
  remembers its position, just all other recent marks are always
  remembered.  This means that you can, if you wish, go back to that
  position by typing ~C-u C-SPC~ twice.

 - In GNU Emacs 22, the ~(point-max)~ is slightly more
   complicated. The line reads

   #+begin_src emacs-lisp
     (push-mark (point-max) nil t)
   #+end_src

- The expression works nearly the same as before.  It sets a mark at
  the highest numbered place in the buffer that it can.  However, in
  this version, ~push-mark~ has two additional arguments.  The second
  argument to ~push-mark~ is ~nil~.  This tells the function it
  /should/ display a message that says "Mark set" when it pushes the
  mark.  The third arguments is ~t~.  This tells ~push-mark~ to
  activate the mark when Transient Mark mode is turned on.  Transient
  Mode highlights the currently active region.  It is often turned
  off.

- Finally, the last line of the function ~(goto-char (point-min))~.
  This written exactly the same way as it is written in
  ~beginning-of-buffer~.  The expression moves the cursor to the
  minimum point in the buffer, that is, to the beginning of the buffer
  (or to the beginning of the accessible portion of the buffer).  As a
  result of this, point is placed at the beginning of the buffer and
  mark is set at the end of the buffer.  The whole buffer is,
  therefore, the region.

** the definition of ~append-to-buffer~

- The ~append-to-buffer~ command is more complex than the
  ~mark-whole-buffer~ command.  What it does is copy the region (that
  is, the part of the buffer between point and mark) from the current
  to a specified buffer.

  - [[An overview of ~append-to-buffer~][append-to-buffer overview]]

  - [[The ~append-to-buffer~ Interactive Expression][append interactive]]       A two part interactive expression

  - [[The Body of ~append-to-buffer~][append-to-buffer body]]                   Incorporates a ~let~ expression

  - [[~save-excursion~ in ~append_to-buffer~][append save-excursion]]           How the ~save-excursion~ works

*** An overview of ~append-to-buffer~

- The ~append-to-buffer~ commands uses the ~insert-buffer-substring~
  function to copy the region.  ~insert-buffer-substring~ is described
  by its name: it takes substring from a buffer, and insert it into
  another buffer.

- Most of ~append-to-buffer~ is concerned with setting up the
  conditions for ~insert-buffer-inserting~ to work: the code must
  specify both the buffer to which the text will go, the window it
  comes from and goes to, and the region that will be copied.

- Here is the complete text of the function

  #+begin_src emacs-lisp
    (defun append-to-buffer (buffer start end)
      "Append to specified buffer the text of the region.
    It is inserted into that buffer before its point.

    When calling from a program, give three argument:
    BUFFER (or buffer name), START and END.
    START and END specify the portion of the current buffer to be copied."
      (interactive
       (list (read-buffer "Append to buffer: " (other-buffer
                                                (current-buffer) t))
             (region-beginning) (region-end)))
       (let (oldbuf (current-buffer)))
       (save-excursion
         (let* (append-to (get-buffer-create buffer))
           (windows (get-buffer-window-list append-to t t))
           point)

         (set-buffer append-to)
         (setq point (point))
         (barf-is-buffer-read-only)
         (insert-buffer-substring oldbuf start end)
         (dolist (window windows)
           (when (= (window-point window) point)
                (set-window-point window (point))))))
  #+end_src

- The function can be understood by looking at it as a series
  filled-in templates.

- The outermost template is for the function.  In this function, it
  looks like this (which several slots filled in):

  #+begin_src emacs-lisp
    (defun append-to-buffer (buffer start end)
      "documentation..."
      (interactive ...)
      body...)
  #+end_src

- The first line of the function includes its name and three
  arguments.  The arguments are the ~buffer~ to which the text will be
  copied, and the ~start~ and ~end~ of the region in the current
  buffer that will be copied.

- The next part of the function is the documentation, which is clear
  and complete.  As is conventional, the three argument are written in
  /upper case/ so you will notice them easily.  Even better, they are
  described in the same order as in argument list.

- Note that the documentation distinguishes between a buffer and its
  name.  (The function can be handler either.)

*** The ~append-to-buffer~ Interactive Expression

- Since the ~append-to-buffer~ function will be used interactively,
  the function must have an ~interactive~ expression.  (For a review
  ~interactive~. see Making Function Interactive.)  The expression
  reads as follows:

  #+begin_src emacs-lisp
    (interactive
     (list (read-buffer
            "Append to buffer: "
            (other-buffer (current-buffer) t))
           (region-beginning)
           (region-end)))
  #+end_src

- This expression is not one with letters standing fort parts, as
  described earlier.  Instead, it starts a list with these parts:

- The first part of the list is an expression to read the name of the
  buffer and return it as a string.  That is ~read-buffer~.  The
  function requires a prompt as its first argument, '~"Append to
  buffer: "~'.  It second argument tells the command what value to
  provide if you don't specific anything.

- In this case that second argument is an expression containing the
  function ~other-buffer~, an exception, and a '~t~', standing for
  true.

- The fist argument to ~other-buffer~, the exception, is yet another
  function, ~current-buffer~.  That is not going to be returned.  The
  second argument is the symbol for true, ~t~.  That tells
  ~other-buffer~ that it may show visible buffers (except in this
  case, it will not show the current buffer, which makes sense).

- The expression looks like this:

  #+begin_src emacs-lisp
    (other-buffer (current-buffer) t)
  #+end_src

- The second and third argument to the ~list~ expression are
  ~(region-beginning)~ and ~(region-end)~.  These two functions
  specify the beginning and end of the text to be appended.

- Originally, the command used the letters '~B~', and '~r~'. The whole
  ~interactive~ expression looked like this:

  #+begin_src emacs-lisp
    (interactive "BAppend to buffer: \nr")
  #+end_src

- But when that was done, the default value of the buffer switched to
  was invisible.  That was not wanted.

- The prompt was separated from the second argument wit a newline,
  '~\n~'.  It was followed by an '~r~' that told Emacs to bind the two
  arguments that follow the symbol ~buffer~ in the function's argument
  list (that is, ~start~ and ~end~) to the values of /point/ and
  /mark/.  That argument work fine.

*** The Body of ~append-to-buffer~

- The body of the ~append-to-buffer~ function begin with ~let~.

- As we have seen before (see ~let~), the purpose of a ~let~
  expression is to create and give initial value to one or more
  variables that will only be used within the body of the ~let~.  This
  meas that such a variable will not be confused with any variable of
  the same time outside the ~let~ expression.

- We can see how the ~let~ expression fits into the function as a
  whole by showing a template for ~append-to-buffer~ with the ~let~
  expression in outline:

  #+begin_src emacs-lisp
    (defun append-to-buffer (buffer start end)
      "documentaion..."
      (interactive ...)
      (let ((variable value))
        body...)
  #+end_src

- The ~let~ expression has three elements:

  1. The symbol ~let~;

  2. A varlist containing, in this case, a single two-element list,
     ~(variable value)~;

  3. The body of the ~let~ expression.

- In the ~append-to-buffer~ function, the varlist looks like this:

  #+begin_src emacs-lisp
    (oldbuf (current-buffer))
  #+end_src

- In this part of the ~let~ expression, he one variable, ~oldbuf~, is
  bound to the value returned by the ~(current-buffer)~ expression.
  The variable, ~oldbuf~, is used to keep track of the buffer in which
  you are working and from which you will copy.

- The element or elements of a varlist are surround by a set of
  parentheses so the Lisp interpreter can distinguish the varlist from
  the body of the ~let~.  As a consequence, the two-element list
  within the varlist is surround by a circumscribing set of
  parentheses.  The line looks like this:

  #+begin_src emacs-lisp
    (let ((oldbuf (current-buffer)))
      ... )
  #+end_src

- The two parentheses before ~oldbuf~ might surprise you if you did
  not realize that the first parenthesis before ~oldbuf~ marks the
  boundary of the varlist and the second parenthesis mark the
  beginning if the two-element list, ~(oldbuf (current-buffer))~
*** ~save-excursion~ in ~append_to-buffer~

- The body of the ~let~ expression in ~append-to-buffer~ consist of a
  ~save-excursion~ expression.

- The ~save-excursion~ function saves the location point, and restores
  it to that position after the expression in the body of the
  ~save-excursion~ complete execution.  In addition, ~save-excursion~
  keeps track of the original buffer, and restore it. This is how
  ~save-excursion~ is *used* in ~append-to-buffer~.

- Incidentally, it is worth noting here that a Lisp function is
  normally formatted so that everything that is enclosed in a
  multi-line spread is indented more to the right than the first
  symbol.  In this function definition, the ~let~ is indented more
  than the ~defun~, and the ~save-excursion~ is indented more than the
  ~let~, like this:

  #+begin_src emacs-lisp
    (defun ...
      ...
      ...
      (let ...
        (save-excursion
          ...
  #+end_src

- This formatting convention makes it easy to see that the lines in
  the body of the ~save-excursion~ are enclosed by the parentheses
  associated with ~save-excursion~, just as the ~save-excursion~
  itself is enclosed by the parentheses associated with the ~let~:

  #+begin_src emacs-lisp
    (let ((oldbuf (current-buffer)))
      (save-excursion
        ...
        (set-buffer ...)
        (insert-buffer-substring oldbuf start end)
        ..))
  #+end_src

- The use of the ~save-excursion~ function can be viewed as process of
  filling in the slots of a template:

  #+begin_src emacs-lisp
    (save-excursion
      first-expression-in-body
      second-expression-in-body
      ...
      last-expression-in-body)
  #+end_src

- In this function, the body of ~save-excursion~ contains only one
  expression, the ~let*~ expression.  You know about a ~let~ function.
  The ~let*~ function is different.  It has '~*~' in its name.  It
  enables Emacs to set each variable in its varlist in *sequence*, one
  after another.

- Its critical feature is that variables later in the varlist can make
  use the value to which Emacs set variables earlier in the
  varlist. See [[][The ~let~ expression]].

- In the old days, the ~set-buffer~ expression was simply

  #+begin_src emacs-lisp
    (set-buffer (get-buffer-create buffer))
  #+end_src

  but now it is

  #+begin_src emacs-lisp
    (set-buffer append-to)
  #+end_src

- ~append-to~ is bound to ~(get-buffer-create buffer)~ earlier on in
  the ~let*~ expression.  That extra binding would not be necessary
  expect for that ~append-to~ is used later in the varlist as an
  argument to ~get-buffer-window-list~.

- The ~append-to-buffer~ function definition inserts text from the
  buffer in which you are currently to a named buffer.  It happens
  that ~insert-buffer-substrig~ does just the reverse--it copies text
  form another buffer to the current buffer-that is why the
  ~append-to-buffer~ definition start out with a ~let~ that binds the
  local symbol ~oldbuf~ to the value returned by ~current-buffer~.

- The ~insert-buffer-substring~ expression looks like this:

  #+begin_src emacs-lisp
    (let (bind-oldbuf-to-value-of-current-buffer)
      (save-excursion                   ; Keep track of buffer
        change-buffer
        insert-substring-from-oldbuf-into-buffer)

      change-back-to-original-buffer-when-finished
      let-the-loca-meaning-of-oldbuf-disappear-when-finshed

  #+end_src

- In summary, ~append-to-buffer~ works as follow: it saves the value
  of the current buffer in the variable called ~oldbuf~.  It gets the
  new buffer (creating one if need be) and switches Emacs's attention
  to it.  Using the value of ~oldbuf~, it inserts the region of text
  from the old buffer into the new buffer: and then using
  ~save-excursion~, it brings you back to your original buffer.

- In looking at ~append-to-buffer~, you can have explored a fairly
  complex function.  It show how to use ~let~ and ~save-excursion~,
  and how to change to and come back from another buffer.  Many
  function definition use ~let~, ~save-excursion~, and ~set-buffer~
  this way.

** Review

Here is a brief summary of the various functions discussed in this chapter.

- ~describe-function~, ~describe-variable~

  Print the documentation for a function or variable. Conventionally
  bound to ~C-h f~ and ~C-h v~:w

- ~xref-find-definition~

  Find the file containing the source for a function or variable and
  switch buffer to it, positioning point at the beginning of the item.
  Conventionally bound to ~M-.~ (that's a period following the ~META~
  key).

- ~save-excursion~

  Save the location of point, and restore its value after the
  arguments to ~save-excursion~ have been evaluated.  Also, remember
  the current buffer and return to it.

- ~push-mark~

  Set mark at a location and record the value of the previous mark on
  the /mark ring/.  The mark is a location in the buffer that will
  keeps its relative position even if text is added to or removed from
  the buffer.

- ~goto-char~

  Set point to the location specified by the value of the argument,
  which can be a number, a marker, or an expression that returns the
  number of a position, such as ~(point-min)~.

- ~insert-buffer-substring~

  Copy a region of text from buffer that is passed to the function as
  an argument and insert the region into the current buffer.

- ~mark-whole-buffer~

  Mark the whole buffer as a region. Normally bound to ~C-x h~

- ~set-buffer~ Switch the attention of Emacs to another buffer, but do
  not change the window being displayed.  Used when the program rather
  than a human is to work on a different buffer.

- ~get-buffer-create~, ~get-buffer~ Find a named buffer or create one
  if a buffer of that name does not exist.  The ~get-buffer~ function
  returns ~nil~ if the named buffer does not exists.


* A Few More Complex Functions

- In this chapter, we build on what we have learned in previous
  chapters by looking at more complex functions.  The ~copy-to-buffer~
  function illustrates use of two ~save-excursion~ expressions in one
  definition, while the ~insert-buffer~ function illustrates use of an
  asterisk in an ~interactive~ expression, use of ~or~, and the
  important distinction between a name and the object to which the
  name refers,

    - [[The Definition of ~copy-to-buffer~][copy-to-buffer]]                    With ~set-buffer~, ~get-buffer-create~.

    - [[The definition of ~insert-buffer~][insert-buffer]]                      Read-only, and with ~or~.

    - [[Complete Definition of ~beginning-of-buffer~][beginning-of-buffer]]     Shows ~goto-char~, ~point-min~, and ~Push-mark~.

    - [[Review][Second buffer Related Review]]

** The Definition of ~copy-to-buffer~

- After understanding how ~append-to-buffer~ to works, it easy to
  understand ~copy-to-buffer~.  This function copies text into a
  buffer, but instead of adding to the second buffer, it replaces all
  the previous text in the second buffer.

- The body of ~copy-to-buffer~ looks like this,

  #+begin_src emacs-lisp
    ...
    (interactive "BCopy to buffer: \nr")
    (let (oldbuf (current-buffer)))
    (with-current-buffer (get-buffer-create buffer)
      (barf-if-buffer-read-only)
      (erase-buffer)
      (save-excursion
        (insert-buffer-substrinh oldbuf start end)))
  #+end_src

  - The ~copy-to-buffer~ function has a simpler ~interactive~
    expression than ~append-to-buffer~.

  - The definition then says

    #+begin_src emacs-lisp
      (with-current-buffer (get-buffser-create buffer) ...
    #+end_src

   - First, look at the earliest inner expression; that is evaluated
     first. That expression start with ~get-buffer-create buffer~.
     The function tells computer to use the buffer with the name
     specified as the one to which you are copying, or if such a
     buffer does not exist, to create it.  Then, the
     ~with-current-buffer~ function evaluates its body with that
     buffer temporarily current.

   - This demonstrates another way to shift the computer's attention
     but not the user's.  The ~append-to-buffer~ function showed how
     to do the same with ~save-excursion~ and ~set-buffer~,
     ~with-current~buffer~ is a newer, and arguably easier, mechanism.

   - The ~barf-if-buffer-read-only~ function sends you an error
     message saying the buffer is read-only if you cannot modify it.

   - The next line has the ~erase-buffer~ function as its sole
     contents.  That function erase the buffer.

   - Finally, the last tow line contain the ~save-excursion~
     expression with ~insert-buffer-substring~ as its body.  The
     ~insert-buffer-substring~ expression copies the text from the
     buffer you are in (and you have not seen the computer shift its
     attention, so you don't know that the buffer is now called
     ~oldbuf~).

   - Incidentally, this is what is meant by "replacement".  To replace
     text, Emacs erase the previous text and insert new text.

   - In outline, the body of ~copy-to-buffer~ looks like this:

     #+begin_src emacs-lisp
       (let (bind-oldbuf-to-value-of-current-buffer)
         (with-the-buffer-you-are-copying-to
          (but-do-not-erase-or-copy-to-a-read-only-buffer)
          (erase-buffer)
          (save-excursion
            insert-substring-from-oldbuf-into-buffer)
     #+end_src

** The definition of ~insert-buffer~

- ~insert-buffer~ is yet another /buffer-related function/.  This
  command copies another buffer /into/ the current buffer.  It is the
  /reverse/ of ~append-to-buffer~ or ~copy-to-buffer~, since they copy
  a region of text /from/ the current buffer to another buffer.

- Here is discussion based on the original code.  The code was
  simplified in 2003 and is harder to understand.

- See [[][New Body for ~insert-buffer~]], to see a discussion of the
  new body.

- In addition, this code illustrates the use of ~interactive~ with a
  buffer that might be /read-only/ and the important distinction
  between the name of an object and the object actually referred to.

- [[The Code for ~insert-code~][insert-buffer code]]

- [[The Interactive Expression in ~insert-buffer~][insert-buffer interactive]]          When you can read, but not write.

- [[The Body of the ~insert~buffer~ Function][insert-buffer body]]                      The body has an ~or~ and a ~let~.

- [[~insert-buffer- with an ~if~ Instead of an ~or~][if & or]]                          Using an ~if~ instead of an ~or~.

- [[The ~or~ in the Body][Insert or]]                                                   How the ~or~ expression works.

- [[The ~let~ Expression in ~insert-buffer~][Insert let]]                               Two ~save-excursion~ expression.

- [[New Body for ~insert-buffer][New insert-buffer]]

*** The Code for ~insert-code~

- Here is the earlier code:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "Insert after point the contents of Buffer.
        Puts mark after the inserted text.
        BUFFER may be a buffer or a buffer name."
      (interactive "*bInsert buffer: ")

      (or (bufferp buffer)
          (setq buffer (get-buffer buffer)))
      (let (start end newmark)
        (save-excursion
          (save-excursion
            (set-buffer buffer)
            (setq start (point-min) end (point-max)))
          (insert-buffer-substring buffer start end)
          (setq newwark (point)))
        (push-mark newmark)))
  #+end_src

- As with other function definitions, you can use a template to see an
  outline of the function:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "documentation.."
      (interactive "*bInsert buffer: ")
      body..)
  #+end_src

*** The Interactive Expression in ~insert-buffer~

- In ~insert-buffer~, the argument to the ~interactive~ declaration
  has two parts, an asterisk, '~*~', and '~bInsert buffer: "~'.

  - [[A Read-only Buffer][Read-only buffer]]                            When a buffer cannot be modified.

  - [['~b~' in an Interactive Expression][b for interactive]]           An existing buffer or else its name.

**** A Read-only Buffer

- The asterisk is for the situation when the current buffer is
  read-only buffer--a buffer that cannot be modified.  If
  ~insert-buffer~ is called when the current buffer is read-only, a
  message to this effect is printed in the echo area and the terminal
  may beep or blink at you; you will not be permitted to insert
  anything into current buffer.  The asterisk does not need to be
  followed by a newline to separate it from the next argument.

**** '~b~' in an Interactive Expression

- The next arguments in the interactive expression start with lower
  case '~b~'.  (This is different from the code for
  ~append-to-buffer~, which uses an upper-case '~B~'.  See [[][The
  Definition of ~append-to-buffer~]].)  The lower-case '~b~' tells the
  Lisp interpreter that the argument for ~insert-buffer~ should be an
  existing buffer or else its name.  (The upper-case '~B~' option
  provides for the possibility that the buffer that does bot exist.)
  Emacs will prompt you for the name of the buffer, offering you a
  default buffer, with name completion enabled.  If the buffer does
  not exist, you receive a message that says "No match"; your terminal
  may beep as you as well.

- The new and simplified code generates a list for ~interactive~.  It
  uses ~barf-if-buffer-ready-only~ and ~read-buffer~ functions with
  which are already familiar ans the ~progn~ special form with which
  we are not.  (It will be described later.)

*** The Body of the ~insert~buffer~ Function

- The body of the ~insert-buffer~ function has two major parts: an
  ~or~ and a ~let~ expression.  The purpose of the ~or~ expression is
  to unsure that the argument ~buffer~ is bound to a buffer and not
  just the name of the buffer.  The body of the ~let~ expression
  contains the code which copies the other buffer into the current
  buffer.

- In outline, the two expression fit into the ~insert-buffer~ function
  like this:

  #+begin_src emacs-lisp
    (defun insert-buffer (buffer)
      "documentation..."
      (interactive "*bInsert buffer: ")
      (or ...
          ...
          (let (varlist)
            body-of-let...)
  #+end_src

- To understand how the ~or~ expression ensures that the argument
  ~buffer~ is bound to a buffer and not the name of a buffer, it is
  first necessary to understand the ~or~ function.

- Before doing this, let me rewrite Thai part of the function using
  ~if~ so that oi can see what is done in a manner that will be
  familiar.

*** ~insert-buffer- with an ~if~ Instead of an ~or~

- The job to be done is to make sure the value of ~buffer~ is a buffer
  itself and not the name of a buffer.  If the value is the name, then
  the buffer itself must be got.A

- You can imagine yourself at a conference where an /usher/ is
  wandering around holding a list with your name on it and looking for
  you: the usher is bound to your name, not to you; but when the usher
  finds you and takes your arm, the usher becomes bound to you.

- In Lisp, you might describe this situation like this:

  #+begin_src emacs-lisp
    (if (not (holding-on-to-guest))
        (find-and-take-arm-of-guest))
  #+end_src

- We want to do the same thing with a buffer--if we do not have the
  buffer itself, we want to get it,

- Using a predicate called ~bufferp~ that tells us whether we have a
  buffer (rather than its name), we can write the code like this:

  #+begin_src emacs-lisp
    (if (not (bufferp buffer))                          ; if-part
        (setq buffer buffer (get-buffer buffer)))       ; then-part
  #+end_src

- Here, the true-or-false-test of the ~if~ expression is ~(mot
  (bufferp buffer))~; and the then-part is the expression ~(setq
  buffer (get-buffer buffer))~

- In the test, the function ~bufferp~ returns true if its argument is
  a buffer--but if its argument is the name of the buffer.  (The last
  character of the function name ~bufferp~ is the character '~p~', as
  we saw earlier, such use of '~p~' is a convention that indicates the
  function is a /predicate/, which is a term that means that the
  function will determine whether some property is true or false.  See
  [Using the Wrong Type Object as an Argument].

- The function ~not~ precedes the expression ~(bufferp buffer)~, so
  the true-or-false-test looks like this:

  #+begin_src emacs-lisp
    (not (bufferp buffer))
  #+end_src

- ~not~ is a function that returns true if its argument is false and
  false if its argument is true.  So if ~(bufferp buffer)~ returns
  true, the ~not~ expression returns false and vice versa.

- Using this test, the ~if~ expression works as follows: when the
  value of the variable ~buffer~ is actually a buffer than its name,
  the true~-or-false-test returns false and the ~if~ expression does
  not evaluate the then-part.  This is fine, since we do not need to
  do anything to the variable ~buffer~ if it really is a buffer.

- On the other hand, when the value of ~buffer~ is not a buffer
  itself, but the name of a buffer, the true-or-false-test returns
  true, and the then-part of the expression is evaluated.  In this
  case, the then-part is ~(setq buffer (get-buffer buffer))~.  This
  expression uses the ~get-buffer~ function to return an actual buffer
  itself, given its name.  The ~setq~ then sets the variable ~buffer~
  to the value of the buffer itself, replacing its previous value
  (which was the name of the buffer).

*** The ~or~ in the Body

- The purpose of the ~or~ expression in the ~insert-buffer~ function
  is to ensure that the argument ~buffer~ is bound to a buffer and not
  just to the name of a buffer.  The previous section shows how the
  job could have been done using ~if~ expression.  However, the
  ~insert-buffer~ function actually use ~or~.  To understand this, it
  is necessary to understand how ~or~ works.

- The ~or~ expression looks like this:

  #+begin_src emacs-lisp
    (or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
  #+end_src

- The first argument to ~or~ is the expression ~(bufferp buffer)~.
  This expression returns true (a non-~nil~ value) if the buffer is
  actually a buffer, and not just the name of a buffer.  In the ~or~
  expression returns this true value and does not evaluate the
  expression--and this is fine with use since we do not want to do
  anything to the value f ~buffer~ if it really is a buffer.

- On the other hand, if the value of ~(bufferp buffer)~ is ~nil~,
  which it will be if the value of ~buffer~ is the name of a buffer,
  the Lisp interpreter evaluates the next element of the ~or~
  expression.  This is the expression ~(setq buffer (get-buffer
  buffer))~.  This expression returns a non-~nil~ value, which is the
  value to which it sets the variable ~buffer~--and this value is a
  buffer itself, not the name of a buffer.

- The result of all this is that the symbol ~buffer~ is always bound
  to a buffer itself rather than to the name of a buffer.  All this is
  necessary because the ~set-buffer~ function in a following line
  only works with a buffer itself, not with the name to a buffer.

- Incidentally, using ~or~, the situation with the usher would be
  written like this:

 #+begin_src emacs-lisp
   (or (holding-on-to-guest) (find-and-take-arm-of-guest))
 #+end_src

*** The ~let~ Expression in ~insert-buffer~

- After ensuring that the variable ~buffer~ refers to a buffer itself
  and not just to the name of a buffer, the ~insert-buffer~ function
  continuous with a ~let~ expression.  This specifies three local
  variables of the same name in Emacs until the end of the ~let~.

- The body of the ~let~ contains two ~save-excursion~ expressions.
  First we will look at the inner ~save-excursion~ expression in
  detail.  The expression looks like this:

  #+begin_src emacs-lisp
    (save-excursion
      (inner-save-excursion-expression
       (go-to-new-buffer-and-set-start-and-end)
       (insert-buffer-substring buffer start end)
       (setq newmark (point)))
  #+end_src

- The ~insert-buffer-substring~ function copies the text /into/ the
  current buffer /from/ the region indicated by ~start~ and ~end~ in
  ~buffer~.  Since the whole of the second buffer lies between ~start~
  and ~end~, the whole of the second buffer is copied into the buffer
  you are editing.  Next, the value of point, which will be at the end
  of the inserted text, is recorded in the variable ~newmark~.

- After the body of the outer ~save-excursion~ is evaluated, point is
  relocated to its original place.

- However, it is convenient to locate a mark at the end of the newly
  inserted text and locate point at the beginning.  The ~newmar~
  variable records the end of the inserted text.  In the last line of
  the ~let~ expression, the ~(push-mark newmark)~ expression function
  sets a mark to this location.  (The previous location of the mark is
  still accessible; it is recorded on the mark ring, and you can go
  back to it with ~C-u SPC~.)  Meanwhile, point is located at the
  beginning of the inserted text, which is where it was before you
  called the insert function, the position of which was saved by the
  first ~save-excursion~.

- The whole ~let~ expression look like this:
  #+begin_src emacs-lisp
    (let (start end newmark)
      (save-excursion
        (save-excursion
          (set-buffer buffer)
          (setq start (point-min) end (point-max)))
        (insert-buffer-substring buffer start end)
        (setq newmark (point)))
      (push-mark newmark))
  #+end_src

- Like the ~append-to-buffer~ function, the ~insert-buffer~ function
  uses ~let~, ~save-excursion~ and ~set-buffer~.  In addition, the
  function illustrates one way to use ~or~.  All the function are
  building blocks that we will find and use again and again.

*** New Body for ~insert-buffer

- The body in the GNU Emacs 22 version is more confusing that the
  original.

-It consist of two expressions,

  #+begin_src emacs-lisp
    (push-mark
     (save-excursion
       (insert-buffer-substring (get-buffer buffer))
       (point)))

    nil
  #+end_src

  except, and this is what confuses novices, very important work is
  done inside the ~push-mark~ expression.

- The ~get-buffer~ function returns a buffer with the name provided.
  You will note that the function is /not/ called ~get-buffer-create~;
  it does not create a buffer if one does not already exist.  The
  buffer returned by ~get-buffer~, an existing buffer, is passed to
  ~insert-buffer-substring~, which inserts the whole of the buffer
  (since you did not specify anything else).

- The location into which the buffer is inserted is recorded by
  ~push-mark~.  Then the function returns ~nil~, the value of its last
  command.  Put another way, the ~insert-buffer~ function exists only
  to produce a side effect, inserting another buffer, not return any
  value.

** Complete Definition of ~beginning-of-buffer~

- The basic structure of the ~beginning-of-buffer~ function has
  already been discussed.  (See [[A Simplified ~beginning-of-buffer~
  Definition]].)  This section describes the complex part of the
  definition.

- As previous described, when invoked without an argument,
  ~beginning-of-buffer~ moves the cursor to the beginning of the
  buffer (in truth, the beginning of the accessible portion of the
  buffer), leaving the mark at the previous position.  However, when
  the command is invoked with a number between one and ten, the
  function considered that number to be a fraction of the length of
  the buffer, measured in tenths and Emacs moves the cursor that
  fraction of the way from the beginning of the buffer.  Thus, you can
  either call this function with the key command ~M-<~, which will
  move the cursor to the beginning of the buffer, or with a key
  command such as ~C-u 7 M-<~ which will move the cursor at a point
  70% of the way through the buffer.  If a number bigger than then us
  used for the argument, it moves to the end of the buffer.

- The ~beginning-of-buffer~ function can be called with or without an
  argument.  The use of the argument is /optional/.

  - [[Optional Arguments][Optional Arguments]]

  - [[~beginning-of-buffer~ with an Argument][beginning-of-buffer opt arg]]             Example with optional argument.

  - [[][beginning-of-buffer complete]]

*** Optional Arguments

- Unless told otherwise, Lisp expects that a function an argument in
  its function definition will be called with a value for that
  argument.  If that does not happen, you get error and a message that
  says '~Wrong number of arguments~'.

- However, optional arguments are feature of Lisp: a particular
  /keyword/ is used to tell the Lisp interpreter that an argument is
  optional.  The keyword is ~&optional~.  (The '~&~' in front of
  '~optional~' is part of the keyword.)  In a function definition, if
  an argument follows the keyword ~&optional~, no value need be passed
  to that argument when the function is called.

- The first line of the function definition of ~beginning-of-buffer~
  therefore looks like this:

  #+begin_src emacs-lisp
- - (defun beginning-of-buffer (&optional arg)
  #+end_src

- In outline, the whole function looks like this:

  #+begin_src emacs-lisp
    (defun beginning-of-buffer (&optional arg)
      "documentation..."
      (interactive "P")
      (or (is-the-argument-a-cons-cell arg)
          (and are-both-transient-mark-mode-and-mark-active-true)
          (push-mark))
      (let (deterimine-size-and-set-it)
        (goto-char
         (if-there-is-an-agument
          figure-out-where-to-go
          else-go-told
          (point-min))))
      do-nicety
  #+end_src

- The function is similar to the ~simplified-beginning-of-buffer~
  function except that the ~interactive~ expression has "~p~" as an
  argument and the ~goto-char~ function is followed by an if-then-else
  expression that figure out where to put the cursor if there is an
  argument that is not a cons cell.

- The ~"P"~ in the ~interactive~ expression tells Emacs to pass a
  /prefix argument/, if there is one, to then function in raw from.  A
  prefix argument is made by typing the ~META~ key followed by a
  number, or by typing ~C-u~ and then a number.  (If you type don't
  type a number, ~C-u~ defaults to a cons cell with a 4.  A lowercase
  ~"p" in the ~interactive~ expression causes the function to convert
  a prefix arg to number.)

- The true-or-false-test of the ~if~ expression looks complex, but it
  is not; it checks whether ~arg~ has a value that is not ~nil~ and
  whether it is a cons sell.  (That is what ~constp~ does; it checks
  whether its argument is a cons cell.)  If ~arg~ has a value that is
  not ~nil~ (and is not a cons cell), which will be the case if
  ~beginning-of-buffer~ is called with a numeric argument, then this
  true-or-false-test will return true and then-part of the ~if~
  expression will be evaluated.  On the other had, if
  ~beginning-of-buffer~ is not called with an argument, the value
  ~arg~ will be ~nil~ and the else-part of the ~if~ expression will be
  evaluated.  The else-part is simply ~point-min~, and when this is
  the outcome, the whole ~goto-char~ expression is ~(goto-char
  (point-min))~, which is how we the ~beginning-of-buffer~ function in
  its simplified form.

*** ~beginning-of-buffer~ with an Argument

- When ~beginning-of-buffer~ is called with an argument, an expression
  is evaluated which calculates what value to pass to ~goto-char~.
  This expression is rather complicated at first sight.  It includes
  an inner ~if~ expression and much arithmetic.  It look like this:

  #+begin_src emacs-lisp
    (if (> (buffer-size) 10000)
        ;; Avoid overflow for large buffer sizes!
        (* (prefix-numeric-value arg)
           (/ size 10)
           (/
            (+ 100%
               (* size (prefix-numeric-value arg))) 10)))
  #+end_src

  - [[Disentangle ~beginning-of-buffer~][Disentangle beginning-of-buffer]]

  - [[What happen in a large buffer][Large buffer case]]

  - [[What happen in a small buffer][Small buffer case]]

**** Disentangle ~beginning-of-buffer~

- Like other complex-looking expression, the conditional expression
  within ~beginning-of-buffer~ can be disentangled by looking at it as
  parts of a template, in this case, the template for an if-then-else
  expression.  In skeletal form, the expression looks like this:

  #+begin_src emacs-lisp
    (if (buffer-is-large
         divide-buffer-size-by-10-and-multiply-by-arg
      else-use-alternate-calculation
  #+end_src

- The true-or-false-test of this inner ~if~ expression checks the size
  of the buffer.  The reason for this is that the old version 18 Emacs
  used numbers that are no bigger than eighth million or so and in the
  computation that followed, the programmer feared that Emacs might
  try to use over-large numbers if the buffer were large.  The term
  "overflow", mentioned in the comment, means numbers that are over
  large.  More recent version of Emacs use large numbers, but this
  code has not been touched, if only because people now look at buffer
  that are far, far larger than ever before.

- there are two cases: if the buffer is large and if it is not.

**** What happen in a large buffer

- In ~beginning-of-buffer~, the inner ~if~ expression test whether the
  size of the buffer is greater than 10,000 characters.  To do this,
  it uses the ~>~ function and the computation of ~size~ that comes
  from the let expression.

- In the old days, the function ~buffer-size~ was used.  Not only was
  the function called several times, it gave the size of the whole
  buffer, not the accessible part.  The computation makes much more
  sense when it handles just the accessible part.  (See [[][Narrowing
  and Widening]], for more information on focusing attention to an
  accessible part.)

- the line looks like this:
  #+begin_src emacs-lisp
    (if (> size 10000)
  #+end_src

- When the buffer is large is large, the then-part of the ~if~
  expression is evaluated.  It reads like this (after formatting for
  easy reading):

  #+begin_src emacs-lisp
    (*
     (prefix-numeric-value arg)
     (/ size 10))
  #+end_src

  this expression is multiplication, which with two arguments to the
  function ~*~

- The first argument is ~(prefix-numeric-value arg)~.  When ~"p"~ is
  used as the argument for ~interactive~, the value passed to the
  function as its argument is passed a ~raw prefix argument~, and not
  a number.  (It is a number list.) To perform the arithmetic, the
  conversion is necessary, and ~prefix-numeric-value~ does the job.

- The second argument is ~(/ size 10)~.  This expression divides the
  numeric value by ten--the numeric value of the size of the
  accessible portion of the buffer.  This produces a number that tells
  how many characters make up one tenth of the buffer size.  (in Lisp,
  ~/~ is used for division, just as ~*~ is used for multiplication.)

- In the multiplication expression as a whole, this amount is
  multiplied by the value of the prefix argument--the multiplication
  looks like this:

  #+begin_src emacs-lisp
    (* numeric-value-of-prefix-arg
       number-of-characters-in-one-tenth-of-the-accessible-buffer)
  #+end_src

- If, for example, the prefix argument is ~'7~', the one-tenth value
  will be multiplied by 7 to give a position 70% of the way through.

- The result of all this is that the accessible portion of the buffer
  is large, the ~goto-char~ reads like this:

  #+begin_src emacs-lisp
    (goto-char (* (prefix-numeric-value arg)
                  (/ size 10)))
  #+end_src

  This put the cursor where we want it.

**** What happen in a small buffer

- Here  is the complete text of the ~beginning-of-buffer~ function:


  #+begin_src emacs-lisp
    (defun beginning-of-buffer (&optional arg)
      "Move point to the beginning of the buffer;
    leave mark atprevious position.
    with \\[universal-argument] prefix,
    do not set mark at previous position.  With numeric org N,
    put point N/10 of the way from the beginning

    If the buffer is narrowed,
    this command uses the beginning and
    size of the accessible part of the buffer.

    Don't use tis command in Lisp program!
    \(go-char (point-min)) is faster
    and avoids clobbering the mark."
      (interactive "P")
      (or (consp arg)
          (and transient-mark-mode-mark-active)
          (push-mark))
      (let ((size (- (point-max) (point-min)))
            (goto-char (if (and arg (not (consp arg)))
                           (+ (point-min)
                              (if (> size 10000)
                                  ;; avoid oveflow for large buffer sizes!
                                  (* (prefix-numeric-value-org)
                                     (/ size 10))
                                (/ (+ 10 (* size (prefix-numeric-value arg)))
                                   10)))
                         (point-min))))
        (if (and arg (not (consp arg))) (forward-line 1)))
    #+end_src

- Except for two small points, the previous discussion shows how this
  function works.  The first point deals with a detail in the
  documentation string, and the second point concerns the last line of
  the function.

- In the documentation string, there is reference to an expression:

  #+begin_src emacs-lisp
    \\[universal argument]
  #+end_src

- A '~\\~\ is used before the first square bracket of this expression.
  This '~\\~' tells the lisp Interpreter to substitute whatever key is
  currently bound to the '~[...]~'.  In this case of
  ~universal-argument~, that is usually ~C-u~, but it might be
  different.  (See [[][Tips for Documentation Strings]] in the GNU
  Emacs Lisp Reference Manual, for more information.)

- Finally, the last line of the ~beginning-of-buffer~ commands says to
  move point to the beginning of the next line if the command is
  invoked with an argument:

  #+begin_src emacs-lisp
    (if (and arg (not (consp arg))) (forward-line 1))
  #+end_src

- This puts the cursor at the beginning of the first line after the
  appropriate tenths position in the buffer.  This is flourish that
  means that the cursor is always located /at least/ the requested
  tenths of the way through the buffer, which is a nicety that is,
  perhaps, not necessary, but which, if it did not occur, would be
  sure to draw complaints.  (The ~(not (consp arg))~ portion is so
  that if you specify the command with a ~C-u~, but without a number,
  that is to say, if the raw prefix argument is simply, a cons cell,
  the command does not put your at the beginning of the second line.)

** Review

- ~or~

  evaluates each argument in sequence, and return the value of the
  first argument that is nor ~nil~; if none return a value that is not
  ~nil~, return ~nil~.  In brief, return the first value of the
  arguments; return a true value of one ~or~ any of the others are
  true.

- ~and~

  Evaluate each argument in sequence, and if any are ~nil~, return
  ~nil~; if none are ~nil~, return the value of the last argument.  In
  brief, return a true value only if all the arguments are true;
  return a true value if one ~nad~ of the others is true.

- ~&optional~

  A keyword used to indicated that an argument to a function
  definitions is optional; this meas that the function can be
  evaluated without the argument, if desired.

- ~prefix-numeric-value~

  Convert the raw prefix argument produced by ~(interactive "P")~ to a numeric value.

- ~forward-line~

  Move point forward to the beginning of the next line, or if the
  argument is greater than one, forward that many lines.  If it can't
  move as far forward as it supposed to, ~forward-line~ goes forward
  as far it can and then returns a count of the number of additional
  lines it was supposed to move but couldn't.

- ~erase-buffer~

  Delete the entire contents of the current buffer.

- ~bufferp~

  Returns ~t~ if its argument is a buffer; otherwise return ~nil~.


* The Advantage of Narrowing

- Narrowing is a feature of Emacs that makes it possible for you to
  focus on a specific part of buffer, and work without accidentally
  changing other parts.  Narrowing is normally disabled since it can
  confuse novices.

  - [[The Advantages of Narrowing][Narrowing advantages]]               The advantages of narrowing.

  - [[The ~save-restriction~ Special Form][save-restriction]]           The ~save-restriction~ special form.

  - [[~what-line~][what-line]]                                          The number of the line that point is on.

** The Advantages of Narrowing

- With narrowing, the rest of a buffer is made invisible, as if
  weren't there.  This is an advantage if, for example, you want to
  replace a word in one part of a buffer but not in another; you
  narrow to the part you want and the replacement is carried out only
  in that section, not in the rest of the buffer.  Searches will only
  work within a narrowed region, not outside of one, so if you are
  fixing a part of a document, you can keep yourself from accidentally
  finding parts you do not need to fix by narrowing just to the region
  you want. (the key binding for ~narrow-to-region~ is ~C-x n n~.)

- However, narrowing does make the rest of the buffer invisible, which
  can scare people who inadvertently invoke narrowing and think they
  deleted a part of their file.  Moreover, the ~undo~ command (which
  is usually bound to ~C-x u) does not turn off narrowing (nor should
  it), so people can become desperate if they do not know that they
  can return the rest of a buffer to visibility with the ~widen~
  command.  (The key binding for ~widen~ is ~C-x n w~.)

- Narrowing is just as useful to the lisp interpreter as to human.
  Often, an Emacs Lisp function is designed to work on just part of a
  buffer, it has any narrowing and when it has finished its job,
  restores the narrowing to what it was. On the other hand, the
  ~count-lines~ function uses narrowing to restrict uses narrowing to
  restrict it self to just that portion of the buffer in which it is
  interested and then restores the previous situation.

** The ~save-restriction~ Special Form

- In Emacs Lisp, you can use the ~save-restriction~, special form to
  keep track whatever narrowing is in effect, if any.  When the Lisp
  interpreter meets with ~save-restriction~, it executes the code in
  the body of the ~save-restriction~ expression, and then undoes any
  changes to narrowing that the code caused.  If, for example, the
  buffer is narrowed and the code that follows ~save-restriction~ gets
  rid of the narrowing, ~save-restriction~ gets rid of the narrowing,
  ~save-restriction~ return the buffer to its narrowed region
  afterwards.  In the ~what-line~ command, any narrowing the buffer
  may have is undone by the ~widen~ command that immediately follows
  the ~save-restriction~ command.  Any original narrowing is restored
  just before the completion of the function.

- The template for a ~save-restriction~ expression is simple:

  #+begin_src emacs-lisp
    (save-restriction
      body...)
  #+end_src

- The body of the ~save-restriction~ is one or more expression that
  will be evaluated in sequence by the Lisp interpreter.

- Finally, a point to note: when you use both ~save-excursion~ and
  ~save-restriction~, one right after the other, you should use
  ~save-excursion~ outermost.  If you write them in reverse order, you
  may fail to record narrowing in the buffer to which Emacs switches
  after calling ~save-excursion~.  Thus, when written together,
  ~save-excursion~ and ~save-restriction~ should be written like this:

  #+begin_src emacs-lisp
    (save-excursion
      (save-restriction
        body...))
  #+end_src

- In other circumstances, when not to written together, the
  ~save-excursion~ and ~save-restriction~ special form must be written
  in the order appropriate to the function.

- For example,

  #+begin_src emacs-lisp
    (save-restriction
      (widen)
      (save-excursion
        body..))
  #+end_src
** ~what-line~

- The ~what-line~ command tells you the number of the line in which
  the cursor is located.  The function illustrate the use of the
  ~save-restriction~ and ~save-excursion~ commands. Here is the
  original text of the function:

  #+begin_src emacs-lisp
    (defun what-line ()
      "Print the current line number (in the buffer) of point."
      (interative)
      (save-excursion
        (beginning-of-line)
        (message "Line %d"
                 (1+ (count-lines 1 (point)))))
  #+end_src

- (In recent version of GNU Emacs, the ~what-line~ function has been
  to tell you your line number in a narrowed buffer as well as your
  line in a widened buffer.  The recent version is more complex than
  version shown here.  If you fell adventurous, you might to look it
  after figuring out how this version works.  You will probably need
  to use ~C-h f (describe-function)~.  The newer version uses a
  conditional to determine the buffer has been narrowed.

- (Also, it uses ~line-number-at-pos~, which among other simple
  expressions, such as ~(goto-char (point-min))~, moves point to the
  beginning of the current line with ~(forward-line 0)~, rather than
  ~beginning-of-line~.)

- The ~what-line~ function as shown here has a documentation line and
  is interactive, as you would expect.  The next two lines use the
  function ~save-restriction~ and ~widen~.

- The ~save-restriction~ special form notes whatever narrowing is an
  effect, if any, in the current buffer and restores that narrowing
  after code in the body of the ~save-restriction~ has been evaluated.

- The call to ~widen~ is followed by ~save-excursion~, which saves the
  location of the cursor (i.e of point(, and restores it after the
  code in the body of the ~save-excursion~ uses the
  ~beginning-of-line~ function to move point.

- (Note that the ~(widen)~ expression comes between the
  ~save-restriction~ and ~save-excursion~ special forms.  When you
  write the two ~save- ...~ expression in sequence, write
  ~save-excursion~ outermost.)

- The last two lines of the ~what-line~ function are functions to
  count the number of lines in the buffer and then print the number in
  the echo area.

  #+begin_src emacs-lisp
    (message "Line %d"
             (1+ (count-lines 1 (point)))))
    #+end_src

- The ~message~ function prints a one-line message at the bottom of
  the Emacs screen.  The first argument is inside of quotation marks
  and id printed as a string of characters.  However, it may contain a
  '~%d~' prints the argument. '~%d~' prints as a decimal, so the
  message will say something such as ~'line 243'~.

- The number that is printed in place of the '~%d~' is computed by the
  last line of the function:

  #+begin_src emacs-lisp
    (1 + (count-lines 11 (point)))
  #+end_src

- What this does count is count the lines from the first position of
  the buffer, indicated by the ~1~, up to ~(point)~, and then add one
  to that number.  (The ~1+~ function adds one to its argument.) We
  add one to it because line 2 has only one line before it, and
  ~count-lines~ counts only the lines /before/ the current line.

- After ~count-lines~ has done its job, and the message has been
  printed in the echo area, the ~save-excursion~ restore point to its
  original position; and ~save-restriction~ restores the original
  narrowing, if any.

** Strange Name
- The name of the ~cons~ function is not unreadable: it is not an
  abbreviation of the word "construct".  The origins of the name for
  ~car~ and ~cdr~ on the other hand, are esoteric: ~car~ is acronym
  from the phrase "Contents of the Address part of the Register": and
  ~cdr~ (pronounced "could-er") is an acronym from the phrase
  "Contents of the Decrement part of the Register".  These phrases
  refer to specific pieces of hardware on the early computer on which
  the original Lisp was developed.  Besides being obsolete, the
  phrases have been completely irrelevant for more 25 years to anyone
  thinking about Lisp.  Nonetheless, although a few brave scholars
  have begun to use more reasonable names for these functions, the old
  term are still in use.  In particular, since the terms are used in
  the Emacs lisp source code, we will use them in this introduction.

** ~car~ and ~cdr~

- The CAR of list is ,quite simply, the first item in the list.  Thus
  CAR of the list ~(rose violet daisy buttercup)~ is ~route~.

- If you reading this info in GNU Emacs, you can see this by
  evaluating the following:

  #+begin_src emacs-lisp
    (car '(rose violet daisy buttercup))
  #+end_src

- After evaluating the expression, ~rose~ will appear in the echo area.

- Clearly, a more reasonable names for the ~car~ function would be
  ~first~ and this is often suggested.

- ~car~ does not remove the first item from the list; it only reports
  what it is.  After ~car~ has been applied to a list, the list is
  still the same as it was.  In the jargon, ~car~ is
  "non-destructive".  This feature of the list, the value returned by
  the ~cdr~ function, is ~(violet daisy buttercup)~.

  #+begin_src emacs-lisp
    (cdr '(rose violet daisy buttercup))
  #+end_src

- When you evaluates this, ~(violet daisy buttercup))~ will appear in
  the echo area.

- Incidentally, in the example, the list of the flowers is quoted.  If
  it were not, the Lisp interpreter wold try to evaluate the list by
  calling ~rose~ as a function.  In this example, we do not want to do
  that.

- Clearly, a more reasonable names for ~cdr~ would be ~rest~.

- (*There is a lesson here*: when you name a new function, consider
  very carefully what you are doing, since you may be stuck with the
  names for far longer than you expect.  The reason this document
  perpetuates these names is that the Emacs Lisp source code uses
  them, and if I did not use them, you would have a hard time reading
  the code; but do, please, try to avoid using these terms
  yourself. The people who come after you will be grateful to you.)

- When ~car~ and ~cdr~ area applied to a list made up of symbols, such
  as the list ~(pine fir oak maple)~, the element of the list returned
  by the function ~car~ is the symbol ~pine~ without parentheses
  around it.  ~pine~ is the first element in the list.  However, the
  CDR of the list is a list itself, ~(fir oak maple)~, as you can set
  by evaluating the following expressions in th usual way:

  #+begin_src emacs-lisp
    (car '(pine fir oak maple))

    (cdr '(pine fir oak maple))
  #+end_src

- On the other hand, in a list of list, the first element is itself a
  list ~car~ returns this first element as a list.  For example, the
  following list contains three sub-lists, a list of carnivores, a
  list of herbivores and a list of sea mammals:

  #+begin_src emacs-lisp
    (car '((lion tiger cheetah)
           (gazelle antelope zebra)
           (whale dolphin seal)))
  #+end_src

- In this example, the first element or CAR of the list is the list of
  carnivores, ~(lion tiger cheetah)~, and the rest of the list is
  ~((gazelle antelope zebra) (whale dolphin seal))~.

- It is worth saying again that ~car~ and ~cdr~ are
  *not-destructive--that* is, they do not modify or change lists they
  area applied.  This very important for how they are used.

- Also, in the first chapter, in the discussion about atoms, I said
  that in Lisp, certain kinds of atom, such as an /array/ can be
  separated into parts; but the mechanism for doing this is different
  from the mechanism for splitting a list.  As far as Lisp is
  concerned, the atoms of a list are unsplittable.  (See [[][Lisp
  Atoms]]) The ~car~ and ~cdr~ functions are used for *splitting
  lists* and are considered fundamental to Lisp.  Since they cannot
  split or gain access to the parts of an array, an array is
  considered an atom.  Conversely, the other fundamental, ~cons~, can
  put together or construct a list, but not an array.  (Arrays are
  handled by array-specific functions.  See [[][Arrays]] in the GNU
  Emacs Lisp Reference Manual.)

** ~cons~

- The ~cons~ function construct lists; it is the inverse of ~car~ and
  ~cdr~.  For example, ~cons~ can be to make a four element list from
  the three element list, ~(fir oak maple)~

  #+begin_src emacs-lisp
    (cons 'pine '(fir oak maple))
  #+end_src

- After evaluating this list, you will see

  #+begin_src emacs-lisp
    (pines fir oak maple)
  #+end_src

- We often say that ~cons~ puts a new element at the beginning of a
  list, or that it attaches or pushes element onto the list, but this
  phrasing can be misleading, since ~cons~ does /not change an
  existing list/, but /creates/ a new one.

- Like ~car~ and ~cdr~, ~cons~ is non-declarative.

  - [[Build a list][Builds list]]

  - [[Find the Length of a List: ~length~][length]]             How to find the length of a list.

*** Build a list

- ~cons~ must have a list to attach to.  You cannot start from
  absolutely nothing.  If you are building a list, you need to provide
  at least an empty list at the beginning.  Here is a series of ~cons~
  expressions that build up a list of flowers.  If you are reading
  this Info in GNU Emacs, you can evaluate each of the expression in
  the usual way; the value is printed in this text after '~⇒~’, which
  you may read as "evaluates to".

  #+begin_src emacs-lisp
    (cons 'buttercup ())
    ⇒ (butterup)

    (cons 'daisy '(buttercup))
    ⇒ (daisy buttercup)

    (cons 'violet '(daisy buttercup))
    ⇒ (violet daisy buttercup)

    (cons 'rose '(violet daisy buttercup))
    ⇒ (rose daisy buttercup)
  #+end_src

- In the first example, the empty list is shown as ~()~ and list made
  up of ~buttercup~ followed by the empty list is constructed.  As you
  can see, the empty list is not shown in the list that was
  constructed. All that you see is ~(buttercup)~.  The empty list is
  not counted as an element of a list because there is nothing in an
  empty list.  Generally speaking, an empty list is invisible.

- The second example, ~(cons 'daisy '(buttercup))~ construct a new,
  two element list by putting ~daisy~ in front of ~buttercup~; and the
  third example construct a three element list by putting in front of
  ~daisy~ and ~buttercup~.

*** Find the Length of a List: ~length~

- You can find out how many elements there are in a list by using the
  Lisp function ~length~, as in the following examples:

  #+begin_src emacs-lisp
    (length '(buttercup))
    ⇒ 1

    (length '(daisy buttercup))
    ⇒ 2

    (length '(cons 'violet '(daisy buttercup)))
    ⇒ 3
  #+end_src

- In the third example, the ~cons~ function is used to construct a
  three element which is then passed to the ~length~ function as its
  argument.

- We can also use ~length~ to count the number of elements in an empty list:

  #+begin_src emacs-lisp
    (length ())
    ⇒
  #+end_src

- As you would expect, the number of elements in apply list is zero.

- An interesting experiment is to find out what happens if you try to
  find the length of no list at all; that is, if you try to call
  ~length~ without giving it an argument, not even an empty list:

  #+begin_src emacs-lisp
    (length )
  #+end_src

** ~nthcdr~

- The ~nthcdr~ function is associated with the ~cdr~ function.  What
  it does is take the CDR of a list repeatedly.

- If you take the CDR of the list ~(pine fir oak maple)~, you will be
  returned the list ~(fir oak maple)~.  If you repeat this on what was
  returned, you will be returned the list ~(oak maple)~.  (Of course,
  repeated CDRing on the original list will just give the original CDR
  since the function does not change th list.  You need to evaluate
  the CDR of the CDR and so on.)  If you continue this, eventually you
  will be returned an empty list, which in this case, instead of being
  shown as ~()~ is shown as ~nil~.

- For review, here is a series of repeated CDRs, the text following
  the '~⇒~' shows what returned.

  #+begin_src emacs-lisp
    (cdr '(pine fir oak maple))
    ⇒ (fir oak maple)

    (cdr '(fir oak maple))
    ⇒ *(oak maple)

    (cdr '(oak maple))

    ⇒ (maple)

    (cdr '(maple))
    ⇒ nil

    (cdr 'nil)
    ⇒ nil

    (cdr ())
    ⇒ nil
  #+end_src

- You can also do several CDRs without printing the values in between,
  like this:

  #+begin_src emacs-lisp
    (cdr (cdr '(pine fir oak maple)))
    ⇒ (oak maple)
  #+end_src

- In this example, the Lisp interpreter evaluates the innermost list
  quoted, so it just passes the list as it is to the innermost ~cdr~.
  This ~cdr~ passes a list made up of the second and subsequent
  element of the list to the outermost ~cdr~, which produces a list
  composed of the third and subsequent elements of the original list.
  In this example, the ~cdr~ function is repeated and returns a list
  that consists of the original list without its first two element.

- The ~nthcdr~ function does the same thing as repeating the call to
  ~cdr~.  In the following example, the argument 2 is passed to the
  function ~nthcdr~, along with the list, and the value returned is
  the list without its first two items, which is exactly the same as
  repeating ~cdr~ twice on the list:

  #+begin_src emacs-lisp
    (nthcdr 2 '(pine fir oak maple))
    ⇒ (oak maple)
  #+end_src

- Using the original four elements list, we can see what happens when
  various numeric arguments are passed to ~nthcdr~, including 0, 1, and 5:

  #+begin_src emacs-lisp
    ;; leave the list as it was.
    (nthcdr 0 ' (pine fir oak maple))
    ⇒ (pine fir oak maple)

    ;; Return a copy without the first element.
    (nthcdr 1 '(pine fir oak maple))
    ⇒ (fir oak maple)

    ;; Return a copy of the list without three elements
    (nthcdr 3 '(pine fir oak maple))
    ⇒ (maple)

    ;; Return a copy lacking all four elements
    (nthcdr 4 '(pine fir oak maple))
    ⇒ ()

    ;; Return a copy lacking all elements
    (nthcdr 5 '(pine fir oak maple))
    ⇒ nil
  #+end_src

** ~nth~

- The ~nthcdr~ function takes the CDR of a list repeatedly.  The ~nth~
  function takes the CAR of the result returned by ~nthcdr~.  It
  returns the Nth element of the list.

- Thus, if it were not defined in C for speed, the definition of ~nth~
  would be:

  #+begin_src emacs-lisp
    (defun nth (n list)
      "Return the Nth element of LIST.
    N count from zero.  If LIST is not that long, nil is returned."
      (car (nthcdr n list)))
  #+end_src

- (Originally, ~nth~ was defined in Emacs Lisp in ~subr.el~, but its
  definition was redone in C in the 1980s.)

- The ~nth~ function returns a single element of a list.  This can be
  very convenient.

- Note that the elements are numbered from *zero*, not one.  That is
  to say, the first element of a list, its CAR is the zeroth element.
  This zero-based counting often bothers people who are accustomed to
  the first element in a list bring number one, which is one-based.

- For example:

  #+begin_src emacs-lisp
    (nth 0 '("one" "two" "three"))
    ⇒ "one"

    (nth 1 '("one" "two" "three"))
    ⇒ "two"
  #+end_src

- It is worth mentioning that ~nth~, like ~nthcdr~ and ~cdr~m does
  change the original list--the function is non-destructive.  This in
  sharp contrast to the ~setcar~ and ~setcdr~ functions.
** ~setcar~

- As you might guess from their names, the ~setcar~ and ~setcdr~
  functions set the CAR or the CDR of a list, to a new value.  The
  actually change the original list, unlike ~car~ and ~cdr~ which
  leave the original list at it was.  One to find way out how this
  works is to experiment.  We will start with the ~setcar~ function.

- First, we can  make a list and  then set the value of  a variable to
  the list, using  the ~setq~ special form.  Because we  intend to use
  ~setcar~ to change  the list, this ~setq~ should not  use the quoted
  form ~'(antelope  girrafe lion tiger)~,  as that would yield  a list
  that is part of the program and  bad things could happen if we tried
  to change part of the  program while running.  Generally speaking an
  Emacs Lisp  program's components  should be constant  (or unchanged)
  while the  program is  running.  So we  instead construct  an animal
  list by using the ~list~ function, as follows:

  #+begin_src emacs-lisp
    (setq animals (list 'antelope 'girafe 'lion 'tiger))
  #+end_src

- If you are reading this in Info inside of GNU Emacs, you can
  evaluate this expression in the usual fashion, by positioning the
  cursor after the expression and typing ~C-x C-e~.  (I'm doing right
  here as I write this.  This is one of the advantages of having the
  interpreter built into the computing environment.  Incidentally,
  when there is nothing on the line after the final parentheses, such
  as a comment, point can be on the next line. Thus, if your cursor is
  in the first column of the next line, you do not need to move it.
  Indeed Emacs permits any amount of white space after the final
  parenthesis.)

- When evaluate the variable ~animals~, we can see that it is bound to
  the list ~(antelope giraffe lion tiger)~:

  #+begin_src emacs-lisp
       animals
    ⇒ (antelope giraffe lion tiger)
  #+end_src

- Put another way the variable ~animals~ points to the list ~(antelope
  giraffe lion tiger)~.

- Next, evaluate the function ~setcar~ while passing it two arguments,
  the variable ~animals~ and the quoted symbol ~hippopotamus~; this is
  done by writing the three element list ~(setcar animals
  'hippopotamus)~ and then evaluating it in the usual fashion:

  #+begin_src emacs-lisp
    (setcar animals 'hippopotamus)
  #+end_src

- After evaluating this expression, evaluate the variable ~animals~
  again.  You will see that the list of animals has changed:

  #+begin_src emacs-lisp
    animals
    ⇒ (hippopotamus giraffe lion tiger)
  #+end_src

- The first element on the list, ~antelope~ is replaced by
  ~hippopotamus~.

- So we can see that ~setcar~ did not add new element to the list as
  ~cons~ would have; it replaced ~antelope~ with ~hippopotamus~; it
  /changed/ the list.
** ~setcdr~

- The ~setcdr~ function is similar to the ~setcar~ function, except
  that function replaces the second and subsequent elements of a list
  rather than the first element.

- (To see how to change the last element of a list, look to [[][The
  ~kill~new~ function]] which uses the ~nthcdr~ and ~setcdr~
  functions.)

- To see how this works, set the value of the variable to a list of
  domesticated animals by evaluating the following expression:

  #+begin_src emacs-lisp
    (setq domesticated-animals (list 'horse 'cow 'sheep 'goat))
  #+end_src

- If you now evaluate the list, you will be returned the list ~(horse
  cow sheep goat)~:

  #+begin_src emacs-lisp
    domesticated-animals
    ⇒ (horse cow sheep goat)
  #+end_src

- Next, evaluate ~setcdr~ with two argument, the name of the variable
  which has a list as its value, and the list to which the CDR of the
  first list will be set;

  #+begin_src emacs-lisp
    (setcdr domesticated-animals '(cat dog))
  #+end_src

- If you evaluate this expression, the list ~(cat dog)~ will appear in
  the echo area.  This is the value returned by the function.  The
  result we are interested is the side effect, which we can see by
  evaluating the variable ~domesticated-animals~:

  #+begin_src emacs-lisp
    domisticated-animals
    ⇒ (horse cat dog)
  #+end_src

- Indeed, the list changed from ~(horse cow sheep goat)~ to ~(horse
  cat dog)~.  The CDR of the list is changed from ~(cow sheep goat)~
  to ~(cat dog)~.


* Cutting and Storing Text

- Whenever you cut or clip text out of buffer with a /kill/ command in
  GNU Emacs, it is stored in a list and you can bring it back with a
  /yank/ command.

- (The use of the word "kill" in Emacs for process which specifically
  /do not/ destroy the value of the entities is an unfortunate
  historical accident. A much more appropriate word would be "clip"
  since that is the kill commands do; they clip text out of buffer and
  put it into storage from which it can be brought back.  I have often
  been tempted to replace globally all occurrences of "kill" in the
  Emacs source with "clip" and all occurrences o "killed" with
  "clipped").

  - [[Storing Text in a List][Storing Text]]                    Text is stored in a list

  - [[~zap-to-char~][zap-to-char]]                              Cutting out text up to character

  - [[~kill-region~][kill-region]]                              Cutting text out of a region

  - [[~copy-region-as-kill~][copy-to-region-as-kill]]           A definition for copying text

  - [[Digression into C][Digression into C]]                    Minor note on C programming language macros

  - [[Initializing a Variable with ~defvar~][defvar]]           How to give a variable an initial value

  - [[Review][cons & search-fwd Review]]                        How to give a variable an initial value

** Storing Text in a List

- When text is cut out of a buffer, it is stored on a list.
  Successive pieces of text are stored on the list successively, so
  the list might look like this:

  #+begin_src emacs-lisp
    ("a piece of text" "previous piece")
  #+end_src

- The function ~cons~ can be used to create a new list from a piece of
  text (an "atom", to use the jargon) and an existing list, like this:

  #+begin_src emacs-lisp
    (cons "another piece"
          '("a piece of text" "previous piece"))
  #+end_src

- If you evaluate this expression, a list of three elements will
  appear in the echo area:

  #+begin_src emacs-lisp
    ("anothe piece" "a apiece of text" "previous piece")
  #+end_src

- With the ~car~ and ~nthcdr~ functions, you can retrieve whichever
  piece of text you want.  For example, in the following code, ~nthcdr
  1 ...~ returns the list with the first item removed; and the ~car~
  returns the first element of that remainder--the second element of
  the original list:

  #+begin_src emacs-lisp
    (car (nthcdr 1 '("another piece"
        "a piece of text"
    "previous piece")))
  #+end_src

- The actual functions in Emacs are more complex than this, of course.
  The code for cutting and retrieving text has to be written so that
  Emacs can figure out which element in the list you want--the first,
  second, third, or whatever.  In addition, when you get to the end of
  the list, Emacs should give you the first element of the list,
  rather than nothing at all.

- The list that holds the pieces of the text is called the /kill
  ring/. This chapter lead up to a description of the kill ring, and
  how it is used by first tracing how the ~zap-to-char~ functions
  works.  This function calls a function that invoke a function that
  manipulates the kill ring.  Thus, before reaching the mountains, we
  climb the foothills.

- A subsequent chapter describes how text that is cut from the buffer
  is retrieved. See [[][Yanking Text Back]]

** ~zap-to-char~

- Let us look at the interactive ~zap-to-char~ function.

  - [[The complete ~zap-to-char~ Implementation][Complete zap-to-char]]         The complete implementation
  - [[The ~interactive~ Expression][zap-to-char interactive]]                   A three part interactive expression
  - [[The Body of ~zap-to-char~][zap-to-char body]]                             A short overview
  - [[The ~search-forward~ Function][search forward]]                           How to search for a string
  - [[The ~progn~ Special Form][prongn]]                                        The ~progn~ special form
  - [[Summing up ~zap-to-char~][Summing up zap-to-char]]                        Using ~point~ and ~search-forward~

*** The complete ~zap-to-char~ Implementation

- The ~zap~to-char~ functions removes the next text in the region
  between the location of the cursor (i.e of point) up to and
  including the next occurrence of a specified character.  The text
  ~zap-to-char~ removes is put in the kill ring; and it can be
  retrieved from the kill ring by typing ~C-y (yank)~.  If the
  commands is given an argument, it removes text through that numbers
  of occurrences.  Thus, if the cursor were at the beginning of this
  sentence and the character were '~s~', '~Thus~; would be removed.
  If the argument were two, '~Thus, if the curs~', would be removed ,
  up to and including he '~s~' in '~cursor~'.

- If the specified character is not found, ~zap-to-char~ will say
  "Search failed", tell you the character you typed, and not remove
  any text.

- In order to determine how much text remove, ~zap-to-char~ uses a
  search function.  Searches are used in code that manipulates text,
  and we will focus attention on them as well on the deletion command.

- Here is the complete text of the version 22 implementation of the
  function:

  #+begin_src emacs-lisp
    (defun zap-to-char (arg char)
      "Kill up to and including ARG'th occurance of CHAR.
            Case is ignored if `case-fold-search' is non-nil in the current buffer.
            Goes backward if ARG is negative; error if CHAR not found."
      (interavtive"p\ncZap to char: ")
      (if (char-table-p translation-table-for-input)
          (setq char (or (aref translation-tabel-for-input-char) char)))
      (kill-region (point) (progn
                             (search-forward (char-to-string char)
                                             nil nil arg)
                             (point))))
  #+end_src

- The documentation is thorough.  You do need to know the jargon
  meaning of word "kill".

- The version 22 documentation string of ~zap-to-char~ uses ASCII
  accent and apostrophe to quote a symbol, so it appears
  ~`case-fold-search'~.  This quoting style was inspired by 1970s-era
  displays in which grave accent ans apostrophe were often mirror
  image for use as quotes.  On most modern displays this is no longer
  need true, and when these two ASCII characters appear in
  documentation strings or diagnostic message formats, Emacs typically
  transliterates them to /curve quotes/ (left and right single
  (quotation marks), so that the abovequoted symbols appears as
  ~`case-fold-search'~.  Source-code string can also simply use curved
  quoted directly.

*** The ~interactive~ Expression

- The interactive expression in the ~zap-to-char~ commands looks like this:

  #+begin_src emacs-lisp
    (interative "p\ncZap to char: ")
  #+end_src

- The part within quotation marks, ~"p\nZap to char: "~ is ~`cZap to
  char: '~.  In this part, the lower case '~c~' indicates that
  ~interactive~ expects a prompt and that prompt ans that the argument
  will be a character.  The prompt follows the '~c~' and is the string
  ~`Zap to char: '~ (with a space after the colon to make it look
  good).

- What all this does is prepare the arguments to ~zap-to-char~
  function copies the text to the kill ring, but does not remove it.
  The echo area displays a message saying that the buffer is
  read-only.  Also, the terminal may beep or blink at you.

*** The Body of ~zap-to-char~

- The body of the ~zap-to-char- function contains the code that kills
  (that is, remove) the next text in the region from the current
  position from the current position of the cursor up to and including
  the specified character.

- The first part of the code looks like this:

  #+begin_src emacs-lisp
    (if (char-table-p translation-table-for-input)
        (setq char (or (aref translation-table-for-input char) char)))
    (kill-region (point) (progn
                           (search-forward (char-to-string char) nil nil arg)
                           (point)))
  #+end_src

~char-table-p~ is a hitherto unseen function.  It determine whether
its argument is a character table.  When it is, sets the charter
passed to ~zap-to-char~ to one of them, if that character exist, or to
the character itself.  (This becomes important for certain characters
in non-European languages.  The ~aref~ function extracts an element an
array. It is an array-specific function that is not described in this
document.  See [[][Arrays]] in The GNU Emacs lisp Reference Manual.)

- ~(point)~ is the current position of the cursor.

- The next part of the code is an expression using ~progn~.  The body
  of the ~progn~ consists of call ~search-forward~ and ~point~.

- It easier to understand how ~progn~ works after learning about
  ~search-forward~, so we will look at ~search-forward~ and then at
  ~progn~.

*** The ~search-forward~ Function

- The ~search-forward~ function is used to locate the
  zapped-for-character in the ~zap-to-char~.  If the search is
  successful, ~search-forward~ leaves point immediately after the last
  character in the target string.  (In ~zap~to-char~, the target
  string is just one character long. ~zap-to-char~ uses the function
  ~char-to-string~ to ensure that the computer treats that character
  as a string.)

- In the ~zap-to-char~, the ~search-forward~ function looks like this:

  #+begin_src emacs-lisp
    (search-forward (char-to-string char) nil nil arg)
  #+end_src

- The ~search-forwad~ function takes four arguments:

  1. The first argument is the target, what is searched for. This must
     be a string, such as '~"z"~'.

     As it happens, the argument passed to ~zap-to-char~ is a single
     character.  Because of the way computers are a built, the Lisp
     interpreter may treat a single characters as being different form
     a string of characters.  Inside the computer, a single character
     has different electronic format than a string of one character.
     (A single character can often be recorded in the computer using
     exactly one byte; but a string may no longer, and the computer
     needs to be ready for this.)  Since the ~search-forward~ function
     searcher for a string, the character that the ~zap-to-char~
     function receives as its argument must be converted inside the
     computer form one format to the other; otherwise the
     ~search-forward~ function will fail.  The ~char-to-string~
     function is used to make this conversion.

  2. The second argument bounds the search; it is specified as a
     position in the buffer.  In this case, the search can go to the
     end of the buffer, so no bound is set and the second argument is
     ~nil~.

  3. The third argument tells the function what it should do if the
     search fails--it can signal an error (and print a message) or it
     can return ~nil~.  A ~nil~ as the third argument causes the
     function to signal an error when the search fails.

  4. The fourth argument to ~search-forward~ is the repeat count--how
     many occurrences of the string to look for.  This argument is
     optional and if the function is called without a repeat count,
     this argument is passed the value 1.  If this argument is
     negative, the search goes backwards.

- In template form, a ~search-forward~ expression looks like this:

  #+begin_src emacs-lisp
    (search-forward "target-string"
                    limit-of-search
                    what-to-do-if-search-fails
                    repeat-count)
  #+end_src

  We will look at ~progn~ next.

*** The ~progn~ Special Form

- ~progn~ is a special form that causes each of its arguments to be
  evaluated in sequence and then the value returns the value of the
  last one.  The preceding expressions are evaluated only for the side
  effects they perform. The value produced by them are discarded.

- The template for a ~progn~ expression is very simple"

  #+begin_src emacs-lisp
    (progn
      body...)
  #+end_src

- In ~zap-to-char, the ~progn~ expression has to do two things: put
  point in exactly the right position; and return the location of
  point so that ~kill-region~ will know how far to kill to.

- The first argument to the ~progn~ is ~search-forward~.  When
  ~search-forward~ finds the string, the function leaves point
  immediately after the last character in the target string.  (In this
  case the target string is just one character long.)  If the search
  is backwards, ~search-forward~ leaves point just before the first
  character in target.  The movement of point is a side effect.

*** Summing up ~zap-to-char~

- Now that we have seen how ~search-forward~ and ~progn~ work, we can
  see how the ~zap-to-char~ function work as a whole.

- The first argument to ~kill-region~ is the position of the cursor
  when ~zap-to-char~ command is given--the value of point at that
  time.  Within the ~progn~, the search function then moves point to
  just after the zapped-to-character and ~point~ returns the value of
  this location.  The ~kill-region~ function puts together these two
  value of point, the first one as the beginning of the region and the
  second one as the end of the region, and removes the region.

- The ~progn~ special form is necessary because the ~kill-region~
  command takes two argument; and it wold fail if ~search-forward~ and
  ~point~ expression were written in sequence as two additional
  arguments.  The ~progn~ expression is a single argument to
  ~kill-region~ and returns the one that ~kill-region~ needs for its
  second argument.

** ~kill-region~

- The ~zap-to-char~ function uses the ~kill-region~ function.  This
  function clip text from a region and copies that text to the kill
  ring, from which it may be retrieved.

- The Emacs 22 version of that function uses ~condition-case~ and
  ~copy-region-as-kill~, both of which we will explain.
  ~condition-case~ is an important special form.

- In essence, the ~kill-region~ function calls ~condition-case~, which
  takes three arguments.  In this function, the first argument does
  nothing. The second argument contains the code that does the work
  when all goes well.  The third argument contains the code that is
  called in the event of an error.

  - [[The Complete ~kill-region~ Definition][Complete kill-region]]             The function definition
  - [[~condition-case~][condition-case]]                                        Dealing with a problem
  - [[Lisp macro][Lisp macro]]

*** The Complete ~kill-region~ Definition

- We will go through the ~condition-case~ code in a moment.  First,
  let us look at the definition of ~kill-region~, with comments added:

  #+begin_src emacs-lisp
    (defun kill-region (beg end)
      "Kill (\"cut\") text between point and mark.
    This deletes the text from the buffer and saves it in the kill ring.
    The command \\[yank] can retrieve it from there. … "


      ;; • Since order matters, pass point first.
      (interactive (list (point) (mark)))
      ;; • And tell us if we cannot cut the text.
      ;; 'unless' is an 'if' without a then-part.
      (unless (and beg end)
        (error "The mark is not set now, so there is no region"))


      ;; • 'condition-case' takes three arguments.
      ;;    If the first argument is nil, as it is here,
      ;;    information about the error signal is not
      ;;    stored for use by another function.
      (condition-case nil


          ;; • The second argument to 'condition-case' tells the
          ;;    Lisp interpreter what to do when all goes well.


          ;;    It starts with a 'let' function that extracts the string
          ;;    and tests whether it exists.  If so (that is what the
          ;;    'when' checks), it calls an 'if' function that determines
          ;;    whether the previous command was another call to
          ;;    'kill-region'; if it was, then the new text is appended to
          ;;    the previous text; if not, then a different function,
          ;;    'kill-new', is called.


          ;;    The 'kill-append' function concatenates the new string and
          ;;    the old.  The 'kill-new' function inserts text into a new
          ;;    item in the kill ring.


          ;;    'when' is an 'if' without an else-part.  The second 'when'
          ;;    again checks whether the current string exists; in
          ;;    addition, it checks whether the previous command was
          ;;    another call to 'kill-region'.  If one or the other
          ;;    condition is true, then it sets the current command to
          ;;    be 'kill-region'.

          (let ((string (filter-buffer-substring beg end t)))
            (when string                    ;STRING is nil if BEG = END
              ;; Add that string to the kill ring, one way or another.
              (if (eq last-command 'kill-region)

                  ;;    - 'yank-handler' is an optional argument to
                  ;;    'kill-region' that tells the 'kill-append' and
                  ;;    'kill-new' functions how deal with properties
                  ;;    added to the text, such as 'bold' or 'italics'.
                  (kill-append string (< end beg) yank-handler)
                (kill-new string nil yank-handler)))
            (when (or string (eq last-command 'kill-region))
              (setq this-command 'kill-region))
            nil)


        ;;  • The third argument to 'condition-case' tells the interpreter
        ;;    what to do with an error.

        ;;    The third argument has a conditions part and a body part.
        ;;    If the conditions are met (in this case,
        ;;             if text or buffer are read-only)
        ;;    then the body is executed.

        ;;    The first part of the third argument is the following:
        ((buffer-read-only text-read-only) ;; the if-part
         ;; …  the then-part
         (copy-region-as-kill beg end)

         ;;    Next, also as part of the then-part, set this-command, so
         ;;    it will be set in an error
         (setq this-command 'kill-region)
         ;;    Finally, in the then-part, send a message if you may copy
         ;;    the text to the kill ring without signaling an error, but
         ;;    don't if you may not.

         (if kill-read-only-ok
             (progn (message "Read only text copied to kill ring") nil)
           (barf-if-buffer-read-only)
           ;; If the buffer isn't read-only, the text is.
           (signal 'text-read-only (list (current-buffer)))))

  #+end_src

*** ~condition-case~

- As er have seen earlier (see [][Generate an Error Message]]), when
  the Emacs Lisp interpreter has trouble evaluating an expression, it
  provides you with help; in the jargon, this is called "signaling an
  error".  Usually, the computer stops the program and shows you a
  message.

- However, some programs undertake complicated actions.  They should
  not simply stop an error.  In the ~kill-region~ function, the most
  likely error is that you will try to kill text that is read-only and
  cannot be removed.  So the ~kill-region~ function contains code to
  handle this circumstance.  This code, which makes up the body of the
  ~kill-region~ function, is inside of a ~condition-case~ special form.

- The template for ~condition-case~ looks like this:

  #+begin_src emacs-lisp
    (condition-case
        var
        bodyform
      error-handler...)
  #+end_src

- The second argument, /bodyform/, is straightforward.  The
  ~condition-case~ special form causes the Lisp interpreter to
  evaluate the code in /bodyform/.  If no error occurs, the special
  form returns the code's value and produces the side-effect, if any.

- In short, the /bodyform/ part of a ~condition-case~ expression
  determines what should happen when everything works correctly.

- However, if an errors occurs, among its other actions, the function
  generating the errors signal will define one or more error condition
  names.

- An error handlers is the third argument to ~condition-name~. An
  error handlers has two parts, a /condition-name/ and a /body/.  If
  the /condition-name/ part of an error handler matches a condition
  name generated by an error, then the /body/ part of the error
  handlers is run.

- As you will expect, the /condition-name/ part of an error handlers
  may be either a single condition name or a list of condition names.

- Also, a complete ~condition-case~ expression may contain more than
  one error handler. When an error occurs, the first applicable
  handler is run.

- Lastly, the first argument to the ~condition-case~ expression, the
  /var/ argument, is sometimes bound to a variable that contains
  information about the error.  However, if that argument is nil, as
  is the case in ~kill-region~, that information is discarded.

- In brief, in the ~kill-region~ function, the code ~condition-case~
  works like this:

  #+begin_src emacs_lisp
    If no errors, run only this code
       but, id errors, run this other code.
  #+end_src

*** Lisp macro

- The part of the ~condition-case~ expression that is evaluated in the
  expectation that all goes well has a ~when~.  The code uses ~when~
  to determine whether the ~string~ variable points to the text that
  exists.

- A ~when~ expression is simply a programmers' convenience.  It is an
  ~if~ without the possibility of an else clause.  In your mind, you
  can replace ~when~ with ~if~ and understand what goes on.  That is
  what the Lisp interpreter does.

- Technically speaking, ~when~ is a Lisp macro.  A Lisp macro enables
  you to define new control constructs and other language features.
  It will tells the interpreter how to compute another Lisp expression
  which will in turn compute the value.  In this case. the other
  expression is an ~if~ expression.

- The ~kill-region~ function definition also has an ~unless~ macro; it
  is the converse of ~when~.  The ~unless~ macro is an ~if~ without a
  then clause.

- For more about Lisp macros, see [[][Macros]] in The GNU Emacs Lisp
  Reference Manual.  The C programming language also provide macros.
  These are different, but also useful.

- Regarding the ~when~ macro, in the ~condition-case~ expression, when
  the string has content, then another conditional expression is
  executed.  This mean is an ~if~ with both a then-part and an
  else-part.

  #+begin_src emacs-lisp
    (if (eq last-command 'kill-region)
        (kill-append string (< end beg) yank handlerr)
      (kill-new string nil yank-handlers))
  #+end_src

- The then-part is evaluated if the previous command was another to
  ~kill-region~; if not, the else-part is evaluated.

- ~yank-handlers~ is an optional argument to ~kill-region~ that tells
  the ~kill-append~ and ~kill-new~ functions how deal with properties
  added to the text, such as bold or italics.

~last-command~ is variable that comes with Emacs that we have not seen
before.  Normally, whenever a function is executed, Emacs sets the
value of ~last-command~ to the previous command.

- In this segment of definition, the ~if~ expression checks whether
  the previous command was ~kill-region~.  If it was.

  #+begin_src emacs-lisp
  #    (kill-append string (< end bag) yank-handlers.
  #+end_src

** ~copy-region-as-kill~

- The ~copy-region-as-kill~ function copies a region of text from a
  buffer and (via either ~kill-append~ or ~kill-new~) saves it in the
  ~kill-ring~.

- If you call ~copy-region-kill~ immediately after a ~kill-region~
  command, Emacs appends the newly copied text to the previously
  copied text.  This mean that if you yank back the text, you will get
  it all, from both this and the previous operation.  on the other
  hand, if some other command precedes the ~copy-region-as-kill~, the
  function copies the text into a separate entry in the kill ring.

  - [[The complete ~copy-region-as-kill~ function definition][Complete copy-region-as-kill]]            The complete function definition.

  - [[The Body of ~copy-region-as-kill~][copy-region-as-kill body]]                                     The body of ~copy-region-as-kill~.

*** The complete ~copy-region-as-kill~ function definition

- Here is the complete text of the version 22 ~copy-region-as-kill~
  function:

  #+begin_src emacs-lisp
    (defun copy-region-as-kill (beg end)
      "Save the region as if killed, but don't kill it.
    In Transient Mark mode, deactivate the mark.
    If `interprogram-cut-function' is non nil, also save the text for a window
    system cut and paste."
      (interactive "r")
      (if (eq last-command 'kill-region)
          (kill-append (filter-buffer-substring beg end) (< end beg))
        (kill-new (filter-buffer-substring beg end)))

      (if transient-mark-mode
          (setq deactive-mar t))
      nil)
  #+end_src

- As usual, this function can be divided into its component parts:

  #+begin_src emacs-lisp
    (defun copy-region-as-kill (argument-list)
      "documentation..."
      (interacritive "r")
      body...)

  #+end_src

- The arguments are ~beg~ and ~end~ and the function is interactive
  with ~"r"~, so the two arguments must refer to the beginning and end
  of the region.  If you have been reading through this documentation
  from beginning, understand these parts of a function is almost
  becoming routine.

- The documentation is somewhat confusing unless you remember that the
  word "kill" has a meaning from usual.  The Transient Mark and
  ~interprogram-cut-function~ comments explain certain side-effects.

- After you once set a mark, a buffer always contains a region.  If
  you wish, you can use Transient Mark mode to highlight the region
  temporarily.  (No one wants to highlight the region all the time, so
  Transient Mark mode highlight it only at appropriate time.  Many
  people turn off Transient Mark mode, so the region id never
  highlighted.)

- The body of ~copy-region-as-kill~ function starts with an ~if~
  clause.  What this clause does is distinguish between two different
  situations: whether or not this command is executed immediately
  after previous ~kill-region~ command.  In this case, the region is
  appended to the previously copied text.  Otherwise, it is inserted
  into the beginning of the kill ring as a separate piece of text from
  the previous piece.a

- The last two lines of the function prevent the region from lighting
  up if Transient Mark mode is turned on.

- The body of ~copy-region-as-kill~ merits discussion in detail.

*** The Body of ~copy-region-as-kill~

- The ~copy-region-as-kill~ function works in much the same way as the
  ~kill-region~ function. Both are written so that two or more kills
  in a row combine their text into a single entry.  If you yank back
  the text from the kill ring, you get it all in one piece.  Moreover,
  kills that kill forward from the current position of the cursor are
  added to the end of the previously copied text and commands that
  copy text backwards add it to the beginning of the previously copied
  text.  This way, the words in the text stay in the proper order.

- Like ~kill-region~, the ~copy-region-as-kill~ function makes use of
  the ~last-command~ variable that keeps track of the previous Emacs
  command.

  - [[~last-command~ and ~this-command~][last-command & this-command]]

  - [[The ~kill-append~ function][kill-append function]]

  - [[The ~kill-new~ function][kill-new function]]

**** ~last-command~ and ~this-command~

- Normally. whenever a function is executed, Emacs sets the value of
  ~this-command~ to the function being executed (which in this case
  would be ~copy-region-as-kill~).  At the same time, Emacs sets the
  value of ~last-command~ to the previous value of ~this-command~.

- In the first part of the body of the ~copy-region-as-kill~ function,
  an ~if~ expression determines whether the value of ~last-command~ is
  ~kill-region~.  If so, the ten-part of the ~if~ expression id
  evaluated; it uses the ~kill-append~ function to concatenate the
  text copied at this call to the function with text in the text
  already in the first element (the CAR) of the kill ring.  On the
  other hand, if the value of ~last-command~ is not ~kil-region~, then
  the ~copy-region-as-kill~ function a new element to the kill ring
  using the ~kill-new~ function.

- The ~if~ expression reads as follows; it use ~eq~:

  #+begin_src emacs-lisp
    (if (eq last-command 'kill-region)
        ;; then-part
        (kill-apend (filter-buffer-substring beg end) (< end beg))
      ;; else-part
      (kill-new (filter-buffer-substring beg end)))
  #+end_src

- (The ~filter-buffer-substring~ function returns a filtered substring
  of the buffer, if any.  Optionally--the arguments are not here, so
  neither is done--the function may delete the initial text or return
  the text without its properties; this function is a replacement for
  the older ~buffer-substring~ function, which came before text
  properties were implemented.)

- The ~eq~ function tests whether its first argument is the same Lisp
  object as its second argument.  The ~eq~ function is similar to the
  ~equal~ function in that it is used to test for equality, but
  differs in that it determines whether two representations are
  actually the same object inside the computer, but with different
  names.  ~equal~ determines whether the structure and contents of two
  expression are the same.

- If the previous command was ~kill-region~, then the Emacs Lisp
  interpreter calls the ~kill-append~ function.

**** The ~kill-append~ function

- The ~kill-apend~ function looks like this:

  #+begin_src emacs-lisp
    (defun kill-append (string before-p &optional yank-handler)
      "Append STRING to the end of the latest kill the kill ring.
    If BEFORE-P is non-nill, prepend STRING to the kill.
    ..."
      (let* ((cur (car kill-ring)))
        (kill-new (if before-p (concat string cur) (concat cur string))
                  (or (= (length cur) 0)
                      (equal yank-handler
                             (get-text-property 0 'yank-handler  cur)))
                  yank-handler)))
 #+end_src

- The ~kill-append~ function is fairly straightforward.  It uses the
  ~kill-new~ function, which we will discuss in more detail in a
  moment.

- (Also, the function provides aw optional argument called
  ~yanked-handler~; when invoked, this argument tells the function how
  to deal with properties added to the text, such as bold or
  italics.)

- It has a ~let*~ function to set the value of this element of the
  kill ring to ~cur~.  (I do not know why the function does not use
  ~let~ instead; only one value is set in the expression.  Perhaps
  this is a bug that produces no problem?)

- Consider the conditional that is one of the two arguments to
  ~kill-new~.  It uses ~concat~ to concatenate the new text to the CAR
  of the kill ring.  Whether it prepends or appends the text depends
  on the result of an ~if~ expression:

  #+begin_src emacs-lisp
    eif before-p                      ; if-part
        (concat string cur)           ; then-part
      (concat cur string              ; else-part
  #+end_src

- If the region being killed is before the region in the last command,
  then it should be prepend before the material that was saved in the
  previous kill; and conversely, if the killed text follows what was
  just killed, it should be appended after the previous text.  The
  ~if~ expression depends on the predict ~before-p~ to decide whether
  the newly saved text should be put before or after the previously
  saved text.

- The symbol ~before-p~ is the name of one argument to ~kill-append~.
  When the ~kill-append~ function is evaluated, it is bound to the
  value returned by evaluating the actual argument.  In this case,
  this is the expression ~(< end beg)~.  This expression does not
  directly determine whether the killed text in this command is
  located before or after the kill text of the last command; what it
  does is determine whether the value of the variable ~end~ id less
  then the value of the variable ~beg~.  If it is, it means that the
  user is most likely heading towards the beginning of the buffer.
  Also, the result of evaluating the predicate expression ~(< end
  beg)~, will be true and the text will be prepended before the
  previous text.  On the other hand, if the value of the variable
  ~end~ is greater than the value of the variable ~beg~, the text will
  appended after the previous text.

- When the newly saved text will be prepended, then the string with
  the new text will be concatenated before the old text:

  #+begin_src emacs-lisp
    (concat string cur)
  #+end_src

- Bur if the text will be appended, it will be concatenated after the
  old text:

  #+begin_src emacs-lisp
    (contat cur string))
  #+end_src

- To understand how this works, we first need to review the ~concat~
  function. The ~concat~ function links together or unites two strings
  of the text.  The result is a string.  For example:

  #+begin_src emacs-lisp
    (concat "abc" "def")
                ⇒ "abcdef"

    (concat "new "
            (car '("first element" "second element")))
                ⇒ "new first element"

    (concat (car
             '("first element" "second element")) "modified")
                ⇒ "first element modified"
  #+end_src


- We can now make sense of ~kill-append~: it modifies the contents of
  the kill ring.  The kill ring is a list, each element of which is
  saved text.  The ~kill-append~ function uses the ~kill-new~ function
  which in turns uses the ~setcar~ function.

**** The ~kill-new~ function

- In version 22 the ~kill-new~ function looks like this:

  #+begin_src emacs-lisp
    (defun kill-new (string &optional replace yank-handler)
      "Make STRING the latest kill in the kill ring.
    Set `kill-ring-yank-pointer' to point to it.

    I `interprogram-cut-function' is non-nil, apply it to STRING.
    Optional second argument REPLACE non-nil mans that STRING will replace
    the optional front of the kill ring, rather than being added to the list.
    ..."

      (if (> (length string) 0)
          (if yank-handler
              (put-text-property 0 (length string)
                                 'yank-handler yank-handler string))

        (if yank-handler
            (signal 'args-out-of-range
                    (list string "yank-hander specified for empty string")))

        (if (fbound 'menu-bar-update-yank-menu)
            (menu-bar-update-yank-menu string (and replace (car kill-ring))))

        (if (and replace kill-ring)
            (setcar kill-ring string)
          (push string kill-ring)
          (if (< length kill-ring) kill-ring-max)
          (setcdr (nthcdr (1- kill-ring-max) kill-ring nil)))

        (setq kill-ring-yank-pointer kill-ring)
        (if interprogram-cut-function
            (funcall interporgram-cut-funtion string (not replace))))
  #+end_src

- (Notice that the function id not interactive)

- As usual, we can look at this function in parts

- The function definition has an optional ~yank-handler~ argument,
  which when invoked tells the function how to deal with properties
  added to the text, such as bold or italics.  We will sip that.

- The first line of the documentation makes sense"

  #+begin_src emacs-lisp
    Make STRING the latest kill in the kill ring.
  #+end_src

- Also, let's skip over the initial ~if~ expression and those lines of
  code involving ~menu-bar-update-yank-menu~.  We will explain them
  below.

- The critical lines are these:

  #+begin_src emacs-lisp
    (if (and replace kill-ring)
        ;; then
        (setcar kill-ring string)
      ;; else
      (push string kill-ring)
      (if (< (length- kill-ring) kill-ring-max)
          ;; avoid overlay long kill ring
          (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
    (setq kill-ring-yank-pointer kill-ring)
    (if interprogram-cut-function
        (funcal interprogram-cut-function string (not replace))))
  #+end_src

- The conditional test id ~(and replace kill-ring)~.  This will be
  true when two conditions are met: the kill ring something in it, and
  the ~replace~ variable is true.

- When the ~kill-append~ function sets ~replace~ to be true and when
  the kill ring has at least one item in it, the ~setcar~ expression
  is executed:

  #+begin_src emacs-lisp
    (setcar kill-ring string)
  #+end_src

- The ~setcar~ function actually changes the first element of the
  ~kill-ring~ list to the value of ~string~.  It replace the first
  element.

- On the other hand, if the kill ring is empty, or replaces is false,
  the else-part of the condition is executed:

  #+begin_src emacs-lisp
    (push string kill-ring)
  #+end_src

- ~push~ puts its first argument onto the second.  It is similar to
  the older.

  #+begin_src emacs-lisp
    (setq kill-ring (cons string kill-ring))
  #+end_src

  or the newer

  #+begin_src emacs-lisp
(add-to-list kill-ring string)
  #+end_src

- When it is false, the expression first construct a new version of
  the kill ring by prepending ~string~ to the existing kill ring as a
  new element (that is what the ~push~ does).  Then it executes a
  second ~if~ clause.  This second ~if~ clause keeps the kill ring
  from growing too long.

- Let's look at these two expressions in order.

- The ~push~ line of the else-part sets the new value of the kill ring
  to what results from adding the string being killed to the old kill
  ring.

- We can see how this with an example

- first,
  #+begin_src emacs-lisp
    (setq example-list '("here is a clause" "another clause"))
  #+end_src

- After evaluating this expression with ~C-x C-e~, you can evaluate
  ~example-list~ and see what it returns:

  #+begin_src emacs-lisp
    example-list
        ⇒ ("here is a clause" "another clause")
  #+end_src

- Now, we can add a new element on to this list by evaluating the
  following expression:

  #+begin_src emacs-lisp
    (push "a third clause" example-list)
  #+end_src

- Thus, the third clause is added to the list by ~push~.

- Now for the second part of the ~if~ clause.  This expression keeps
  the kill ring from growing too long.  It looks like this:

  #+begin_src emacs-lisp
    (if (> (length kill-ring) kill-ring-max)
        (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
  #+end_src

- The code checks whether the length of the kill ring is greater than
  the maximum permitted length.  This is the value of ~kill-ring-max~
  (which is 60, by default).  If the length of the kill ring is too
  long, then this code sets the last element of the kill ring to
  ~nil~.  It does this by using two functions, ~nthcdr~ and ~setcdr~.

- We looked at ~setcdr~ earlier.  It sets the CDR of a list, just as
  ~setcar~sets the CAR of the list.  In this case, however, ~setcdr~
  will not be setting the CDR of the whole kill ring; the ~nthcdr~
  function is used to cause it to set the CDR of the next to last
  element of the kill ring--this means that since the CDR of the next
  to last element is the last element of the kill ring, it will set
  the last element of the kill ring.

- The ~nthcdr~ functions works by repeatedly taking the CDR of a
  list--it takes the CDR of the CDR of the CDR ... It does this /N/
  times and returns the results.  (see [[][nthcdr]].)

- Thus, if we had a four element list that was supposed to be three
  elements long, we could set the CDR of the net to last element to
  ~nil~, and thereby shorten the list.  (If you set the last element
  to some other value than ~nil~, which you could do, then you would
  not have shortened the list.  See [[][setcdr]].)

- You can see shortening by evaluating the following three expressions
  in turn.  First set the value of ~trees~ to ~(maple oak pine
  birch)~, then set the CDR of its second CDR to ~nil~ and then find
  the value of ~trees~:

  #+begin_src emacs-lisp
    (setq trees (list 'maple 'oak 'pine 'birch))
        ⇒ (maple oak pine birch)

    (setcdr (nthcdr 2 trees) nil)
        ⇒ nil

    trees
        ⇒ (maple oak pine)
  #+end_src

- (The value returned by the ~setcdr~ expression is ~nil~ since that
  is what the CDR is set to.)

- To repeat, in ~kill-new~, he ~nthcdr~ function takes the CDR a
  number times that is one less than the maximum permitted size of the
  kill ring and ~setcfr~ sets the CDR of that element (which will be
  the rest of the elements in the kill ring) to ~nil~.  This prevents
  the kill ring from growing too long.

- The next to last expression in the ~kill-new~ functions is:

  #+begin_src emacs-lisp
    (setq kill-ring-yank-pointer kill-ring)
  #+end_src

- The ~kill-ring-yank-pointer~ is a global variable that is set to be
  the ~kill-ring~.

- Even though the ~kill-ring-yank-pointer~ is called a '~pointer~', it
  is a variable just like the kill ring.  However, the name has been
  chosen to help humans understand how the variable is used.

- Now, to return to an early expression in the body of the function:

  #+begin_src emacs-lisp
    (id (fboundp 'menu-bar-update-yank-menu)
        (menu-bar-update-yank-menu string (and replace (car kill-ring))))
  #+end_src

- It start with an ~if~ expression

- In this case, the expression test first to see whether
  ~menu-bar-update-yank-menu~ exists as a function, and if so, calls
  it.  The ~fboundp~ function returns true if the symbol it is testing
  has a function definition that is not void.  If the symbol's
  function definition were void, we would receive an error message, as
  we did when we created errors intentionally (see [[][Generate an
  Error Message]]).

- The then-part contains an expression whose first element is the
  function ~and~.

- The ~and~ special form evaluates each of its arguments until one of
  the arguments returns a value of ~nil~, in which case the ~end~
  expression returns ~nil~; however, if none of the arguments returns
  a value of ~nil~, the value resulting from evaluating the last
  argument is returned.  (Since such a value is not ~nil~, it is
  considered true in Emacs Lisp.)  In other words, an ~and~ expression
  returns a true value only if all its arguments are true.  (See
  [[][Second Buffer Related Review]])

- The expression determines whether the second argument to
  ~menu-bar-update-yank-menu~ is true or not.

- ~menu-bar-update-yank-menu~ is one of the functions that make it
  possible to use the "Select and Paste" menu in the Edit item of a
  menu bar; using a mouse, you can look at the various pieces of text
  you have saved and select one piece to paste.

- The last expression in the ~kill-new~ function adds the newly copied
  string to whatever facility exists for copying and pasting among
  different programs running in a windowing system.  In the X
  Windowing system, for example, the ~x-select-text~ function takes
  the string ans stores it in memory operated by X.  You can paste the
  string in another program, such as an Xterm.

- The expression looks like this:

  #+begin_src emacs-lisp
    (if interprogram-cut-function
        (funcall interprogram-cut-function string (not replace))))
  #+end_src

- If an ~interprogram-cut-function~ exists, then Emacs executes
  ~funcall~, which in turns calls its first argument as a function and
  passes the remaining arguments to it.  (Incidentally, as far as I
  can see, this ~if~ expression could be replaced by ~and~ expression
  similar to the one in the first part of the function.)

- We are not going to discuss windowing systems and other program
  further, but merely note that this is a mechanism that enables GNU
  Emacs to work easily and well with other-programs.

- This code for placing text in the kill ring, either concatenated
  with an existing element or as a new element, leads us to the code
  for bringing back text that has been cut out of the buffer--the yank
  commands.  However, before discussing the yank command, i t is
  better to learn how lists are implemented in a computer.  This will
  make clear such mysteries as the use of the "pointer".  But before
  that, we will digress into C.

**  Digression into C

- The ~copy-region-as-kill~ function (see[[][copy-region-as-kill]])
  uses the ~filter-buffer-substring~ function, which in turn uses the
  ~delete-and-extract-region~ function.  It removes the contents of a
  region and you cannot get them back.

- Unlike the other code discussed here, the
  ~delete-and-extract-region~ function is not written in Emacs Lisp;
  it is written in C and is one of the primitives of the GNU Emacs
  system.  Since is very simple, I will digress briefly from Lisp and
  describe it here.

- Like many other code Emacs primitives, ~delete-and-extract-region~
  is written as an instance of a C macro, a macro being a template for
  code.  The complete macro looks like this:

  #+begin_src c
    DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
           Sdelete_and_extract_region, 2, 2, 0,
           doc: /* Delete the text between START and END and return it. */)
    (lisp_object start, lisp_Object end)
    {
        validate_region (&start, &end);
        if (XFIXNUM (start) == XFIXNUM (end))
            return empty_unibyte_string;
        return del_range_2 (XFIXNUM (start), XFIXNUM (end), 1, 1);
    }
  #+end_src

- Without going into the details of the macro writing process, let me
  point out that this macro starts with the word ~DEFUN~ was chosen
  since the code serves the same purpose as ~defun~ does in Lisp.
  (The ~DEFUN~ C macro is defined in ~emacs/src/lisp.h~.)

- The word ~DEFUN~ is followed by seven parts inside of parentheses:

    - The first part is the name given to the function in Lisp,
      ~delete-and-extract-region~.

    - The second part is the name of the function in C,
      ~Fdelete_and_extract_region~.  By convention, it start with
      '~F~'.  Since C does not use hyphens in names, underscores are
      used instead.

    - The third part is the name for the C constant structure that
      records information on this function for internal use.  It is
      the name of the function in C but begins with an '~s~' instead
      of an '~F~'.

    - The forth and fifth parts specify the minimum and maximum number
      of arguments the function can have.  This function demands
      exactly 2 arguments.

    - The sixth part is nearly like the argument that follows the
      ~interactive~ declaration in a function written in Lisp: a
      letter followed, perhaps, by a prompt.  The only difference from
      Lisp id when the macro is called with no arguments.  Then you
      write a ~0~ (which is a null string), as in this macro.

      If you were to specify arguments, you would place them between
      quotation marks.  The C macro for ~goto-char~ includes ~"NGoto
      char: "~ in this position to indicate that the function expects
      a raw prefix, in this case, a numerical location in a buffer,
      and provides a prompt.

   - The seventh part is a documentation string, just like the one for
     a function written in Emacs Lisp.  This is written as a C
     comment.  (When you build Emacs, the program
     ~lib-src/make-docfile~ extracts these comments and uses them to
     make the documentation.)

- In a C macro, the formal parameters come next, with a statement of
  what kind of object they are, followed by the body of the macro.
  For ~delete-and-extract-region~ the body consists of the following
  four lines:

  #+begin_src c
    validate_region (&start, &end);
    if (XFIXNUM (start) == XFIXNUM (end))
        return empty_unibyte_string;
    return del_range_1 (XFIXNUM (start), XFIXNUM (end), 1, 1);
  #+end_src

- The ~validate_region~ function checks whether the values passed as
  the beginning and end of the region are the proper type and are
  within a range.  If the beginning and end position are the same,
  then return empty string.

- The ~del_range_1~ function actually deletes the text.  It is a
  complex function we will look into.  It updates the buffer and does
  other things.  However, it is worth looking at the expert knowledge
  to understand, the two values are of type ~Lisp_object~, which might
  be a C pointer, a C integer, or a C ~struct~; C code ordinarily
  should not care how ~Lisp_object~ is implemented.

- ~Lisp_Object~ widths depend on the machine, and are typically 32 or
  64 bits.  A few of the bits are used to specify the type of
  information; the remaining buts are used as content.

- '~XFIXNUM~' is a C macro that extracts the relevant integer from the
  longer collection of bits; the type bits are discarded.

- The command in ~delete-and-extract-region~ looks like this:

  #+begin_src c
    del_range_1 (XFINUM (start), XFINUM (end), 1, 1);
  #+end_src

- It deletes the region between the beginning position, ~start~, and
  the ending position, ~end~.

- From the point of view of the person writing Lisp, Emacs is all very
  simple; but hidden underneath is a great deal of complexity to make
  it all work.

** Initializing a Variable with ~defvar~

- The ~copy-region-as-kill~ function is written in Emacs Lisp.  Two
  functions within, ~kill-append~ and ~kill-new~, copy a region in a
  buffer and save it in a variable called the ~kill-ring~.  This
  section describes how the ~kill-ring~ variable is created and
  initialized using the ~defvar~ special form.

- (again we note that the term ~kill-ring~ is misnomer.  The text that
  is clipped out of the buffer can be brought back; it is not a ring
  of corpses, but a ring of resurrectable text.)

- In Emacs Lisp, a variable such as the ~kill-ring~ is created and
  given an initial value by using the ~defvar~ special form.  The name
  comes from "define variable".

- The ~defvar~ special form is similar to ~setq~ in that sets the
  value of a variable.  It is unlike ~setq~ in two ways; first, it
  only sets the value of the variable if the variable does not already
  have a value.  If the variable already has a value, ~defvar~ does
  not override the existing value.  Second, ~defvar~ has a
  documentation string.

- (There is a related macro, ~defcustom~, designed for variables that
  people customize.  It has more features than ~defvar~.  (See
  [[][Setting Variables With ~defcustom~.)

  - [[Seeing the Current  Value of a Variable][See variable current value]]

  - [[~devfar~ and asterisk][defvar and asterisk]]

*** Seeing the Current  Value of a Variable

- You can see the current value of variable, by using the
  ~describe-variable~ function, which usually invoked by typing ~C-h
  v~.  If you type ~C-h v~ and then ~kill-ring~ (followed by ~RET~)
  when prompted, you will see what is in your current kill ring--this
  may be quite a lot! Conversely, if you have been doing nothing this
  Emacs session expect read this document, you may have nothing in it.
  Also you will see the documentation for ~kill-ring~:

  #+begin_src emacs-lisp
    Documentation:
    List of killed text sequences.
    Since the kill ring is supossed to interact nicely with cut-and-paste
    facilities offered by window systems, use of this variable should
    interact nicely with `interporgram-cut-function' and
    `interprogram-paste-function'.  The function `kill-new',
    `kill-append', and `current-kill' are supposed to implement this
    interaction; you may want to use them instead of manipulating the kill
    ring directly.
  #+end_src

- The kill ring is defined by a ~defvar~ in the following way:

  #+begin_src emacs-lisp
    (devfar kill-ring nill
     "list of killed trxt sequences.
    ...")
  #+end_src

- In this variable definition, the variable is given an initial value
  of ~nil~, which make sense, since if you have saved nothing, you
  want nothing back if oy give a ~yank~ command.  The documentation
  string is written just like the documentation string of a ~defun~.
  As with the documentation string of the ~defun~, the first line of
  the documentation should be a complete sentence, since some
  commands, like ~apropos~, print only the first line of
  documentation.  Succeeding lines should not be indented; otherwise
  they look odd when you use ~C-h v (describe-variable)~.

*** ~devfar~ and asterisk

- In the past, Emacs used the ~defvar~special form both for internal
  variables that you would not expect a user to change and for
  variables that you do expect a user to change.  Although you can
  still use ~devfar~ for user customizable variables, please use
  ~defcustom~ instead, since it provides a path into the Customization
  commands.  (See [[][Specifying Variables using ~defcustom~.)

- When you specified a variable using the ~defvar~ special form, you
  could distinguish a variable that a user might want to change form
  others by typing an asterisk '~*~', in the first column of its
  documentation string.  For example:

  #+begin_src emacs-lisp
    (defvar shell-command-default-error-buffer nill
      "*Buffer name for `shell-command' ... error output.
    ... ")
  #+end_src

- You could (and still can) use the ~set-variable~ command to change
  the value of ~shell-command-default-error-buffer~ temporarily.
  However, options set using ~set-variable~ are set only for the
  duration of your editing session.  The new values are not saved
  between sessions.  Each time Emacs start, it reads the original
  value, unless you change the value within your ~.emacs~ file, either
  by setting it manually or by using ~customize~.  See [[][Your .emacs
  File]].

- For me, the major use of the ~set-variable~ command is to suggest
  variables that I might want to set in my ~.emacs~ file.  There are
  now more than 700 such variables, for too many to remember readily.
  Fortunately, you can press ~TAB~ after calling ~M-x set-variable~
  command to see list of variables.  (See [[][Examining and Setting
  Variables]] in the GNU Emacs Manual.)

** Review

Here is a brief summary of some recently introduced functions.

- ~car~, ~cdr~

  ~car~ returns the first element of a list; ~cdr~ returns the second
  and subsequent element of a list.

  For example:

    #+begin_src emacs-lisp
      (car '(1 2 3 4 5 6 7))
           ⇒ 1
      (cdr '(1 2 3 4 5 6 7))
           ⇒ (2 3 4 5 6 7)
    #+end_src

- ~cons~

  ~cons~ construct a list by prepending its first argument to its
  second argument.

  For example:

    #+begin_src emacs-lisp
      (cons 1 '(2 3 4))
            ⇒ (1 2 3 4)
    #+end_src

- ~funcall~

  ~funcall~ evaluates its first arguments as a function.  It passes
  its remaining arguments to its first argument.

- ~nthcdr~

  Returns the result of taking CDR /n/ times on a list.  The "rest of
  the rest", as it were.

  For example:

    #+begin_src emacs-lisp
      (nthcdr 3 '(1 2 3 4 5 6 7))
            ⇒ (4 5 6 7)
    #+end_src

- ~setcar~, ~setcdr~

  ~setcar~ changes the first element of a list; ~setcdr~ changes the
  second and subsequent elements of a list.

  For example:

    #+begin_src emacs-lisp
      (setq triple (list 1 2 3))

      (setcar triple '37)

      triple
        ⇒ (37 2 3)

      (setcdr triple '("foo" "bar"))

      triple
        ⇒ (37 "foo" "bar")
    #+end_src

- ~progn~

  Evaluate each argument in sequence and then return the value of the
  last.

  For example:

    #+begin_src emacs-lisp
      (progn 1 2 3  4)
      ⇒ 4
    #+end_src

- ~save-restriction~

  Record whatever narrowing is in effect in the current buffer, if
  any, and restore that narrowing after evaluating the arguments.

- ~search-forward~

  Search for a string, and if the string is found, move point.  With a
  regular expression, use the similar ~re-search-forward~.  (See
  Regular Expression Searches, for an explanation of regular
  expression patterns and searches.)

  ~search-forward~ and ~re-search-forward~ take four argument:

  1. The string or regular expression to search for.

  2. Optionally, the limit of the search.

  3. Optionally, what to do if the search fails, return ~nil~ or an
     error message

  4. Optionally, how many times to repeat the search; if negative, the
     search goes back.


- ~kill-region~, ~delete-and-extract-region~, ~copy-region-as-kill~

  ~kill-region~ cuts the text between point and mark from the buffer
  and stores that text in the kill ring, so you can get it back by
  yanking.

  ~copy-region-as-kill~ copies the text between point and mark into
  the kill ring, from which you can get it by yanking.  The function
  does not cut or remove the text from the buffer.

  ~delete-and-extract-region~ removes the text between point and mark
  from the buffer and throws it away.  You cannot get it back. (This
  is not interactive command.)


* How Lists are Implemented.

- In Lisp, atoms are recorded in a straightforward fashion; if the
  implementation is not straightforward in practice, it is,
  nonetheless, straightforward in theory.  The atom '~rose~', for
  example, is recorded as the four contiguous letters, '~r~', '~o~',
  '~s~'. '~e~'.  A list, on the other hand, is kept differently.  The
  mechanism is equally simple, but it takes a moment to get used to
  the idea.  A list is kept using a series of pairs of pointers.  In
  the series, the first pointer in each pair points to an atom or to
  another list, and the second pointer in each pairs points to the
  next pair, or to the symbol ~nil~, which marks the end of the list.

- A pointer itself is quite simply the electronic address of what is
  pointed to.  Hence, a list is kept as a series of electronic
  addresses.

    - [[List diagrammed][Lists diagrammed]]

    - [[][Symbol as Chest]]                     Exploring a powerful metaphor

** List diagrammed

- For example, the list ~(rose violet buttercup)~ has three elements,
  '~rose~', '~violet~', '~buttercup~'.  In the computer, the
  electronic address of '~rose~' is recorded in a segment of computer
  memory along with the address that gives the electronic address of
  where the atom '~violet~' is located; and that address (the one that
  tells where '~violet~' is located) is kept along with an address
  that tells where the address for the atom '~buttercup~' is located.


- This sound more complicated than it is and is easier seen in a diagram:

  #+begin_src emacs-lisp
     --- ---       --- ---      --- ---
    |   |   | --> |   |   | -->|   |   | --> nil
     --- ---       --- ---      --- ---
      |             |            |
      |             |            |
      --> rose      --> voilet   --> buttercup
  #+end_src

- In the diagram, each box represents a word of computer memory that
  holds a Lisp object, usually in the form of a memory address.  The
  boxes, i.e., the addresses, are in pairs.  Each arrow point to what
  the address is the address of, either an atom or another pair of
  addresses.  The first box is the electronic address of '~rose~' and
  the arrow points to '~rose~', the second box is the address of the
  next pair of boxes, the first part of which is the address of
  '~violet~' and the second part of which is the address of the next
  pair.  The very last box points to the symbol ~nil~, which marks the
  end of the list.

- When the variable is set to a list with an operation such as ~setq~,
  it stores the address of the first box in the variable.  Thus
  evaluation of the expression.

  #+begin_src emacs-lisp
    (setq bouquet '(rose violet buttercup))
  #+end_src

- creates a situation like this:

  #+begin_src emacs-lisp
    bouquet
         |
         |    --- ---        --- ---        --- ---
         --> |   |   | -->  |   |   | -->  |   |   | --> nil
              --- ---        --- ---        --- ---
               |              |              |
               |              |              |
               --> rose       --> violet     --> buttercup
  #+end_src

- In the same example, the symbol ~bouquet~ holds the address of the
  first pair of boxes.

- the same list can be illustrated in a different sort of box notation
  like this:

  #+begin_src emacs-lisp
    boquet
       |
       |     ----------------      -----------------       ----------------
       |    | car    |  cdr  |    | car     |  cdr  |     | car     | cdr  |
       -->  | rose   |   o------->| violet  |   o-------> | butter- |      |
            |        |       |    |         |       |     | cup     |      |
             ----------------      -----------------       ----------------
  #+end_src

- (Symbol consist of more than pairs of addresses, but the structure
  of a symbol is made up of addresses.  Indeed, he symbol ~bouquet~
  consist of a group of address-boxes, one of which is the address of
  the printed word '~bouquet~'. a second of which is the address of a
  function definition attach to the symbol, if any, a third of which
  is the address of the first pair of address-boxes for the list
  ~(rose violet buttercup)~, and so on.

- If a symbol is set to CDR of a list, the list itself is not changed;
  the symbol simply has an address further down the list.  (In the
  jargon, CAR and CDR are "non-destructive".) Thus, evaluation of the
  following expression.

  #+begin_src emacs-lisp
    (setq flowers (cdr boquet))
  #+end_src

 - produces this:

  #+begin_src emacs-lisp
    bouquet      flowers
      |             |
      |    --- ---  |     --- ---      --- ---
      --> |   |   |  --> |   |   |    |   |   |
          |   |   |----> |   |   |--> |   |   | --> nil
           --- ---        --- ---      --- ---
            |              |            |
            |              |            |
            --> rose       --> violet   --> buttercup
  #+end_src

- The value of ~flowers~ is ~(violet buttercup)~, which is to say, the
  symbol ~flowers~ holds of the pair of address-boxes, the first of
  which holds the address of ~violet~, and the second of which holds
  the address of ~buttercup~.

- A pair of address-boxes is called a /cons cell/ or /dotted pair/.
  See [[][Cons Cell and List Types]] in The GNU Emacs Lisp Reference
  Manual, and [[][Dotted Pair Notation]] in The GNU Emacs Lisp
  Reference Manual, for more information about cons cells and dotted
  pairs.

- The function ~cons~ adds a new pair of addresses to the front of a
  series of addresses like that shown above.  For example, evaluating
  the expression

  #+begin_src emacs-lisp
    (setq boquet (cons 'lily bouquet))
  #+end_src

- produces

  #+begin_src
    bouquet                        flowers
      |                             |
      |    --- ---        --- ---   |     --- ---      --- ---
      --> |   |   |      |   |   |   --> |   |   |    |   |   |
          |   |   |--->  |   |   |-----> |   |   |--> |   |   | --> nil
           --- ---        --- ---         --- ---      --- ---
            |              |               |            |
            |              |               |            |
            --> lily       --> rose         --> violet   --> buttercup

  #+end_src

- However, this does not changed the value of the symbol ~flowers~, as
  you can see by evaluating the following,

  #+begin_src emacs-lisp
    (eq (cdr (cdr bouquet)) flowers)
  #+end_src

  which returns ~t~ for true.

- Until it reset, ~flowers~ still has the value ~(violet buttercup)~;
  that is, it has the address of the cons cell whose first address is
  of ~violet~.  Also, this does not alter any of pre-existing cons
  cells; they are all still the same.


- Thus, in Lisp, to get the CDR of a list, you just get the address of
  the next cons cell in the series; to get the CAR of a list, you get
  the address of the first element of the list; to ~cons~ a new
  element on a list, you add a new cons cell to the front of the list.
  That is all there is to it!  The underlying structure of Lisp is
  brilliantly simple!.

- And what does the last address in a series of cons cell refer to? It
  is the address of the empty list, of ~nil~.

- In summary, when a Lisp variable is set to a value, it is provided
  with the address of the list to which the variable refers.

** Symbols as a Chest of Drawers

- In an earlier section, I suggested that you might imagine a symbol
  as being a chest of drawers.  The function definition is put in one
  drawer, the value in another, and so on.  What is put in the drawer
  holding the value can be changed without affecting the contents of
  the drawer holding the function definition, and vice versa.

- Actually, what is put in each drawer is the address of the value of
  function definition.  It is as if you found an old chest in the
  attic, and in one of its drawers you found a map giving you
  directions to where the buried the treasure lies.

- (In addition to its name, symbol definition, and variable value, a
  symbol has a drawer for a /property list/ which can be used to
  record other information. Property lists are not discussed here; see
  [[][Property list]] in The GNU Emacs Lisp Reference Manual.)

- Here is a fanciful representation:

  #+begin_src emacs-lisp
           Chest of Drawers           Content of Drawers

       --     oOoOoO      --
      /                     \
     -------------------------
    |     directions to       |            [map to]
    |      symbol name        |             bouquet
    |                         |
    +-------------------------+
    |     directions to       |
    |   symbol definition     |            [none]
    |                         |
    +-------------------------+
    |     directions to       |            [map to]
    |     variable value      |            [rose violet buttercup]
    |                         |
    +-------------------------+
    |     directions to       |
    |     property values     |            [not described]
    |                         |
    +-------------------------+
    |/                       \|

  #+end_src


* Yanking Text Back

- Whenever you cut text out of buffer with a kill command in GNU
  Emacs, you can bring it back with a yank command.  The text that is
  cut out of the buffer is put in the kill ring and the yank command
  insert the appropriate contents of the kill ring back into a buffer
  (not necessarily the original buffer).

- A simple ~C-y (yank) command insert the first item from the kill
  ring into the current buffer.  If the ~C-y~ command is followed
  immediately by ~M-y~, the first element is replaced by the second
  element.  Successive ~M-y~ command replace the second element with
  the third, fourth, or fifth element, and so on.  When the last
  element in the kill ring is reached, it is replaced by the first
  element and the cycle is repeated.  (Thus the kill ring is called a
  "ring" rather than just a "list".  However, the actual data
  structure that holds the text is a list.  See [[][Handling the Kill
  Ring]], for the details of how the list is handling as a ring.)

  - [[Kill Ring Overview][Kill Ring Overview]]

  - [[The ~kill-ring-yank-pointer~ Variable][kill-ring-yank-pointer]]        The kill ring is a list

  - [[][yank nthcdr Exercises]]                                              The ~kill-ring-yank-pointer~ variable

** Kill Ring Overview

- The kill ring is a list of textual strings.  This is what it looks like:

  #+begin_src emacs-lisp
    ("some text" "a different piece of text" "yet more text")
  #+end_src

- If this were the contents of my kill ring and I pressed ~C-y~, the
  string of characters saying '~some text~' would be inserted in this
  buffer where my cursor is located.

- The ~yank~ command is also used for duplicating text by copying it.
  The copied text is not cut from the buffer, but a copy of it is put
  on the kill ring and is inserted by yanking it back.

- Three functions are used for bringing text back from the kill ring:
  ~yank~, which is usually bound to ~C-y~; ~yank-pop~, which is
  usually bound to ~M-y~; and ~rotate-yank-pointer~, which is used by
  the two other functions.

- These function refer to the kill ring through a variable called the
  ~kill-ring-yank-pointer~.  Indeed, the insertion code for both the
  ~yank~, and ~yank-pop~ function is:

  #+begin_src emacs-lisp
    (insert (car kill-ring-yank-pointer)
  #+end_src

- (Well, no more. In GNU Emacs 22, the function has been replaced by
  ~insert-for-yank~, which calls ~insert-for-yank-1~ repetitively for
  each ~yank-handler~ segment.  In turn, ~insert-for-yank-1~ strips
  text properties from the inserted text according to
  ~yank-excluded-properties~.  Otherwise, it is just like ~insert~.
  We will stick with plain ~insert~ since it is easier to understand.

- To begin to understand how ~yank~ and ~yank-pop~ work, it is first
  necessary to look at the ~kill-ring-yank-pointer~ variable.

** The ~kill-ring-yank-pointer~ Variable

- ~kill-ring-yank-pointer~ us a variable, just as ~kill-ring~ is a
  variable.  It points to something by being to the value of what it
  points to, like any other Lisp variable.

- Thus, if the value of the kill ring is:

  #+begin_src emacs-lisp
    ("some text" "a different piece of text" "yet-more-text")
  #+end_src

- and the ~kill-ring-yank-pointer~ points to the seconds clause, the
  value of ~kill-ring-yank-pointers~ is:

  #+begin_src emacs-lisp
    ("a different piece of text" "yet more text")
  #+end_src

- As explained in the previous chapter (see [[][List
  implementation]]), the computer does not keep two different copies
  of the text being pointed to by both the ~kill-ring~ and the
  ~kill-ring-yank-pointer~.  the words "a different piece of text" and
  "yet another text" are not duplicated.  instead, the two lisp
  variables point to the same pieces of text. here is a diagram:

  #+begin_src emacs-lisp
    kill-ring         kill-ring-yank-pointer
        |                  |
        |     ----   ----  |       ----   ----       ----   ----
        ---> |    | |    |  -->   |    | |    |     |    | |    |
             |    | |    |---->   |    | |    |---> |    | |    |---> nil
              ----   ----          ----   ----       ----   ----
               |                    |                 |
               |                    |                 |
               |                    |                 ---> "yet more text"
               |                    |
               |                    ---> "a different piece of text"
               |
               ---> "some text"
  #+end_src

- both the variable ~kill-ring~ and the variable
  ~kill-ring-yank-pointer~ are pointers.  but the kill ring itself is
  usually described ad if it were actually what it is composed of.
  the ~kill-ring~ is spoken of as if it were list rather than that it
  points to the list. Conversely, the ~kill-ring-pointer~ is spoken of
  as pointing to a list.

- These two ways of talking about the same thing sound confusing at
  first but make sense on reflection.  The kill ring is generally
  though of as the complete structure of data that holds the
  information of what has recently been cut out of Emacs buffer.  The
  ~kill-ring-yank-pointer~ on the other hand, serves to indicate--that
  is, to point to--that part of the kill ring of which the first
  element (the CAR) will be inserted.


* Loops and Recursion

- Emacs Lisp has two primary ways to cause an expression, or a series
  of expression, to be evaluated repeatedly: one using a ~while~ loop,
  and the other using ~recursion~.

- Repetition can be very valuable.  For example, to move forward four
  sentences, you need only write a program that will move forward one
  sentence and then repeat the process four times.  Since the computer
  does not get bored or tired, such repetitive action does not have
  the deleterious effects that excessive or the wrong kinds of
  repetition can have on humans.

- People mostly write Emacs Lisp function using ~while~ loops and
  their kin; but you can use recursion, which provides a very powerful
  way of think about and then to solve the problems.

- (You can write recursive function to be frugal or wasteful of mental
  or computer resource; as it happens, methods that people find
  easy--that are frugal of mental resources--sometimes use
  considerable computer resources.  Emacs was designed to run on
  machine that we now consider limited and its default settings are
  conservative.  You may want to increase the values of
  ~max-specpdl-size~ and ~max-lisp-eval-depth~.  In may ~.emacs~ file,
  I set them to 15 and 30 times their default value.)

  - [[~while~][while]]                                                  Causing a stretch of code to repeat

  - [[Save your time: ~dolist~ and ~dotimes~][dolist dotimes]]

  - [[Recursion][Recursion]]                                            Causing a function to call itself

** ~while~

- The ~while~ special form test whether the value returned by
  evaluating its first argument is true or false.  This is similar to
  what Lisp interpreter does with an ~if~; what the interpreter does
  next, however, is different.

- In a ~while~ expression, if the value returned by evaluating the
  first argument is false, the Lisp interpreter skips the rest of the
  expression (the /body/ of the expression) and does not evaluate it.
  However, if the value is true, the Lisp interpreter evaluates the
  body of the expression and then again tests whether the first
  argument to ~while~ is true or false.  If the value returned by
  evaluating the first argument is true, the Lisp interpreter again
  evaluates the body of the expression.

- The template for a ~while~ expression looks like this:

  #+begin_src emacs-lisp
    (while true-or-false-test
      body...)
  #+end_src

  - [[Looping with ~while~][Looping with while]]                                Repeat so long as test returns true

  - [[A ~while~ Loop and a List][Leop example]]                                 A ~while~ loop that uses a list

  - [[An Example: ~print-elements-of-list~][print-element-of-list]]             Uses ~while~, ~car~, ~cdr~

  - [[A Loop with an Incrementing Counter][Incrementing Loop]]                  A loop with an incrementing counter

  - [[Details of an Incrementing Loop][Incrementing Loop Details]]

  - [[Loop with a Decrementing Counter][Decrementing Loop]]                     Repeat so long as test returns true

*** Looping with ~while~

- So long as the true-or-false-text of the ~while~ expression returns
  true when it is evaluated, the body is repeatedly evaluated.  This
  process is called a loop since the Lisp interpreter repeats the same
  thing again and again, like an airplane doing a loop.  When the
  result of evaluating the true-or-false-test is false, the Lisp
  interpreter does not evaluate the rest of the ~while~ expression and
  exits the loop.

- Clearly, if the value returned by evaluating the first argument to
  ~while~ is always true, the body following will be evaluating again
  and again ... and again ... forever.  Conversely, if the value
  returned is never true, the expressions in the body will never be
  evaluated.  The craft of writing a ~while~ loop consists of choosing
  a mechanism such that the true-or-false-test returns true just the
  number of times that you want to subsequent expressions to be
  evaluated, and then have the test returns false.

- The value returned by evaluating a ~while~ is the value of
  true-or-false-test.  An interesting consequence of this is that a
  ~while~ loop that evaluates without error will return ~nil~ or false
  regardless of whether it has looped 1 or 100 times or none at all.
  A ~while~ expression the evaluates successfully never returns a true
  value! What this mean is that ~while~ is always evaluated for its
  side effects, which is to say, the consequences of evaluating the
  expressions within the body of the ~while~ loop.  This makes sense.
  It is not the mere act of looping that is desired, but consequences
  of what happens when the expression in the loop are repeatedly
  evaluated.

*** A ~while~ Loop and a List

- A common way to control a ~while~ loop is to test whether a list has
  any elements. If it does, the loop in repeated; but i it does not,
  the repetition is ended.  Since this is an important technique, we
  will create a short example to illustrate it.

- A simple way to test whether a list has elements is to evaluate the
  list; if it has no elements, it is an empty list ans will return the
  empty list, ~()~, which is a synonym for ~nil~ or false.  On the
  other hand, a list with elements will return those elements when it
  is evaluated.  Since Emacs Lisp considered as true any value that is
  not ~nil~, as list returns elements will test true in a ~while~
  loop.

- For example, you can set the variable ~empty-list~ to ~nil~ by
  evaluating the following ~setq~ expression:

  #+begin_src emacs-lisp
    (setq empty-list ())
  #+end_src

- After evaluating the ~setq~ expression, you can evaluate the
  variable ~empty-list~ in the usual way, by placing the cursor after
  the symbol and typing ~C-x C-e~; ~nil~ will appear in your echo
  area:

  #+begin_src emacs-lisp
    empty-list
  #+end_src

- On the other hand, if you set a variable to be a list with elements,
  the list will appear when you evaluate the variable, as you can see
  by evaluating the following two expressions:

  #+begin_src emacs-lisp
    (setq animals '(gazelle giraffe lion tiger))

    animals
  #+end_src

- Thus, to create a ~while~ loop that tests whether there any items in
  the list ~animals~, the first part of the loop will be written like
  this:

  #+begin_src emacs-lisp
    (while animals
      ....
  #+end_src

- When the ~while~ tests its first argument, the variable ~animals~ is
  evaluated.  It returns a list.  So long as the list has elements,
  the ~while~ considers the results of the test to be true; but when
  the list is empty, it considers the results of the test to be false.

- To prevent the ~while~ loop from running forever, some mechanism
  needs to provided to empty list eventually.  An oft-used technique
  is to have one of the subsequent forms in the ~while~ expression set
  the value of the list to be the CDR of the list.  Each time the
  ~cdr~ function is evaluated, the list will be made shorter, until
  eventually only the empty list will be left.  At this point, the
  test of the ~while~ loop will returns false, and the arguments to
  the ~while~ will no longer be evaluated.

- For example, the list of animals bound to the variable ~animals~ can
  be set to be the CDR of the original list with the following
  expression:

  #+begin_src emacs-lisp
(setq animals (cdr animals))
  #+end_src

- If you have evaluated the previous expressions and then evaluate
  this expression, you will see ~(giraffe lion tiger)~ appear in the
  echo area.  If you evaluate the expression again, ~(lion tiger)~
  will appear in the echo area.  If you evaluate it again and yet
  again, ~(tiger)~ appears and then the empty list, shown by ~nil~.

- A template for a ~while~ loop that uses the ~cdr~ function
  repeatedly to cause the true-or-false-test eventually to test false
  looks like this:

  #+begin_src emacs-lisp
    (while test-whether-list-is-empty
      body...
      set-list-to-cdr-of-list)
  #+end_src

- This test use of ~cdr~ can be put together in a function that goes
  through a list and prints each element of the list on a line of its
  own.

*** An Example: ~print-elements-of-list~

- The ~print-elements-of-list~ function illustrate a ~while~ loop with
  a list.

- The function requires several lines for its output.  If you are
  reading this in a recent instance of GNU Emacs, you can evaluate the
  following expression inside of Info, as usual.

- If you are using an earlier version of Emacs, you need to copy the
  necessary expression to your ~*scracth*~ buffer and evaluates them
  there.  This is because the echo area had only one line in the
  earlier version.

- You can copy the expression by marking the beginning of the region
  with ~C-SPC~ (~set-mark-command~), moving the cursor to the end of
  the region using ~M-w~ (~kill-ring-save~, which calls
  ~copy-region-as-kill~ and then provides visual feedback).  In the
  ~*scratch*~ buffer, you can yank the expressions back by typing
  ~C-y~ (~yank~).

- After you have copied the expressions to the ~*scratch*~ buffer,
  evaluate each expression in turn.  Be sure to evaluate the last
  expression, ~(print-element-of-list- animals)~, by typing ~C-u C-x
  C-e~, that is, by giving an argument to ~eval-last-sexp~.  This will
  cause the result of the evaluation to be printed in the ~*scrath*~
  buffer instead of being printed in the echo area.  (Otherwise you
  will see something like this in your echo area:
  ~^Jgazelle^J^Jgiraffe^J^Jlion^J^Jtiger^J^Jnil~ in which each '~^J~'
  stands for a new line.)

- In a recent instance of GNU Emacs, you can evaluate these expression
  directly in the Info buffer, and the echo area will grow to show the
  results.

  #+begin_src emacs-lisp
    (setq animals '(gazelle giraffe lion tiger))

    (defun print-elements-of-list (list)
      "Print each element of LIST on a line of its own."
      (while list
        (print (car list))
        (setq list (cdr list))))

      (print-elements-of-list animals)
  #+end_src

- When you evaluate the three expression in a sequence, you will see
  this:

  #+begin_src emacs-lisp
    gazelle

    giraffe

    lion

    tiger
    nil
  #+end_src

- Each element of the list is printed on a line of its own (that is
  what the function ~print~ does) and then value returned by the
  function is printed.  Since the last expression in the function is
  the ~while~ loop, and since ~while~ loop always return ~nil~, a
  ~nil~ is printed after the last element of the list.

*** A Loop with an Incrementing Counter

- A loop is not useful unless is stop when it ought.  Besides
  controlling a loop with a list, a common way of stopping a loop is
  to write the first argument as a test that returns false when the
  correct number of repetitions are complete.  This means that the
  loop must have a counter--an expression that counts how many times
  the loop repeats itself.

*** Details of an Incrementing Loop

- The test for a loop with an incrementing counter can be an
  expression such as ~(< count desired-number)~ which returns ~t~ for
  true if the value of ~count~ is less than the ~desired-number~ of
  repetitions and ~nil~ for false if the value of ~count~ is equal to
  or is greater than the ~desired-number~.  The expression that
  increments the count can be simple ~setq~ such as ~(setq count (1+
  count))~, where ~+1~ is a built-in function in Emacs Lisp that adds
  1 to its argument.  (The expression ~(1+ count)~ has the same result
  as ~(+ count 1)~, but is easier for human to read.)

- The template for a ~while~ loop controlled by an incrementing
  counter looks like this:

  #+begin_src emacs-lisp
    set-count-to-initial-value
    (while (< count desired-number)     ; true-or-false-test
      body...
      (setq count (+1 count)))          ; increment
  #+end_src

- Note that you need to set the initial value of ~count~; usually it
  is set to 1.

  - [[Example with incrementing counter][Incrementing Example]]                   Counting pebbles in a triangle

  - [[The parts of the function definition][Inc Example part]]                    The parts of the function definition

  - [[Putting the function definition together][Inc Example altogether]]          Putting the function definition together

**** Example with incrementing counter

- Suppose you are playing on the beach and decide to make a triangle
  of pebbles, putting one pebbles in the first row, two in the second
  roe, three in the third row, and so on, like this:

  #+begin_src emacs-lisp
        *
       * *
      * * *
     * * * *
  #+end_src

- (about 2500 years ago, Pythagoras and others developed the beginning
  of number theory by considering question such as this.)

- Suppose you want to know how many pebbles you will need to make a
  triangle with 7 rows?

- Clearly, what you need to do is add up the numbers from 1 to 7.
  There are two ways to do this; start with the smallest number, one,
  and add up the list in sequence, 1, 2, 3, 4 and so on; or start with
  the largest number and add the list going down: 7, 6, 5, 4 and so
  on.  Because both mechanisms illustrate common ways of writing
  ~while~ loops, we will create two examples. one counting up and the
  other counting down.  In this first example, we will start with 1
  and add 2, 3, 4 and so on.

- If you are just adding up a short list of numbers, the easiest way
  to do it is to add up all the numbers at once.  However, if you do
  not know ahead of time how many numbers your list will have, or if
  you want to be prepared for a very long list, then you need to
  design your addition so that what you do is repeat a simple process
  many times instead of doing a more complex process once.

- For example, instead of adding up all the pebbles all at once, what
  you can do is add the number of pebbles in the first row, 1, to the
  number in the second row, 2, and then add the total of those two
  roes to the third row, 3.  Then you can add the number in the forth
  row, 4, to the total of the first three roes; and so on.

- The critical characteristic of the process is that each repetitive
  action is simple.  In this case, at each step we add only two
  numbers, The number of pebbles in the row and the total already
  found.  This process of adding two numbers is repeated again and
  again until the last row has been added to the total of all
  preceding rows.  In a more complex loop the repetitive action might
  be so simple, but it will be simpler than doing everything all at
  once.

**** The parts of the function definition

- The preceding analysis gives us the bones of our function
  definition: first, we will need a variable that we can call ~total~
  that will be the total of pebbles.  This will be the value returned
  by the function.

- Second, we know that the function will require an argument: this
  argument will be the total number of rows in the triangle.  It can
  be called ~number-of-rows~.

- Finally, we need a variable to use as a counter.  We could call this
  variable ~counter~, but a butter name is ~row-numbers~.  That is
  because what the counter does in this function is count rows, and a
  program should be written to be understandable as possible.

- When the Lisp interpreter first start evaluating the expressions in
  the function, the value of ~total~ should be set to zero, since we
  have not added anything to it.  Then the function should add the
  numbers of pebbles in the first row to the total, and then add the
  number of pebbles in the second to the total, and then add the
  number of pebbles in the third row to the total, and so on, until
  there are no more rows left to add.

- Both ~total~ and ~row-number~ are used only inside the function, so
  they can be declared as local variables with ~let~ and given initial
  values.  Clearly, the initial value for ~total~ should be 0.  The
  initial value of ~row-number~ should be 1, since we start with the
  first row, this means that the ~let~ statement will look like this:

  #+begin_src emacs-lisp
    (let ((total 0)
          (row-number 1))
      body...)
  #+end_src

- After the internal variables are declared and bound to their initial
  values, we can begin the ~while~ loop.  The expression that serves
  as the test should return a value of ~t~ for true so long as the
  ~row-number~ is less than or equal to the ~number-of-rows~.  (If the
  expression tests true only so long as the row number is less than
  the number of roes in the triangle, the last row will never be added
  to the total; hence the row number has to be either less than or
  equal to the number of rows.)

- Lisp provide ~<=~ function that returns true if the value of its
  first argument is less than or equal to the value of its second
  argument and false otherwise.  So the expression that the ~while~
  will evaluate as its test should look like this:

  #+begin_src emacs-lisp
    (<= row-number number-of-rows)
  #+end_src

- The total number of pebbles can be found by repeatedly adding the
  number of pebbles in a row to the total already found.  Since the
  number of pebbles in the row is equal to the row number, the total
  can be found by adding the row number to the total.  (Clearly, in a
  more complex situation, the number of pebbles in the row might be
  related to the row number in a more complicated way; if this were
  the case, the row number would be replaced by the appropriate
  expression.)

- After setting the value of ~total~, the conditions need to be
  established for the next repetition of the loop. if there is one.
  This is done by incrementing the value of the ~row-number~ variable,
  which serves as a counter.  After the ~row-number~ variable has been
  incremented, the true-or-false-test at the beginning of the ~while~
  loop tests whether its value is still less than or equal to the
  value of the ~number-of-rows~ and if it is, adds the new value of
  the ~row-number~ variable to the ~total~ of the previous repetition
  of the loop.

- The built-in Emacs Lisp function ~+1~ add 1 to a number, so the
  ~row-number~ variable can be incremented with this expression:

  #+begin_src emacs-lisp
    (setq row-number (1+ row-number))
  #+end_src

**** Putting the function definition together

- We have created the parts for the function definition; now we need
  to put them together.

- First, the contents of the ~while~ expression:

  #+begin_src emacs-lisp
    (while (<= row-number number-of-rows)
      (setq total (+ total row-number))               ; true-or-false-test
      (setq row-number (1+ row-number))               ; incrementer
  #+end_src

- Along with the ~let~ expression varlist, this very nearly completes
  the body of the function definition.  However, it requires one final
  element, the need for which is somewhat subtle.

- The final touch is to place the variable ~total~ on a line by itself
  after the ~while~ expression.  Otherwise, the value returned by the
  whole function is the value of the last expression that is evaluated
  in the body of the ~let~, and this is the value returned by the
  ~while~, which is always ~nil~.

- This is may not be evident at first sight.  It almost looks as if
  the incrementing expression is the last expression of the whole
  function.  But that expression is part of the body of the ~while~;
  it is the last element of the list that start with the symbol
  ~while~.  Moreover, the whole of the ~while~ loop is a list within
  the body of the ~let~.

  #+begin_src emacs-lisp
    (defun name-of-funtion (argument-list)
      "documentation..."
      (let (varlist)
        (while (true-or-false-text)
          body-of-while)
        ... ))                  ; Need final expression here.
  #+end_src

- The result of evaluating the ~let~ is what is going to be returned
  by the ~defun~ since the ~let~ is not embedded within any containing
  list, except for the ~defun~ as a whole.  However, if the ~while~ is
  the last element of the ~let~ expression, the function will always
  return ~nil~.  This is not what we want! Instead, what we want is
  the value of the variable ~total~.  This is returned by simply
  placing the symbol as the last element of the list starting with
  ~let~.  It gets evaluated after the preceding elements of the list
  are evaluated, which means it gets evaluated after it has been
  assigned the correct value for the total.

- It may be easier to see this by printing the lust starting with
  ~let~ all on one line.  This format makes it evident that the
  /varlist/ and ~while~ expression are the second and third elements
  of the list starting with ~let~, and ~total~ is the last element:

  #+begin_src emacs-lisp
    (let (varlist) (while (true-or-false-test) body-of-while... ) total)
  #+end_src

- Putting everything together, the ~triangle~ function definition
  looks like this:

  #+begin_src emacs-lisp
    (defun triangle (number-of-rows)        ; Version with
                                            ;   incrementing counter.
      "Add up the number of pebbles in a triangle.
    The first row has one pebble, the second row two pebbles,
    the third row three pebbles, and so on.
    The argument is NUMBER-OF-ROWS."

      (let ((total 0)
            (row-number 1))
        (while (<= row-number number-of-rows)
          (setq total (+ total row-number))
          (setq row-number (1+ row-number)))
        total))
  #+end_src

- After you installing ~triangle~ by evaluating the function, you can
  try it out.  Here are two examples:

  #+begin_src emacs-lisp
    (triangle 4)
    (triangle 7)
  #+end_src

- The sum of the first four numbers is 10 and the sum of the first
  seven numbers is 28.

*** Loop with a Decrementing Counter

- Another common way to write a ~while~ loop is to write the test that
  it determines whether a counter is greater than zero.  So long as
  the counter is greater than zero, the loop is repeated.  But when
  the counter is equal to or less than zero, the loop is stopped.  For
  this to work, the counter has to start out greater than zero, ans
  then be made smaller and smaller by form that is evaluated
  repeatedly.

- The template for a decrementing ~while~ loop looks like this:

  #+begin_src emacs-lisp
    (while (> counter 0)                ; true-or-false-test
      body...
      (setq counter (1- counter)))      ; decrementer
  #+end_src

  - [[Example with decrementing counter][Decrementing Example]]                   More pebbles on the bench

  - [[The parts of the function definition][Dec Example parts]]                   The parts of the function definition

  - [[Putting the function definition together][Dec Example altogether]]          Putting the function definition together

**** Example with decrementing counter

- To illustrate a loop with a decrementing counter, we will rewrite
  the ~triangle~ function so the counter decreases to zero.

- This is the reverse of the earlier version of the function.  In this
  case, to find out how many pebbles are needed to make a triangle
  with 3 rows, add the number of pebbles in the third row, 3. to the
  number in the preceding row, 2, and then add the total of those two
  rows to the row that precedes them, which is 1.

- Likewise, to find the number of pebbles in a triangle with 7 rows,
  add the number of pebbles in the seventh row, 7, to the number in
  the preceding row, which is 6, and then add the total of those row
  to the row that precedes them, which is 5, and so on.  As in the
  previous example, each addition only involves adding two number, the
  total of the rows already added up and the number of pebbles in the
  row that is being added to the total.  This process of adding two
  numbers is repeated again and again until there are no more pebbles
  to add.

- We know how many pebbles to start with: the number of pebbles in the
  last row is equal to the number of rows.  If the triangle has seven
  rows, the number of pebbles in the last row is 7.  Likewise, we know
  how many pebbles are in the preceding row: it is one less than the
  number in the row.

**** The parts of the function definition

- We start with three variables: the total amount of rows in the
  triangle; the number of pebbles in a row; and the total number of
  pebbles, which is what we want to calculate.  These variables can be
  named ~number-of-rows~, ~number-of-pebbles-in-row~, and ~total~,
  respectively.

- Both ~total~ and ~number-of-pebbles-in-row~ are used only inside the
  function and are declared with ~let~.  The initial value of ~total~
  should,, of course, be zero.  However, the initial value of
  ~number-of-pebbles-in-rows~ should be equal to the number of rows in
  the triangle, since the addition will start with the longest row.

- This means that the beginning of the ~let~ expression will look like
  this:

  #+begin_src emacs-lisp
    (let ((total 0)
      (number-of-pebbles-in-row number-of-rows))
    body...)
  #+end_src

- The total number of pebbles can be found by repeatedly adding the
  number of pebbles in a row to the total already found, that is, by
  repeatedly evaluating the following expression:

  #+begin_src emacs-lisp
    (setq total (+ total number-of-pebbles-in-row))
  #+end_src

- After the ~number-of-pebbles-in-row~ is added to the ~total~, the
  ~number-of-pebbles-in-row~ should be decremented by one, since the
  next time the loop repeats, the preceding row will be added to the
  total.

- The number of pebbles in a preceding row is one less than the number
  of pebbles in a row, so the built-in Emacs Lisp function ~1-~ can be
  used to compute the number of pebbles in the preceding row.  This
  can be done with the following expression:

  #+begin_src emacs-lisp
    (setq number-of-pebbles-in-row
          (1- number-of-pebbles-in-row))
  #+end_src

- Finally, we know that the ~while~ loop should stop making repeated
  additions when there are no pebbles in a row.  So the test for the
  ~while~ loop is simply:

  #+begin_src emacs-lisp
(while (> number-of-pebbles-in-row 0)
  #+end_src

**** Putting the function definition together

- We can put these expression together to create a function definition
  that works.  However, on examination, we find that one of the local
  variables is unneeded!.

- The function definition looks like this:

  #+begin_src emacs-lisp
    ;;; First subtractive version.
    (defun triangle (number-of-rows)
      "Add up the number of pebbles in a triangle."
      (let ((total 0)
            (number-of-pebbles-in-row number-of-rows))
        (while (> number-of-pebbles-in-row 0)
          (setq total (+ total number-of-pebbles-in-row))
          (setq number-of-pebbles-in-row
                (1- number-of-pebbles-in-row)))
        total))
  #+end_src

  As written, this function works.

- However, we do not need ~number-of-pebbles-in-row~.

- When the ~triangle~ function is evaluated, the symbol
  ~number-of-rows~ will be bound to a number, giving it an initial
  value.  That number can be changed in the body of the functions as
  if it were a local variable, without any fear that such a change
  will effect the value outside of the function.  This is a very
  useful characteristic of Lisp; it means that he variable
  ~number-of-rows~ can be used anywhere in the function where
  ~number-of-pebbles-in-row~ is used.

- Here is a second version of the function written a bit more cleanly:

  #+begin_src emacs-lisp
    (defun triangle (number)                ; Second version
      "Return sum of numbers 1 through NUMBER inclusive."

      (let ((total 0))
        (while (> number 0)
          (setq total (+ total-number))
          (setq number (1- number))
          total))
  #+end_src

- In brief, a properly written ~while~ loop will consist of three
  parts:

  1. A test will return false after the loop has repeated itself the
     correct number if times.

  2. An expression the evaluation of which will return the value
     desired after being repeatedly evaluated.

  3. An expression to change the value passed to the
     true-or-false-test so that the test return false after the loop
     has repeated itself the right number of times.

** Save your time: ~dolist~ and ~dotimes~

- In addition to ~while~, both ~dolist~ and ~dotimes~ provide for
  looping.  Sometimes these are quicker to written than the equivalent
  ~while~ loop.  Both are Lisp macros.  (See [[][Macros]] in The GNU
  Emacs Lisp Reference Manual.)

- ~dolist~ works like a ~while~ loop that CDRs down a list: ~dolist~
  automatically shortens the list each time it loop--takes the CDR of
  the list--and binds the CAR of each shorter version of the list to
  the first arguments.

- ~dotimes~ loops a specific number of times: you specify the number:

  - [[The ~dolist~ Macro][dolist]]
  - [[The ~dotimes~ Macro][dotimes]]

*** The ~dolist~ Macro

- Suppose, for example, you want to reserve a list, so that "first"
  "second" "third" becomes "third" "second" "first".

- In practice, you would use the ~reserve~ function, like this:

  #+begin_src emacs-lisp
(setq animals '(gazelle giraffe lion tiger))
(reverse animals)
  #+end_src

- Here is hoe you could reverse the list using a ~while~ loop:

  #+begin_src emacs-lisp
    (setq animals '(gazelle giraffe lion tiger))

    (defun reverse-list-with-while (list)
      "Using while, reverse the order of LIST."
      (let (value)      ; make sure lst starts empty
        (while list
          (setq value (cons (car list) value))
          (setq list (cdr list)))
        value))

    (reverse-list-with-while animals)
  #+end_src

- And here is how you could use the ~dolist~ macro:

  #+begin_src emacs-lisp
(setq animals '(gazelle giraffe lion tiger))

(defun reverse-list-with-dolist (list)
"Using dolist. reverse the order of LIST."
(let (value)    ; make sure list start empty
(dolist (element list value)
(setq value (cons element value)))))

(reverse-list-with-dolist animals)
  #+end_src

- In info, you can place your cursor after the closing parenthesis of
  each expression and type ~C-x C-e~; in each case, you should seeing

  #+begin_src emacs-lisp
    (tiger lion giraffe gazelle)
  #+end_src

  in the echo area.

- For this example, the existing ~reverse~ function is obviously best.
  The ~while~ loop is just like our first example (see [[][A ~while~
  Loop and a List]]).  The ~while~ first checks whether the list has
  elements; if so, construct a new list by adding the first element of
  the list to the existing list (which in the first iteration of the
  loop is ~nil~).  Since the second element is prepended in front of
  the first element, and the third element is prepended in front of
  the second element, the list is reserved.

- In the expression using a ~while~ loop, the ~(setq list (cdr list))~
  expression shortens the list, so the ~while~ loop eventually stops.
  In addition it provides the ~cons~ expression with a new first
  element by creating a new ans shorter list at each repetition of the
  loop.

- Like the example, the CAR of each shorter version of the list is
  referred to using the symbol '~element~', the list itself is called
  '~list~', and the value returned is called '~value~'.  The remainder
  of the ~dolist~ expression is the body.

- The ~dolist~ expression binds the CAR of each shorter version of the
  list to ~element~ and then evaluates the body of the expression; and
  repeats the loop.  The result is returned in ~value~.
*** The ~dotimes~ Macro

- The ~dotimes~ macro is similar to ~dolist~, except that it loops a
  specific number of times.

- The first argument to ~dotimes~ is assigned the number 0, 1, 2 and
  so forth each time around the loop.  You need to provide the value
  of the second argument, which is how many times the macro loops.

- For example, the following binds the numbers form 0 up to, but not
  including, the number 3 to the first argument, /number/, and then
  construct a list of the three numbers.  (The first number is 0, the
  second number is 1. and the third number is 2; this makes a total of
  three numbers in all, starting with zero as the first number.)

  #+begin_src emacs-lisp
    (let (value)                ; otherwise a value is a void variable
      (dotimes (number 3)
        (setq value (cons number value)))
      value)
    ⇒ (2 1 0)
  #+end_src


- The way to use ~dotimes~ is to operate on some expression /number/
  number of times and then return the result, either as a list or an
  atom.

- Here is an example of a ~defun~ that uses ~dotimes~ to add up the
  number of pebbles in a triangle.

  #+begin_src emacs-lisp
    (defun triangle-using-dotimes (number-of-rows)
      "Using `dotimes', add up the number of pebbles in a triangle."
      (let ((total 0))          ; otherwise a total is a void variable
        (dotimes (number number-of-rows)
          (setq total (+ total (1+ number))))
        total))

(triangle-using-dotimes 4)
  #+end_src

** Recursion

- A recursive function contains code that tells the Lisp interpreter
  to call a program that runs exactly like itself, but with slightly
  different arguments.  The code runs exactly the same because it has
  the same name.  However, even though the program has the same name,
  it is not the same entity.  It is different.  In the jargon, it is
  different "instance".

- Eventually, if the program is written correctly, the slightly
  different arguments will become sufficiently different from the
  first arguments that the final instance will stop.

  - [[Building Robots: Extending the Metaphor][Building Robots]]                Same model, different serial number ...

  - [[The Parts of a Recursive Definition][Recursive Definition Parts]]         Walk until you stop ...

  - [[Recursion with a list][Recursion with list]]                              Using a list as the test whether to recurse

  - [[Recursion in Place of a Counter][Recursive triangle function]]

  - [[Recursion Example using ~cond~][Recursion with cond]]

  - [[Recursive Patterns][Recursive pattern]]                                   Often used templates

  - [[Recursion without Deferments][No Deferment]]                              Don't store up work ...

  - [[No Deferment Solution][No deferment solution]]

*** Building Robots: Extending the Metaphor

- It is sometimes helpful to think of a running program as a robot
  that does a job.  In doing its job, a recursive function calls on a
  second robot to help it.  The second robot is identical to the firs
  in every way, except that the second robot helps the first and has
  been passed different argument than the first.

- In a recursive function, the second robot may call a third; and the
  third may call a fourth, and so on.  Each of these is a different
  entity; but all are clones.

- Since each robot has slightly different instructions--the arguments
  will differ from one robot to the next--the last robot should know
  when to stop.

- Let's expand on the metaphor in which a computer program is a robot.

- A function definition provides the blueprints for a robot.  When you
  install a function definition, that is, when you evaluate a ~defun~
  macro, you install the necessary equipment to build robots.  It is
  as if you were in a factory, setting up an assembly line.  Robots
  with the same name are built according to the same blueprints.  So
  they have the same model number, but a different serial number.

- We often say a recursive function "calls itself".  What we mean is
  that the instructions in a recursive function cause the Lisp
  interpreter to run a different function that has the same name and
  does the same job as the first, but with different arguments.

- It is important that the arguments differs from one instance to the
  next; otherwise, the process will never stop.
*** The Parts of a Recursive Definition

- A recursive function typically contains a conditional expression
  which has three parts:

  1. A true-or-false-test that determines whether the function is
     called again, here called the /do-again-test/.

  2. The name of the function.  When this name is called, a new
     instance of the function--a new robot, as it were-is created and
     told what to do.

  3. An expression that returns a different value each time the
     function is called, here called /next-step-expression/.
     Consequently, the argument (or arguments) passed to the new
     instance of the function will be different from that passed to
     the previous instance.  This cause the conditional expression,
     the /do-again-test/, to test false after the correct number of
     repetitions.

- Recursive functions can be much simpler than any other kind of
  function.  Indeed, when people first start to use them, they often
  look so mysteriously simple as to be incomprehensible.  Like riding
  a bicycle, reading a recursive function definition takes a certain
  knack which is hard at first but then seems simple.

- There are several different common recursive patterns.  A very
  simple pattern looks like this:

  #+begin_src emacs-lisp
    (defun name-of-recursive-function  (argument-list)
      "documentation..."
      (if do-again-test
          body...
        (name-of-recursive-function
         next-step-expression)))
  #+end_src

- Each time a recursive function is evaluated, a new instance of it is
  created and told what to do.  The arguments tell the instance what
  to do.

- An argument is bound to the value of the next-step-expression.  Each
  instance runs with a different value of the next-step-expression.

- The value in the next-step-expression is used in the do-again-test.

- The value returned by the next-step-expression is passed to the new
  instance of the function, which evaluate it (or some
  transmogrification of it) to determine whether to continue or stop.
  The next-step-expression is designed so that the do-again-test
  return false when the function should no longer be repeated.

- The do-again-test is sometimes called the /stop condition/, since it
  stops the repetitions when it test false.

*** Recursion with a list

- The example of a ~while~ loop that printed the elements of a list of
  numbers can be written recursively.  Here is the code, including an
  expression to set the value of the variable ~animals~ to a list.

- If you are reading this Info in Emacs, you can evaluate this
  expression in Info.  Otherwise, you must copy the example to the
  ~*scratch*~ buffer and evaluate each expression there.

- Use ~C-u C-x C-e~ to evaluate the ~(print-elements-recursively
  animals)~ expression so that the results are pinned in the buffer;
  otherwise the Lisp interpreter will try to squeeze the result into
  the one line of the echo area.

- Also, place your cursor immediately after the last closing
  parenthesis of the ~print-elements-recursively~ function, before the
  comment.  Otherwise, the Lisp interpreter will try to evaluate the
  comment.

  #+begin_src emacs-lisp
    (setq animals '(gazelle giraffe lion tiger))

    (defun print-elements-recursively (list)
      "Print each element of LIST on a line of its own.
    Uses recursion."
      (when list                        ; do-again-test
        (print (car list))              ; body
        (print-elements-recursively     ; recursive call
         (cdr list))))                  ; next-step-expression

(print-elements-recursively animals)
  #+end_srC

- The ~print-elements-recursively~ function first tests whether there
  is any content in the list; if there is, the function prints the
  first element of the list, the CAR of the list.  Then the function
  invokes itself, but gives itself as its argument, not the whole
  list, but the second and subsequent elements of the list, the CDR of
  the list.

- Put another way, if the list is not empty, the function invokes
  another instance of code that is similar to the initial code, but is
  a different thread of execution, with different arguments than the
  first instance.

- Put in yet another way, if the list is not empty, the first robot
  assembles a second robot and tells it what to do; the second robot
  is a different individual from the first, but is the same model.

- When the second evaluation occurs, the ~when~ expression is
  evaluated and if true, prints the first element of the list it
  receives as its arguments (which is the second element of the
  original list).  Then the function call itself with the CDR of the
  list it is invoked with, which (the second time around) is the CDR
  of the CDR of the original list.

- Note that although we say that the function "call itself", what we
  man is that the Lisp interpreter assembles and instructs a new
  instance of the program.  The new instance is a clone of the first,
  but is a separate individual.

- Each time the function invokes itself, it does do on a shorter
  version of the original list.  It creates a new instance that works
  on a shorter list.

- Eventually, the function invokes itself on an empty list.  It
  creates a new instance whose arguments is ~nil~.  The conditional
  expression tests the value of ~list~ is ~nil~, the ~when~ expression
  tests false so the then-part is not evaluated.  The function as a
  whole then returns ~nil~.

- When you evaluate the expression ~(print-elements-recursively
  animals)~ in the ~*scratch*~ buffer, you see this result:

  #+begin_src emacs-lisp
    gazelle

    giraffe

    lion

    tiger
    nil
  #+end_src

*** Recursion in Place of a Counter

- The triangle function described in a previous section can also be
  written recursively.  It looks like this:

  #+begin_src emacs-lisp
    (defun triangle-recursively (number)
      "Return the sum of the numbers 1 through NUMBER inclusive.
    Uses recursion."
      (if (= number 1)                  ; do-again-test
          1                             ; then-part
        (+ number                       ; else-part
           (triangle-recursively        ; recursive call
            (1- number)))))             ; next-step-expression

    (triangle-recursively 7)
  #+end_src

- You can install this function by evaluating it and then try it by
  evaluating ~(triangle-recursively 7).  (Remember to put your cursor
  immediately after the last parenthesis of the function definition,
  before the comment.)  The function evaluates to 28.

- To understand how this function works, let's consider what happen in
  the various cases when the function is passed 1, 2, 3, 4 as the
  value of the argument.

  - [[An argument of 1 or 2][Recursive Example arg of 1 or 2]]

  - [[An argument of 3 or 4][Recursive Example arg of 3 or 4]]

**** An argument of 1 or 2

- First, what happen if the value of the argument is 1?

- The function has an ~if~ expression after the documentation string.
  It test whether the value of ~number~ is equal to 1; if so, Emacs
  evaluates the *then-part* of the ~if~ expression, which returns the
  number 1 as the value of the function.  (A triangle with one row has
  one pebbles on it.)

- Suppose, however, that the value of the argument is 2.  In this
  case, Emacs evaluates the *else-part* of the ~if~ expression.

- The else-part consist of an addition, the recursive call to
  ~triangle-recursively~ and a decrementing action; and it looks like
  this:

  #+begin_src emacs-lisp
    (+ number (triangle-recursively (1- number)))
  #+end_src

- When Emacs evaluates this expression, the innermost expression is
  evaluated first; then the other parts in sequence.  Here the steps
  in detail:

  - Step 1 */Evaluate the innermost expression/*

    The innermost expression is ~(1- number)~ so Emacs decrement the
    value of ~number~ from 2 to 1

  - Step 2 */Evaluate the ~triangle-recursively~ function/*

    The Lisp interpreter creates an individual instance of
    ~triangle-recursively~.  It does not matter that this function is
    contained within itself.  Emacs passes the result Step 1 as the
    argument used by this instance of the ~triangle-recursively~
    function.

  - Step 3 */Evaluate the value of ~number~/*

    The variable ~number~ id the second element of the list that start
    with ~+~; its value is 2.

  - Step 4 */Evaluate the ~+~ expression/*

    The ~+~ expression receives two arguments, the first from the
    evaluation of ~number~ (Step 3) and the second from the evaluation
    of ~triangle-recursively~ (Step 2).

    The result of the addition is the sum of 2 plus 1, and the number
    3 is returned, which is correct.  A triangle with two rows has
    three pebbles in it.

**** An argument of 3 or 4

- Suppose that ~triangle-recursively~ is called with an argument of 3.

  - Step 1 */Evaluate the do-again-test/*

    The ~if~ expression is evaluated first.  This is the do-again-test
    and returns false, so the else-part is evaluated.  (Note that in
    this example, the do-again-test causes the function to call itself
    when it tests false, not when it tests true.)

  - Step 2 */Evaluate the innermost expression of the else-part

    The innermost expression of the else-part is evaluated, which
    decrement 3 to 2.  This is the next-step-expression.

  - Step 3 */Evaluate the ~triangle-recursively~ function/*

    The number 2 is passed to the ~triangle-recursively~ function.

    We already know what happens when Emacs evaluates
    ~triangle-recursively~ with an argument of 2.  After going through
    the sequence of actions described earlier, it returns a value
    of 3.  So that is what will happen here.

  - Step 4 */Evaluate the addition/*

    3 will be passed as an argument to the addition and will be added
    to the number with which the function was called, which is 3.

- The value returned by the function as whole will be 6.

- Now that we know what will happen when ~triangle-recursively~ is
  called with an argument of 3, it is evident what will happen if it
  is called with an argument of 4:

  In the recursive call, the evaluation of

    #+begin_src emacs-lisp
      (triangle-recursively (1- 4))
    #+end_src

  Will return the value of evaluating

    #+begin_src emacs-lisp
      (triangle-recursively 3)
    #+end_src

  Which is 6 and this value will be added to 4 by the addition in
  the third line.

- The value returned by the function as a whole will be 10.

- Each time ~triangle-recursively~ is evaluated, it evaluates a
  version of itself--a different instance of itself--with a smaller
  argument, until the argument is small enough so that it does not
  evaluate itself.

- Note that this particular design for a recursive function requires
  that operations be deferred.

- Before ~(triangle-recursively 7)~ can calculate its answer, it must
  call (triangle-recursively 6)~; and before ~(triangle-recursively
  6)~ can calculate its answer, it must call ~(triangle-recursively
  5)~; and so on.  That is to say, the calculation that
  ~(triangle-recursively 7)~ makes must be deferred until
  ~(triangle-recursively 6) makes its calculation; and
  ~(triangle-recursively 6)~ must defer until ~(triangle-recursively
  5)~ completes; and so on.

- If each of these instances of ~triangle-recursively~ are thought of
  as different robots, the first robot must wait for the second to
  complete its job, which must wait until the third completes, and so
  on.

- There is a way around this kind of waiting, which we will discuss in
  [[][Recursive without Deferments]].

*** Recursion Example using ~cond~

- The version of ~triangle-recursively~ described earlier is written
  with the ~if~ special form.  It can also be written using another
  special form called ~cond~.  The name of the special form ~cond~ is
  an abbreviation of word '~conditional~'.

- Although the ~cond~ special form is not used as often in the Emacs
  Lisp sources as ~if~, it used often enough to justify explaining it.

- The template for a ~cond~ expression looks like this:

  #+begin_src emacs-lisp
    (cond
     body...)
  #+end_src

- Where the /body/ is a series of lists.

- Written out more fully, the template looks like this:

  #+begin_src emacs-lisp
    (cond
     (first-true-or-false-test first-consequent)
     (second-true-or-false-test second-consequent)
     (third-true-or-false-test third-consequent)
     ...)
  #+end_src

- When the Lisp interpreter evaluates the ~cond~ expression, it
  evaluates the first element (the CAR or true-or-false-test) of the
  first expression in a series of expressions within the body of the
  ~cond~.

- If the true-or-false-test returns ~nil~ the rest of that expression,
  the consequent, is skipped and the true-or-false-test of the next
  expression is evaluated.  When an expression is found whose
  true-or-false-test returns a value that is not ~nil~, the consequent
  of that expression is evaluated.  The consequent can be one or more
  expressions.  If the consequent consists of more than one
  expression, the expressions are evaluated in sequence and the value
  of the last one is returned.  If the expression does not have
  consequent, the value of the true-or-false-test is returned.

- If none of the true-or-false-tests test true, the ~cond~ expression
  return ~nil~.

- Writing using ~cond~, the ~triangle~ function looks like this:

  #+begin_src emacs-lisp
    (defun triangle-using-cond (number)
      (cond ((<= number 0) 0)
            ((= number 1) 1)
            ((> number 1)
             (+ number (triangle-using-cond (1- number))))))
  #+end_src

- In this example, the ~cond~ returns 0 if the number is less than or
  equal to 0, it returns 1 if the number is 1 and its evaluates ~(+
  number (triangle-using-cond (1- number)))~ if the number is greater
  than 1.

*** Recursive Patterns

- Here are three common recursive pattern.  Each involve a list.
  Recursion does not need to involve list, but Lisp is designed for
  lists and this provides a sense of its primal capabilities.

  - [[Recursive Pattern: ~every~][Every]]
  - [[Recursive Pattern: ~accumulate~][Accumulate]]
  - [[Recursive Pattern: ~keep~][Keep]]
**** Recursive Pattern: ~every~

- In the ~every~ recursive pattern, an action is performed on every
  element of a list.

- The basic pattern is:

  - If a list be empty, return ~nil~

  - Else, act on the beginning of the list (the CAR of the list)

    - through a recursive call by the function on the rest (the CDR)
      of the list,

    - and, optionally, combine the acted-in element, using ~cons~,
      with the results of acting on the rest.

- Here is an example:

  #+begin_src emacs-lisp
    (defun square-each (number-list)
      "Square each of a NUMBER LIST, recursively."
      (if (not number-list)                     ; do-again-test
          nil
        (cons
         (* (car number-list) (car number-list))
         (square-each (cdr number-list)))))     ; next-step-expression

    (square-each '(1 2 3))
        ⇒ (1 4 9)
    (square-each '(4 5 6))
        ⇒ (16 35 36)
  #+end_src

- If the ~number-list~ is empty, do nothing.  But if it has content,
  construct a list combining the square of the first number in the
  list with the result of the recursively call.

- (The example follows the pattern exactly: ~nil~ is returned if the
  numbers' list is empty.  In practice, you would write the
  conditional so it carries out the action when the numbers' list is
  not empty.)

- The ~print-elements-recursively~ function (see [[][Recursive with a
  list]]) is another example of an ~every~ pattern, except in this
  case, rather than bring the result together using ~cons~, we print
  each element of output.

- The ~print-elements-recursively~ function looks like this:

  #+begin_src emacs-lisp
    (setq animals '(gazelle giraffe lion tiger))

    (defun print-elements-recursively (list)
      "Print each element of LIST on a line of its own.
    Uses recursion."
      (when list
        (print (car list))
        (print-elements-recursively
         (cdr list))))

    (print-elements-recursively animals)
  #+end_src

- The pattern for ~print-elements-recursively~ is:

  - When the list is empty, do nothing.

  - But when the list has at least one element

    - act on the beginning of the list (the CAR of the list)

    - and make a recursive call on the rest (the CDR) of the list

**** Recursive Pattern: ~accumulate~

- Another recursive pattern is called the ~accumulate~ pattern.  In
  the ~accumulate~ recursive pattern, an action is performed on every
  element of a list and the result of that action is accumulated with
  the results of performing the action on the other elements.

- This is very like the ~every~ pattern using ~cons~, except that
  ~cons~ is not used, but some other combiner.

- The pattern is:

  - If a list empty, return zero or some other constant.

  - Else, act on the beginning of the list (the CAR of the list),

    - and combine that acted-on element, using ~+~ or some other
      combination function, with

    - a recursive call by the function on the rest (the CDR) of the
      list.

- Here is an example:

  #+begin_src emacs-lisp
    (defun add-elements (numbers-list)
      "Add the elements of NUMBER-LIST together."
      (if (not numbers-list)
          0
        (+ (car numbers-list) (add-elements (cdr numbers-list)))))

    (add-elements '(1 2 3 4))
        ⇒ 10
  #+end_src

- See [[][Making a List of Files]], for an example of the accumulate
  pattern.

**** Recursive Pattern: ~keep~

- A third recursive pattern is called the ~keep~ pattern.  In the
  ~keep~ recursive pattern, each element of a list is tested; the
  element is acted on and the results are kept only if the element
  meets a criterion.

- Again, this is very like the ~every~ pattern, except the element is
  skipped unless it meets a criterion.

- The pattern has three parts:

  - If a list be empty, return ~nil~

  - Else, if the beginning of the list (the CAR of the list) passes a
    test

    - act on that element and combine it, using ~cons~ with

    - recursive call by the function on the rest (the CDR) of the list.

  - Otherwise, if the beginning of he list (the CAR of the list) fails
    the test

    - skip on that element,

    - and, recursively call the function on the rest (the CDR) of the list.

- Here is an example that uses ~cond~:

  #+begin_src emacs-lisp
    (defun keep-three-letter-words (word-list)
      "Keep three letter word in WORD-LIST."

      (cond
       ;; First do-again-test: stop-condition
       ((not word-list) nil)

       ;; Second do-again-test: when to acte
       ((eq 3 (length (symbol-name (car word-list))))
        ;; combine acted-on element with recursive call on shorter list
        (cons (car word-list) (keep-three-letter-words (cdr word-list))))

       ;; Third do-again-test: when to skip element;
       ;;   recursively vall shorter list with next-step expression
       (t (keep-three-letter-words (cdr word-list)))))

    (keep-three-letter-words '(one two three four five six))
        ⇒ (one two six)
  #+end_src

*** Recursion without Deferments

- Let's consider again what happens with the ~triangle-recursively~
  function.  We will find that the intermediate calculations are
  deferred until all can be done.

- Here is the function definition:

  #+begin_src emacs-lisp
    (defun triangle-recursively (number)
      "Return the sum of the numbers 1 through NUMBER inclusive.
    Uses recursion."
      (if (= number 1)                  ; do-again-test
          1                             ; then-part
        (+ number                       ; else-part
           (triangle-recursively        ; recursive call
            (1- number)))))             ; next-step-expression
  #+end_src

- What happen when we call this function with an argument of 7?

- The first instance of the ~triangle-recursively~ function adds the
  number 7 to the value returned by a second instance of
  ~triangle-recursively~, an instance that has been passed an argument
  of 6, that is to say, the first calculation is:

  #+begin_src emacs-lisp
    (+ 7 (triangle-recursively 6))
  #+end_src

- The first instance of the ~triangle-recursively~--you may want to
  think of it as a little robot--cannot complete its jobs.  It must
  hand off the calculation for ~(triangle-recursively 6)~ to a second
  instance of the program, to a second robot.  This second individual
  is completely different from the first one; it is, in the jargon, a
  "different instantiation".  Or, put another way, it is a different
  robot.  It is the same model as the first; it calculates triangle
  numbers recursively; but it has a different serial number.

- And what does ~(triangle-recursively 6)~ return? It returns the
  number 6 added to the value returned by evaluating
  ~triangle-recursively~ with an argument of 5.  Using the robot
  metaphor, it asks yet another robot to help it.

- Now the total is:

  #+begin_src emacs-lisp
    (+ 7 6 (triangle-recursively 5))
  #+end_src

- And what happen next?

  #+begin_src emacs-lisp
    (+ 7 6 5 (triangle-recursively 4))
  #+end_src

- Each time ~triangle-recursively~ is called, except for the last
  time, it creates another instance of the program--another robot--ans
  asks it to make a calculation.

- Eventually, the full addition is set up and performed:

  #+begin_src emacs-lisp
    (+ 7 6 5 4 3 2 1)
  #+end_src

- This design for the function defers the calculation of the first
  step until the second can be done, and defers that until the third
  can be done, and so on.  Each deferment means the computer must
  remember what is being waited on.  This is not a problem when there
  are only a few steps, as in this example.  But it can be a problem
  when there are more steps.

*** No Deferment Solution

- The solution to the problem of deferred operations is to write in a
  manner that does not defer operation (the phrase /tail recursive/ is
  used to describe such a process, one that uses constant space).
  This requires writing to a different pattern, often one that
  involves writing two function definitions, an initialization
  function and a helper function.

- Here are two function definitions for adding up numbers.  They are
  so simple.  I find them hard to understand.

  #+begin_src emacs-lisp
    (defun triangle-initialization (number)
      "Return the sum of the numberrs 1 through NUMBER inclusive.
    This initialization component of a two function
    duo that uses recursion."
      (triangle-recursive-helper 0 0 number))
  #+end_src

  #+begin_src emacs-lisp
    (defun triangle-recursive-helper (sum counter number)
      "Return SUM, using COUNTER, through NUMBER inclusive.
    This is the helper component of a two function duo
    that uses recursion."
      (if (> counter number)
          sum
        (triangle-recursive-helper (+ sum counter)  ; sum
                                   (1+ counter)     ; counter
                                   number)))        ; number
  #+end_src

- Install both function definitions by evaluating them, then call
  ~triangle-initialization~ with 2 rows:

  #+begin_src emacs-lisp
    (triangle-initialization 2)
        ⇒ 3
  #+end_src

- The initialization functions calls the first instance of the helper
  function with three arguments: zero, zero, and a number which is the
  number of rows in the triangle.

- The first two arguments passed to the helper function are
  initialization values.  These values are changed when
  ~triangle-recursive-helper~ invokes new instances.  (The jargon is
  mildly confusing: ~triangle-recursive-helper~ uses a process that is
  iterative in a procedure that is recursive.  The process is called
  iterative because the computer need only record the three values,
  ~sum~, ~counter~, and ~number~; The procedure is recursive because
  the function calls itself.  On the other hand, both the process and
  the procedure used by ~triangle-recursively~ are called recursive.
  The word "recursive" has different meanings in the two contexts.)

- Let's see what happen when we have a triangle that has one row.
  (This triangle will have one pebble in it!)

- ~triangle-initialization~ will call its helper with the arguments ~0
  0 1~.  That function will run the conditional test whether ~(>
  counter number)~:

  #+begin_src emacs-lisp
    (> 0 1)
  #+end_src


- and find that result is false, so it will invoke the else-part of
  the ~if~ clause:

  #+begin_src emacs-lisp
    (triangle-recursive-helper
     (+ sim counter)            ; sum plus counter ⇒ sum
     (1+ counter)               ; increment counetr ⇒ counter
     number)                    ; number stays the same
  #+end_src

- Which will first compute:

  #+begin_src emacs-lisp
    (triangle-recursive-helper (+ 0 0)  ; sum
                               (1+ 0)   ; counter
                               1)       ; number

    ;;which is:
    (triangle-recursive-helper 0 1 1)
  #+end_src

- Again, ~(> counter number)~ will be false, so again, the Lisp
  interpreter will evaluate ~triangle-recursive-helper~, creating a
  new instance with new arguments.

- This new instance will be;

  #+begin_src emacs-lisp
    (triangle-recursive-helper
     (+ sum counter)         ; sum plus counter ⇒ sum
     (1+ counter)            ; increment counter ⇒ counter
     (number)                ; number stays the same

     ;; which is
     (triangle-recursive-helper 1 2 1)
  #+end_src

- In this case, the ~(> counter number)~ test will be true!  So the
  instance will return the value of the sum, which will be 1, as
  expected.

- Now, let's pass ~triangle-initialization~ an argument of 2, to find
  out how many pebbles there are in a triangle with two rows.

- That function calls ~(triangle-recursive-helper 0 0 2)~.

- In stages, the instance called will be:

  #+begin_src emacs-lisp
                            ;;sum  counter  number
    (triangle-recursive-helper 0       1        2)
    (triangle-recursive-helper 1       2        2)
    (triangle-recursive-helper 3       3        2)

  #+end_src

- When the last instance is called, the ~(> counter number)~ test will
  be true, so the instance will return the value of ~sum~, which will
  be 3.

- This kind of pattern helps when you are writing functions that can
  use many resource in a computer.


* Regular Expression Searches

- Regular expression searches are used extensively in GNU Emacs. The
  two functions, ~forward-sentence~ and ~forward-paragraph~,
  illustrate these searches well.  They use regular expressions to
  find where to move point.  The phrase "regular expression" is often
  written as "regexp".

- Regular expression searches are describes in [[][Regular Expression
  Search]] in the GNU Emacs Manual, as ell as in [[][Regular
  Expression]] in The GNU Emacs Lisp Reference Manual.  In writing
  this chapter, I am presuming that you have at least a mild
  acquaintance with them.  The major point to remember is that regular
  expressions permit you to search for patterns as well as for literal
  string or characters.  For example, the code in ~forward-sentence~
  searches for the pattern of possible characters that could mark the
  end of the sentence, and moves point to that spot.

- Before looking at the code for the ~forward-sentence~ function, it
  is worth considering what the pattern that marks the end of a
  sentence must be.  The pattern is discussed in the next section;
  following that is a description of the regular expression search
  function, ~re-search-forward~.  The ~forward-sentence~ function
  describe in the section following.  Finally, the ~forward-paragraph~
  function is described in the last section of this chapter.
  ~forward-paragraph~ is a complex function that introduces several
  new features.

  - [[The Regular Expression for ~sentence-end~][sentence-end]]                 The regular expression for ~sentence-end~

  - [[The ~re-search-forward~ Function][re-search-forward]]                     Very similar to ~search-forward~

  - [[~forward-sentence~][forward-sentence]]                                    A straightforward example of regexp search

  - [[~forward-paragraph~: a Goldmine of Function][forward-paragraph]]          A somewhat complex example

  - [[Review][Regexp Review]]

** The Regular Expression for ~sentence-end~

- The symbol ~sentence-end~ is bound to the pattern that marks the end
  of a sentence.  What should this regular expression be?

- Clearly, a sentence may be ended by a period, a question mark, or an
  exclamation mark.  Indeed, in English, only clauses that end with
  one of those three characters should be considered the end of a
  sentence.  This means that the pattern should include the character
  set:

  #+begin_src emacs-lisp
    [.?!]
  #+end_src

- However, we do not want ~forward-sentence~ merely to jump a period,
  a question mark, or an exclamation mark, because such a character
  might be used in the middle of a sentence.  A period, for example,
  is used after abbreviations.  So other information is needed.

- According to convention, you type two spaces after every sentence,
  but only one space after a period, a question mark, or an
  exclamation mark in the body of a sentence.  So a period, a question
  mark, or an exclamation mark followed by two spaces is good
  indicator of an end of sentence.  However, in a file, the two spaces
  may instead be a tab or the end of a line.  This is means that the
  regular expression should includes these three items as
  alternatives.

- This group of alternatives will look like this:

  #+begin_src emacs-lisp
    \\($\\| \\|  \\)
           ^   ^^
          TAB  SPC
  #+end_src

- Here, '~$~' indicates the end of the line, and I have pointed out
  where tab and two spaces are inserted in the expression.  Both are
  inserted by putting the actual characters into the expression.

- Two backslashes, '~\\~', are required before the parentheses and
  vertical bars: the first backslashes quotes the following
  backslashes in Emacs; and the second indicates that the following
  character, the parenthesis or the vertical bar, is special.

- Also, a sentence may be followed by one or more carriage returns,
  like this:

  #+begin_src emacs-lisp
    [
     ]*
  #+end_src

- Like tabs and spaces, a carriage returns is inserted into a regular
  expression by inserting it literally.  The asterisk indicates that
  the ~RET~ is repeated zero or more times.

- But a sentence end does not consist only of a period, a question
  mark or an exclamation mark followed by appropriate space: a closing
  quotation mark or a closing brace of some kind my precede the space.
  Indeed more than one such mark or brace may precede the space.
  These require a expression that looks like this:

  #+begin_src emacs-lisp
    []\"')}]*
  #+end_src

- In this expression, the first '~]~' is the first character in the
  expression; the second character is '~"~', which is precedes by a
  '~\~' to tell Emacs the '~"~' is /not/ special.  The last three
  characters are '~'~','~)~', and '~}~'.

- all this suggest what the regular expression pattern for matching
  the end of a sentence should be; and, indeed, if we evaluate
  ~sentence-end~ we find that it returns the following value:

  #+begin_src emacs-lisp
    sentence-end
    ⇒ "[.?!][]\"')}]*\\($\\|     \\|  \\)[
    ]*"
  #+end_src

- (Well, not in GNU Emacs 22; that is because of an effort to make the
  process simpler and to handle more glyph and languages.  When the
  value of ~sentence-end~ is ~nil~, then use the value defined by the
  function ~sentence-end~.  (Here is use of the difference between a
  value and a function in Emacs Lisp.)  The function returns a value
  constructed from the variable ~sentence-end-base~,
  ~sentence-end-double-space~, ~sentence-end-without-period~, and
  ~sentence-end-without-space~.  The critical variable is
  ~sentence-end-base~; its global value is similar to the one
  described above but it also contains two additional quotation marks.
  These have differing degrees of curliness.  The
  ~sentence-end-without-period~ variable, when true, tells Emacs that
  a sentence may end without a period, such as text in Thai.)

** The ~re-search-forward~ Function

- The ~re-search-forward~ function is very like the ~search-forward~
  function.  (See [[][The ~search-forward~ Function]].)

- ~re-search-forward~ searches for a regular expression.  If the
  search is successful, it leaves point immediately after the last
  character in the target.  If the search is backwards, it leaves
  point just before the first character in the target.  You may tell
  ~re-search-forward~ to return ~t~ for true.  (Moving point is
  therefore a side effect.)

- Like ~search-forward~, the ~re-search-forward~ function takes four
  arguments:

  - The first argument is the regular expression that the function
    searches for.  The regular expression will be string between
    quotation marks.

  - The optional second argument limits how far the function will
    search; it is a bound, which is specified as a position in the
    buffer.

  - The optional third argument specifies how the function responds to
    failure: ~nil~ as the third argument causes the function to signal
    error (and print a message) when the search fails; any other value
    causes it to return ~nil~ if the search fails and ~t~ if the
    search succeeds.

  - The optional fourth argument is the repeat count.  A negative
    repeat count causes ~re-search-forward~ to search backwards.

- The template for ~re-search-forward~ looks like this:

  #+begin_src emacs-lisp
    (re-search-forward "regular-expression"
                       limit-of-search
                       what-to-do-if-search-fails
                       repeat-count)
  #+end_src

- The second, third, and fourth arguments are optional.  However, if
  you want to pass a value to either or both of the last two
  arguments, you must also pass a value to all preceding arguments.
  Otherwise, the Lisp interpreter will mistake which argument you are
  passing the value to.

- In the ~forward-sentence~ function, the regular expression will be
  the value of the variable ~sentence-end~.  In simple form, that is:

  #+begin_src emacs-lisp
    "[.?!][]\"')}]*\\($\\|  \\|  \\)[
    ]*"
  #+end_src

- The limit of the search will be the end of the paragraph (since a
  sentence cannot go beyond a paragraph).  If the search fails, the
  function will return ~nil~; and the repeat count will be provided by
  argument to the ~forward-sentence~ function.
** ~forward-sentence~

- The command to move the cursor forward a sentence is a
  straightforward illustration of how to use regular expression
  searches in Emacs Lip.  Indeed, the function looks longer and more
  complicated than it is; this is because the function is designed to
  go backwards as well as forwards; and, optionally, over more than
  one sentence.  The function is usually bound to the key command ~M-e~.

  - [[Complete ~forward-sentence~ function definition][Complete forward-sentence]]
  - [[The ~while~ loops][fwd-sentence while loops]]                     Two ~while~ loops
  - [[The regular expression search][fwd-sentence re-search]]           A regular expression search
*** Complete ~forward-sentence~ function definition

- Here is the code for ~forward-sentence~:

  #+begin_src emacs-lisp
    (defun forward-sentence (&optional arg)
      "Move forward to next end of sentence.  With argument, repeat.
    With negative argument, move backward repeatedly to start of sentence.

    The variable `sentence-end' is a regular expression that matches ends of
    sentences.  Also, every paragraph boundary terminates sentence as well."

      (interactive "p")
      (or arg (setq arg 1))
      (let ((opoint (point))
            (sentence-end (sentence-end)))
        (while (< arg 0)
          (let ((pos (point))
                (par-beg (sve-excursion (start-of-paragraph-text) (point))))
            (if (and (re-search-backward sentence-end par-beg t)
                     (or (< (match-end 0) pos)
                         (re-search-backward sentence-end par-beg t)))
                (goto-char (match-end 0))
              (goto-char par-beg)))
          (setq arg (1+ arg)))
        (while (> arg 0)
          (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            (if (re-search-forward sentence-end par-end t)
                (skip-chars-backward "\t\n")
              (goto-char par-end)))
          (setq arg (1- arg)))
        (constrain-to-field nil point t)))
  #+end_src

- The function looks long at first sight and it is best to look at its
  skeleton first, and then its muscle.  The way to see the skeleton is
  to look at the expression that start in the left-most columns:

  #+begin_src emacs-lisp
    (defun forward-sentence (&optional arg)
      "documentation..."
      (interactive "p")
      (or arg (setq arg 1))
      (let ((opoint (point)) (sentence-end (sentence-end)))
        (while (< arg 0)
          (let ((pos (point))
                (par-beg (save-excursion (start-of-paragraph-text) (point))))
            rest-of-body-of-while-loop-when-going-backwards
            (while (> arg 0)
              (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
                rest-of-body-of-while-loop-when-going-forwards
            handle-forms-and-equivalent
  #+end_src

- This looks much simpler!  The function definition consists of
  documentation, an ~interactive~ expression, an ~or~ expression, a
  ~let~ expression, and ~while~ loops.

- Let's look at each of these parts in turn.

- We note that the documentation is thorough and understandable.

- The function has an ~interactive "p"~ declaration.  This mean that
  the processed prefix argument, if any, is passed to the function as
  its argument.  (This will be a number.)  If the function is not
  passed an argument (it is optional) then the argument ~arg~ will be
  bound to 1.

- When ~forward-sentence~ is called non-interactively without an
  argument, ~arg~ is bound to ~nil~.  The ~org~ expression handles
  this.  What it does is either leave the value of ~arg~ as it is, but
  only if ~arg~ is bound to a value; or it sets the value of ~arg~
  to 1, in this case when ~arg~ is bound to ~nil~.

- Next is a ~let~.  That specifies the values of two local variables,
  ~opoint~ and ~sentence-end~.  The local value of point, from before
  the search, is used in the ~constrain-to-field~ function which
  handles forms and equivalents.  The ~sentence-end~ variable is set
  by the ~sentence-end~ function.

*** The ~while~ loops

- Two ~while~ loops follow.  The first ~while~ has a
  true-or-false-test that test true if the prefix argument for
  ~forward-sentence~ is a negative number.  This is for going
  backwards.  The body of this loops is similar to the body of the
  second ~while~ clause, but it is not exactly the same.  We will skip
  this ~while~ loop and concentrate on the second ~while~ loop.

- The second ~while~ loop is for moving point forward.  Its skeleton
  looks like this:

  #+begin_src emacs-lisp
    (while (< arg 0)            ; true-or-false-test
      (let varlist
        (if (true-or-false-test)
            then-part
          else-part
     (setq arg (1- arg))))      ; while loop decrement
  #+end_src

- The ~while~ loop is decrementing kind.  (See [[][A Loop with a
  Decrementing Counter]].)  It has a true-or-false-test that test true
  so long as the counter (in this case, the variable ~arg~) is greater
  than zero; and it has decrementer that subtract 1 from the value of
  the counter every time the loop repeats.

- If no prefix argument is given to ~forward-sentence~, which is the
  most common way the command is used, this ~while~ loop will run
  once, since the value of ~arg~ will be 1.

- The body of the ~while~ loop consist of a ~let~ expression, which
  creates and bind a local variable, and has, as its body, an ~if~
  expression.

- The body of the ~while~ loop likes this:

  #+begin_src emacs-lisp
    (let ((par-end
           (save-excursion (end-of-paragraph-text) (point))))
      (if (re-search-forward sentence-end par-end t)
          (skip-chars-backwards " \t\n")
        (goto-char par-end)))
  #+end_src

- The ~let~ expression creates and binds the local variable ~par-end~.
  As we shall see, this local variable is designed to provide a bound
  or a limit to the regular expression search.  If the search fails to
  find a proper sentence ending in the paragraph, it will stop on
  reaching the end of the paragraph.

- But first, let us examine how ~par-end~ is bound to the value of the
  end of the paragraph.  What happens is that the ~let~ sets the value
  of ~par-end~ to the value returned when the Lisp interpreter
  evaluates the expression:

  #+begin_src emacs-lisp
    (save-excursion (end-of-paragraph-text) (point))
  #+end_src

- In this expression, ~(end-to-paragraph-text)~ moves point to the end
  of the paragraph, ~(point)~ returns the value of point, and then
  ~save-excursion~ restore point to its original position.  Thus, the
  ~let~ binds ~par-end~ to the value returned by the ~save-excursion~
  expression, which is the position of the end of the paragraph.  (The
  ~end-of-paragraph-text~ function uses ~forward-paragraph~ which we
  will discuss shortly.)

- Emacs next evaluates the body of the ~let~, which is an ~if~
  expression that looks like this:

  #+begin_src emacs-lisp
    (if (re-search-forward sentence-end par-end t)      ; if-part
        (skip-chars-backward " \t\n")                   ; then-part
      (goto-char par-end)))                             ; else-part
  #+end_src

- The ~if~ test whether is first argument is true and if so, evaluates
  its then-part; otherwise, the Emacs Lisp interpreter evaluates the
  else-part.  The true-or-false-test of the ~if~ expression is the
  regular expression search.

- It may seem odd to have what looks like the real work of
  ~forward-sentence~ function buried here, but this is a common way
  this kind of operations is carried out in Lisp.

*** The regular expression search

- The ~re-search-forward~ function searches for the end of the
  sentence, that is, for the pattern defined by the ~sentence-end~
  regular expression.  If the pattern is found--if the end of the
  sentence is found--then the ~re-search-forward~ function does two
  thing:

  1. The ~re-search-forward~ function carried out a side effect, which
     is to move point to the end of the occurrence found.

  2. The ~re-search-forward~ function returns a value of true.  This
     is the value received by the ~if~, and means that the search was
     successful.

- The side effect, the movement of point, is completed before the ~if~
  function is handed the value returned by the successful conclusion
  of the search.


- When the ~if~ function receives the value of true from a successful
  call to ~re-search-forward~, the ~if~ evaluates the then-part, which
  is the expression ~(skip-chars-backward " \t\n")~.  This expression
  moves backwards over any spaces, tabs or carriage returns until a
  printed is found and then leaves point after the character.  Since
  point already been moved to the end of the pattern that marks the
  end of the sentence, this action leaves point right after the
  closing printed character of the sentence, which usually a period.

- On the other hand, if the ~re-search-forward~ function fails to find
  a pattern marking the end of the sentence, the function return
  false.  The false then causes the ~if~ to evaluate its third
  argument, which is ~(goto-char par-end)~; it moves point to the end
  of the paragraph.

- (And if the text is a form or equivalent, and point may not move
  fully, then the ~constrain-to-field~ function come into play.)

- Regular expression searches are exceptionally useful and the pattern
  illustrates by ~re-search-forward~, in which the search is the test
  of an ~if~ expression, is handy.  You will see or write code
  incorporating this pattern often.

** ~forward-paragraph~: a Goldmine of Function

- The ~forward-paragraph~ function moves point forward to the end of
  the paragraph.  It usually bound to ~M-}~ and makes use of a number
  of function that are important in themselves, including ~let~,
  ~match-beginning~, and ~looking-at~.

- The function definition for ~forward-paragraph~ is considerably
  longer than the function definition for ~forward-sentence~ because
  it works with a paragraph, each line of which may begin with a fill
  prefix.

- A fill prefix of a string of characters that are repeated at the
  beginning of each line.  For example, in Lisp code, it is a
  convention to start each line of which may begin with a fill prefix.

- A fill prefix consist of a string of characters that are repeated at
  the beginning of each line.  for example, in Lisp code, it is
  convention to start each line of a paragraph-long comment with '~;;;
  ~'.  In text mode, four blank spaces makes up another common fill
  prefix, creating an indented paragraph.  (See [[][Fill Prefix]] in
  the GNU Emacs Manual, for more information about fill prefixes.)

- The existence of a fill prefix means that in addition to being able
  to find the end of the paragraph whose lines begin on the left-most
  column, the ~forward-paragraph~ function must be able to fund the
  end of a paragraph when all or many of the lines in the buffer begin
  with the fill prefix.

- Moreover, it is sometimes practical to ignore a fill prefix that
  exists, especially when blank lines separate paragraphs.  This is an
  added complication.

  - [[Shortened ~forward-paragraph~ function definition][forward-paragraph in brief]]           Key parts of the function definition
  - [[The ~let*~ expression][fwd-para let]]                                                     the ~let*~ expression
  - [[The forward motion ~wile~ loop][fwd-para while]]                                          The forward motion ~while~ loop

*** Shortened ~forward-paragraph~ function definition

- Rather than print all of the ~forward-paragraph~ function, we will
  only print parts of it.  Read without preparation, the function can
  be daunting!

- In outline, the function looks like this:

  #+begin_src emacs-lisp
    (defun forward-paragraph (&optional arg)
      "documentation..."
      (interactive "p")
      (or arg (setq arg 1))
      (let*
          varlist
        (while (and (< arg 0) (not  (bobp)))    ; backward-moving-code
          ...
        (while (and (> arg 0) (not bobp)))      ; forward-moving-code
          ...
  #+end_src

- The first parts of the function are routine: the function's argument
  list consists of one optional argument.  Documentation follows.

- The lower case '~p~' in the ~interactive~ declaration means that the
  processed prefix argument, if any, is passed to the function.  This
  will be a number, and is the repeat count of how many paragraphs
  point will move.  The ~or~ expression line handles the common case
  when no argument is passed to the function, which occurs if the
  function is called from other code rather than interactively.  This
  case was described earlier.  (See [[][The ~forward-sentence
  function]].)  Now we reach the end of the familiar part of this
  function.

*** The ~let*~ expression

- The next line of the ~forward-paragraph~ function begins a ~let*~
  expression.  This is different from ~let~.  The symbol is ~let*~ not
  ~let~.

- The ~let*~ special form is like ~let~ except that Emacs sets
  variable in sequence, one after another, and variables on the latter
  part of the varlist can make use of the values to which Emacs set
  variables in the earlier part of the varlist.

- ([[]~save-excursion~ in ~append-to-buffer]])

- In the ~let*~ expression in this function, Emacs binds a total of
  seven variables: ~opoint~, ~fill-prefix-regexp~, ~parstart~,
  ~parsep~, ~sp-parstart~, ~start~, and ~found-start~.

- The variable ~parsep~ appears twice, first, to remove instances of
  '~^~', and second, to handle fill prefixes.

- The variable ~opoint~ is just the value of ~point~.  As you can
  guess, it used in a ~constrain-to-field~ expression, just as in
  ~forward-sentence~.

- The variable ~fill-prefix-regexp~ is set to the value returned by
  evaluating the following list:

 #+begin_src emacs-lisp
   (and fil-prefix
        (not (equal fill-prefix ""))
        (not paragraph-ignore-fill-prefix)
        (regexp-quote fill-prefix))
 #+end_src

- This is an expression whose first element is the ~and~ special form.

- As we learned earlier (See [[][The ~kill-new~ function]]), the ~and~
  special form evaluates each of its arguments until one of the
  arguments returns a value of ~nil~, in which case the ~and~
  expression returns ~nil~, if none of the arguments returns a value
  of ~nil~, the value resulting from evaluating the last argument is
  returned.  (Since such a value is not ~nil~, it is considered true
  in Lisp.)  In other words, an ~and~ returns a true value only if all
  its arguments are true.

- In this case, the variable ~fill-prefix-regexp~ is bound to a
  non-~nil~ value only if the following four expression produce a true
  (i.e., a non-~nil~) value when they are evaluated; otherwise,
  ~fill-prefix-regexp~ is bound to ~nil~.

  - *~fill-prefix~*

    When this variable is evaluated, the value of the fill prefix, if
    any, is returned.  If there is no fill prefix, this variable
    returns ~nil~.

  - *~(not (equal fill-prefix "")~*

    This expression checks whether an existing fill prefix is an empty
    string, that is, a string with no characters in it.  An empty
    string is not a useful fill prefix.

  - *~(not paragraph-ignore-fill-prefix)~*

    This expression returns ~nil~ if the variable
    ~paragraph-ignore-fill-prefix~ has been turned on by being set to
    a true value such as ~t~.

  - *~(regexp-quote fill-prefix)~*

    This is the last argument to the ~and~ special form.  If all the
    argument to the ~and~ are true, the value resulting from
    evaluating this expression will be returned by the ~and~
    expression and bound to the variable ~fill-prefix-regexp~.

- The result of evaluating this ~and~ expression successfully is that
  ~fill-prefix-regexp~ will be bound to the value of ~fill-prefix~ as
  modified by the ~regexp-quote~ function.  What ~regexp-quote~ does
  is read a string and return a regular expression that will exactly
  match the string and match nothing else.  This means that
  ~fill-prefix-regexp~ will be set to a value that will exactly match
  the fill prefix if the fill prefix exists.  Otherwise, the variable
  will be set to ~nil~.

- The next two local variable in the ~let*~ expression are designed to
  remove instance of '~^~' from ~parstart~ and ~parsep~, the local
  variables which indicate the paragraph start and paragraph
  separator.  The next expressions sets ~parsep~ again.  That is to
  handle fill prefixes.

- This is the setting that requires the definition call ~let*~ rather
  than ~let~.  The true-or-false-test for the ~if~ depends on whether
  the variable ~fill-prefix-regexp~ evaluates to ~nil~ or some other
  value.

- If ~fill-prefix-regexp~ does not have a value, Emacs evaluates the
  else-part of the ~if~ expression and binds ~parsep~ to its local
  value.  (~parsep~ is a regular expression that matches what
  separates paragraphs.)

- But if ~fill-prefix-regexp~ does have a value, Emacs evaluates the
  then-part of the ~if~ expression and binds ~parsep~ to a regular
  expression that includes the ~fill-prefix-regexp~ as part of the
  pattern.

- Specifically, ~parsep~ is set to the original value of the paragraph
  separate regular expression concatenated with an alternatives
  expression that consists of the ~fll-prefix-regexp~ followed by
  optional whitespace to the end of the line.  The whitespace is
  defined by ~" [ \t]*$")~.  The '~\\|~' defines this portion of the
  regexp as an alternative to ~parsep~.

- According to a comment in the code, the next local variable,
  ~sp-parstart~, is used for searching, and then the final two,
  ~start~ and ~found-start~, are set to ~nil~.

- Now we get into the body of the ~let*~.  The first part of the body
  of the ~let*~ deals with the case when the function is given a
  negative argument and is therefor moving backwards.  We will skip
    this section.
*** The forward motion ~wile~ loop

- The second part of the body of the ~let*~ deals with forward motion.
  It is a ~while~ loop that repeats itself as long as the value of
  ~arg~ is greater than zero.  In the most common use of the function,
  the value of the argument is 1, so the body of the ~while~ loop is
  evaluated exactly once, and the cursor moves forward one paragraph.

- this part handles three situation: when point is between paragraphs,
  when there is a fill prefix and when there is no fill prefix.

- The ~while~ loop looks like this:

  #+begin_src emacs-lisp
    ;; going forward and not at the end of the buffer
    (while (and (> arg 0) (not (eobp)))

      ;; between paragraphs
      ;; Move forward over separator line...
      (while (and (not eobp))
        (progn (move-to-left-margin) (not (eobp)))
        (looking-at parsep))
      (forward-line 1))
    ;;  this decrements the loop
    (unless (eobp) (setq arg (1- arg)))
    ;; ... and one more line
    (forward-line 1)

    (if fill-prefix-regexp
        ;; There is a fill prefix; it overrides parstart'
        ;; we go forward line by line
        (while (and (not (eobp))
                    (progn (move-to-left-margin) (not (eobp)))
                    (not (looking-at parsep)
                         (looking-at fill-prefix-regexp))
                    (forward-line 1))


          ;; There is no fill prefix;
          ;; we go forward character by character
          (while (and (re-search-forward sp-parstart nil 1)
                      (progn (setq start (match-beginning 0))
                             (goto-char start)
                             (not (eobp)))
                      (progn (move-to-left-margin)
                             (not (looking-at parsep)))
                      (or (not (looking-at parstart))
                          (and use-hard-newlines
                               (not (get-text-propert (1- start) 'hard)))))
            (forward-char 1))
          ;; and if there is no fill prefix and if we are not at the end,
          ;;     go to whatever was found in the regular expression search
          ;;     for sp-parstart
          (if (< point) (point-max))
              (goto-char start))))
  #+end_src

- We can see that this is decrementing counter ~while~ loop, using the
  expression ~(setq arg (1- arg))~ as the decrementer.  That
  expression is not far from the ~while~, but is hidden in another
  Lisp macro, an ~unless~ macro.  Unless we are at the end of the
  buffer--that is what the ~eopb~ function determines; it is an
  abbreviation of '~End of Buffer P~'--we decrease the value of ~arg~
  by one.

- (If we are at the end of the buffer, we cannot go forward any more
  and the next loop of the ~while~ expression will test false since
  the test is an ~ans~ with ~(not (eobp))~.  The ~not~ function means
  exactly as you expect; it is another name for ~null~, a function
  that returns true when its argument is false.)

- Interestingly, the loop count is not decremented until we leave the
  space between paragraphs, unless we come to the end of buffer or
  stop seeing the local value of the paragraph separator.

- That second ~while~ also has a ~(move-to-left-margin)~ expression.
  The function is self-explanatory.  It is inside a ~progn~ expression
  and not the last element of its body, so it is only invoked for its
  side effect, which is to move point to the left margin of the
  current line.

- The ~looking-at~ function is also self-explanatory; it returns true
  if the text after point matches the regular expression gives as its
  argument.

- The rest of the body of the loop looks difficult at first, but makes
  sense as you come to understands it.

- First consider what happens if there is a fill prefix:

  #+begin_src emacs-lisp
    (if fill-prefix-regexp
        ;; There is a fill prefix; it overrides parstart'
        ;; we go forward line by line
        (while (and (not (eobp))
                    (progn (move-to-left-margin) (not (eobp)))
                    (not (looking-at parsep))
                    (looking-at fill-prefix-regexp))
          (forward-line 1))
  #+end_src

- This expression moves point forward line by line so long as four
  condition are true:

  1. Point is not at the end of the buffer.

  2. We can move to the left margin of the text and are not at the end
     of the buffer.

  3. The text following point does not separate paragraph.

  4.  The pattern following point is the fill prefix regular expression.

- The last condition may be puzzling, until you remember that point
  was moved to the beginning of the line early in the
  ~forward-paragraph~ function.  This means that if the text has a
  fill prefix, the ~looking-at~ function will see it.

- Consider what happens when there is no fill prefix.

  #+begin_src emacs-lisp
    (while (and (re-search-forward sp-parstart nil 1)
                (progn (setq start (match-beginning 0))
                       (goto-char start)
                       (not (eobp)))
                (progn (move-to-lef-margin)
                       (not (looking-at parsep)))
                (or (not (looking-at parstart))
                    (and use-hard-newlines
                         (not (get-text-property (1- start) 'hard)))))
      (forward-char 1))
  #+end_src

- This ~while~ loop has us searching forward for ~sp-parstart~, which
  is the combination of possible whitespace with the local value of
  the start of a paragraph separator.  (the latter two are within
  expression starting ~\(?:~ so that they are not referenced by the
  ~match-beginning~ function.)

- That two expressions,

  #+begin_src emacs-lisp
    (setq start (match-beginning 0))
    (goto-char start)
  #+end_src

- mean go to the start of the text matched by the regular expression search.

- The ~(match-beginning 0)~ expression is new.  It returns a number
  specifying the location of the start of the text that was matched by
  the last search.

- The ~match-beginning~ function is used here because of
  characteristic of a forward search: a successful forward search,
  regardless of whether it is a plain search or regular expression
  search, moved point to the end of the text that is found.  In this
  case, a successful search moves point to the end of the pattern for
  ~sp-partstart~.

- However, we want to put point at the end of the current paragraph,
  not somewhere else.  Indeed, since the search possibly includes the
  paragraph separator, point may end up at the beginning of the next
  one unless we use an expression that includes ~match-beginning~.

- When given an argument of 0, ~match-beginning~ returns the position
  that is the start of the text matched by the most recent search.  In
  this case, the most recent search looks for ~sp-parstart~.  The
  ~(match-beginning 0)~ expression returns the beginning position of
  that pattern.

- (Incidentally, when passed a positive number as an argument, the
  ~match-beginning~ function returns the location of point at that
  parenthesized expression in the last search unless that
  parenthesized expression begins with ~\(?:~ appears here since the
  argument is 0.)

- The last expression when there is no fill prefix is

  #+begin_src emacs-lisp
    (if (< (point) (point-max))
        (goto-char start))))
  #+end_src

- This say that if there is no fill prefix and if we are not at the
  end, point should move to the beginning of whatever was found by the
  regular expression search for ~sp-parstart~.

- The full definition for the ~forward-paragraph~ function not
  includes code for going forwards, but also code for going backwards.

- If you are reading this inside GNU Emacs and you want to see the
  whole function, you can type ~C-h f (describe-function)~ and the
  name of the function.  This gives you the function documentation and
  the name of the library containing the function''s source.  Place
  point over the name of the library and press ~RET~ key; you will be
  taken directly to the source.  (Be sure to install your sources!
  Without them, you are like a person who tries to drive a car with
  his eyes shut!)

** Review

- Here is a brief summary of some recently introduced functions.

- *~while~*

  Repeatedly evaluate the body of the expression so long as the first
  element of the body test true.  Then return ~nil~.  (The expression
  is evaluated only for its side effects.)

  For example:

  #+begin_src emacs-lisp
    (let ((foo 2))
      (while (> foo 0)
        (insert (format "foo is %d.\n" foo))
        (setq foo (1- foo))))

          ⇒         foo is 2
                    foo is 1
                    nil
    #+end_src

  (The ~insert~ function its arguments at point; the ~format~
  functions returns a string formatted from its arguments the way
  ~message~ formats its argument; ~\n~ produces a new line.)

- *~re-search-forward~*

  Search for a pattern, and if the pattern is found, move point to
  rest just after it.

  Takes four arguments, like ~search-forward~:

    1. A regular expression that specifies the pattern to search for.
       (Remember to put quotation marks around this argument!)

    2. Optionally, the limit of the search.

    3. Optionally, what to do if the search fails, return ~nil~ or an
       error message.

    4. Optionally, how many times to repeat the search; if negative,
       the search goes backwards.

- *~let*~*

  Bind some variables locally to particular values, and then evaluates
  the remaining arguments, returning the value of the last one.  While
  binding the local variables, use the local values of variables bound
  earlier, if any.

  For example:

    #+begin_src emacs-lisp
      (let* ((foo 7)
             (bar (* 3 foo)))
        (message "`bar' is %d." bar))

            ⇒ `bar' is 21
    #+end_src

- *~match-beginning~*

  Return the position of the start of the text found by the last
  regular expression search.

- *~looking-at~*

  Return ~t~ for true if the text after point matches the argument,
  which should be a regular expression.

- *~eobp~*

  Return ~t~ for true if point is at the end of the accessible part of
  a buffer.  The end of the accessible part is the end of the buffer
  if the buffer is not narrowed; it is the end of the narrowed part if
  the buffer is narrowed.


* Counting via Repetition and Regexps

- Repetition and regular expression searches are powerful tools that
  you often use when you write code in Emacs Lisp.  This chapter
  illustrates the use of regular expression searches through the
  construction of word count commands using ~while~ loops and recursion.

    - [[Counting words][Why Count Words]]

    - [[The ~count-words-example~ Function][count-words-example]]               Use a regexp, but find a problem

    - [[Count Words Recursively][recursive-count-words]]                        Start with case of no words in region

** Counting words

- The standard Emacs distribution contains functions for counting the
  number of lines and words within a region.

- Certain types of writing ask you to count words.  Thus, if you write
  an essay, you may be limited to 800 words; if you write a novel, you
  may discipline yourself to write 1000 words a day.  It seems odd,
  but for a long time, Emacs lacked a word count command.  Perhaps
  people used Emacs mostly for code or types of documentation that did
  not require words counts; or perhaps restricted themselves to the
  operating system word count command, ~wc~.  Alternatively, people
  may have followed the publisher' convention and computed a word
  count by dividing the number of characters in a document by five.

- There are many ways to implement a command to count words.  Here are
  some examples, which you may wish to compare with the standard Emacs
  command, ~count-words-region~.

** The ~count-words-example~ Function

- A word count command could count words in a line, paragraph, region,
  or buffer.  What should the command cover?  You could design the
  command to count the number of words in a complete buffer.  However,
  the Emacs tradition encourages flexibility--you may want to count
  words in just a section, rather than all of a buffer.  So it makes
  more sense to design the command to count the number of words in a
  region.  Once you have a command to count words in a region, you
  can, if you wish, count words in a whole buffer by marking it with
  ~C-x h (mark-whole-buffer)~.

- Clearly, counting words is a repetitive act: starting from the
  beginning of the region, you count the first word, then the second
  word, then the third word, and so on, until you reach the end of the
  region.  This means that word counting is ideally suited to
  recursion of to a ~while~ loop.


    - [[Designing ~count-words-example~][Design count-words-example]]           The definition using a ~while~ loop

    - [[The Whitespace Bug In ~count-word-example~][Whitespace Bug]]            The Whitespace Bug in ~count-words-example~

*** Designing ~count-words-example~

- First, we will implement the word count command with a while loop,
  then with recursion.  The command will, of course, be interactive.

- The template for an interactive function definition is, as always:

  #+begin_src emacs-lisp
    (defun name-of-function (argument-list)
      "documentation..."
      (interactive-expression...)
      body...)
  #+end_src

- What we need to do is fill in the slots.

- The name of the function should be self-explanatory and similar to
  the existing ~count-lines-region~ name.  This makes the name easier
  to remember.  ~count-words-region~ is the obvious choice.  Since
  that name is now the standard Emacs command to count word, we will
  name our implementation ~count-words-example~.

- The function counts words within a region.  This means that the
  argument list must contain symbols that are bound to the two
  positions, the beginning and end of the region.  These two position
  can be called '~beginning~' and '~end~' respectively.  The first
  line of the documentation should be a single sentence, since that is
  all that is printed as documentation by a command such as ~apropos~.
  The interactive expression will be of the form '~(interactive
  "r")~', since that will cause Emacs to pass the beginning and end of
  the region to the function's argument list.  All this is routine.

- The body of the function needs to be written to do three tasks:
  /first/, to set up conditions under which the ~while~ loop can count
  words, /second/, to rue the ~while~ loop, and /third/, to send a
  message to the user.

- When a user calls ~count-words-example~, point may be at the
  beginning or the end of the region.  However, the counting process
  must start at the beginning of the region.  This means we will want
  to put point there if it is not already there.  Executing
  ~(goto-char beginning)~ ensure this.  Of course, we will want to
  return point to its expected position when the function finished its
  work.  For this reason, the body must be enclosed in a
  ~save-excursion~ expression.

- The central part of the body of the function consists of a ~while~
  loop in which one expression jumps point forward word by word, and
  another expression counts those jump.  The true-or-false-test of the
  ~while~ loop should test true so long as point should jump forward,
  and false when point is at the end of the region.

- We could use ~(forward-word 1)~ as the expression for moving point
  forward word by word, but it is easier to see what Emacs identifies
  as a "word" if we use regular expression search.

- A regular expression search that finds the pattern for which it is
  searching leaves point after the last character matched.  This means
  that a succession of successful word searches will move point
  forward word by word.

- As a practical matter, we want the regular expression search to jump
  over whitespace and punctuation between words as well as over the
  words themselves.  A regexp that refuses to jump over interword
  whitespace would never jump more than one word!  This means that the
  regexp should include the whitespace and punctuation that follows a
  word, if any, as well as the word itself.  (A word may end a buffer
  and not have any following whitespace or punctuation, so that part
  of the regexp must be optional.)

- Thus, what we want for the regexp is a pattern defining one or more
  word constituent characters followed, optionally, by one or more
  characters that are not word constituents.  The regular expression
  for this is:

  #+begin_src emacs-lisp
    \w+\W*
  #+end_src

- The buffer's syntax table determines which characters are and not
  word constituents.  For more information about syntax, see
  [[][Syntax Tables]] in The GNU Lisp Reference Manual.

- The search expression looks like this:

  #+begin_src emacs-lisp
    (re-search-forward "\\w+\\W*")
  #+end_src

- (Note that paired backslashes precede the '~w~' and '~W~'.  A single
  backslash has a special meaning to the Emacs Lisp interpreter.  It
  indicates that the following character is interpreted differently
  than usual.  For example, the two characters, '~\n~', stand for
  '~newline~', rather than for a backslash followed by '~n~'.  Two
  backslashes in a row stand for an ordinary, unspecial backslash, so
  Emacs Lisp interpreter ends of seeing backslash followed by a
  letter.  So it discovers the letter is special.)

- We need a counter to count how many words there are; this variable
  must first set to 0 and incremented each time Emacs goes around the
  ~while~ loop.  The incrementing expression is simply:

  #+begin_src emacs-lisp
    (setq count (1+ count))
  #+end_src

- Finally, we want to tell the user how many words there are in the
  region. The ~message~ function is intended for presenting this kind
  of information to the use.  The message has to be phrased so that it
  reads properly regardless of how many words there are in the region:
  we don't want to say that "there are 1 words in the region".  The
  conflict between singular and plural is ungrammatical.  We can solve
  this problem by using a conditional expression that evaluates
  different message on the number of words in the region.  There are
  there possibilities: no words in the region, one word in the region,
  and more than one word.  This means that the ~cond~ special form is
  appropriate.

- All this leads to the following function definition:

  #+begin_src emacs-lisp
    ;;; First version; has bugs!
    (defun count-words-example (beginning end)
      "Print number of wores in the region.
    Words are defined as at least one word-constituent
    character followed by at least one character that
    is not a word-constituent.  The buffer's syntax
    table determine which characters these are."

      (interactive "r")
      (message "Counting word in region ... ")

     ;;; 1. Set up appropriate conditions.
      (save-excursion
        (goto-char beginning)
        (let ((count 0))

     ;;; 2. Run the while loop.
          (while (< (point) end)
            (re-search-forward "\\w+\\W*")
            (setq count (1+ count)))

     ;;; 3. Send a message to user.
          (cond ((zerop count)
                 (message
                  "The region does NOT have any words."))
                ((= 1 count)
                 (message
                  "The region has 1 word."))
                (t
                 (message
                  "The region has %d words." count))))))
  #+end_src

- As written, the function works, but not in all circumstances.
*** The Whitespace Bug In ~count-word-example~

- The ~count-word-example~ command described in the preceding section
  has two bugs, or rather, one bug with two manifestations.  First, if
  you mark a region containing only whitespace in the middle of some
  text, the ~count-words-example~ command tells you that the region
  contains one word!  Second, if you mark a region containing only
  whitespace at the end of the buffer or the accessible portion of
  narrowed buffer, the command display an error message that looks
  like this:

  #+begin_src emacs-lisp
    Search failed: "\\w+\\W*"
  #+end_src

- If you are reading this in Info in GNU Emacs, you can test for these
  bugs yourself.

- First, evaluate the function in the usual manner to install it.

- If you wish, you can also install this keybinding by evaluating it:

  #+begin_src emacs-lisp
    (global-set-key "\C-c=" 'count-words-example)
  #+end_src

- To conduct the first test, set mark point to the beginning and end
  of the following line and then type ~C-c =~ (or ~M-x
  count-word-example~ if you have not bound ~C-c =):

  #+begin_src emacs-lisp
    one two three
  #+end_src

- Emacs will tell you, correctly, that the region has three words.

- Repeat the test, but place mark at the beginning of the line and
  place point just /before/ the word '~one~'.  Again type the command
  ~C-c =~ (or ~M-x count-words-example)~.  Emacs should tell you that
  the region has no words, since it composed only of the whitespace at
  the beginning of the line.  But instead Emacs tells you that the
  region has one word!.

- For the third test, copy the sample line to the end of the
  ~*scartch*~ buffer and then type several spaces at the end of the
  line.  Place mark right after the word '~three~' ans point at the
  end of line.  (The end of the line will be the end of the buffer.)
  Type ~C-c =~ (or ~M-x count-words-example~) as you did before.
  Again Emacs should tell you that the region has no words, since it
  composed only of the whitespace at the end of the line.  Instead,
  Emacs display an error message saying '~Search Failed~'.

- The two bug stem from the same problem.

- Consider the first manifestation of the bug, in which the command
  tells you that the whitespace at the beginning of the line contains
  one word.  What happens is this: the ~M-x count-words-example~
  command moves point to the beginning of the region.  The ~while~
  test whether the value of point is smaller than the value of ~end~,
  which it is.  Consequently the regular expression search looks for
  and finds the first word.  ~count~ is set to one.  The ~while~ loop
  repeats; but this time the value of point is larger than the value
  of ~end~, the loop is exited; and the function displays a message
  saying the number of words in the region is one.  In brief, the
  regular expression search looks for and finds the word even though
  it is outside the marked region.

- In the second manifestation of bug, the region is whitespace at the
  end of the buffer.  Emacs says '~Search failed.~'.  What happen is
  that the true-or-false-test in the ~while~ loop test true, so the
  search expression is executed.  But since there are no more words in
  the buffer, the search fails.

- In both manifestation of bug, the search extends or attempts to
  extend outside of the region.

- The solution is to limit the search to the region--this is a fairly
  simple action, but as you may have come to expect, it is not quite
  as simple as you might think.

- As we have seen, the ~re-search-forward~ function takes a search
  pattern as its first argument.  But in addition to this first,
  mandatory argument, it accepts three optional argument.  The
  optional second argument bound the search.  The optional third
  argument, if ~t~, cause the function to return ~nil~ rather than
  signal an error if the search fails.  The optional fourth argument
  is a repeat count.  (In Emacs, you can see a function's
  documentation by typing ~C-h f~, the name of the function, and then
  ~RET~.)

- In the ~count-words-example~ definition, the value of the end of the
  region is held by the variable ~end~ which is passed as an argument
  to the function.  Thus, we can add ~end~ as an argument to the
  regular expression search expression:

  #+begin_src emacs-lisp
    (re-search-forward "\\w+\\W*" end)
  #+end_src

- However, if you make only this change to the ~count-words-example~
  definition and then test the new version the definition on a stretch
  of whitespace, you will receive an error message saying '~Search
  failed~'.

- What happens is this: the search is limited to the region, and fails
  as you expect because there are no word-constituent characters in
  the region.  Since it fails, we receive an error message.  But we do
  not want to receive an error message in this case; we want to
  receive the message "The region does NOT have any words."

- The solution to this problem is to provide ~re-search-forward~ with
  a third argument of ~t~, which causes the function to return ~nil~
  rather than signal an error if the search fails.

- Here is what happens: the search is limited to the region, as
  before, and it fails because there are no word-constituent
  characters in the region, as expected.  Consequently, the
  ~re-search-forward~ expression return ~nil~.  It does nothing else.
  In particular, it does not move point, which it does a side effect
  if it finds the search target.  After the ~re-search-forward~
  expression return ~nil~, the next expression in the ~while~ loop is
  evaluated.  This expression increment the count.  Then the loop
  repeats.  The true-or-false-test tests true because the value of
  point is still less than the value of end, since the
  ~re-search-forward~ expression did not move point. ... and the cycle
  repeats ...

- The ~count-words-example~ definition requires yet another
  modification, to cause the true-or-false-test of the ~while~ loop to
  test false if the search fails.  Put another way, there are two
  conditions that must be satisfied in the true-or-false-test before
  the word count variable is incremented: point must still be within
  the region and the search must have found a word to count.

- Since both the first condition and the second condition must be true
  together, the two expression, the region test and the search
  expression, can be joined with an ~and~ special form and embedded in
  the ~while~ loop as the true-or-false-test, like this:

  #+begin_src emacs-lisp
    (and (< (point) end) (re-search-forward "\\w+\\W*" end t))
  #+end_src

- The ~re-search-forward~ expression return ~t~ if the search
  succeeded and as a side effect moves point.  Consequently, as words
  are found, point is moved through the region.  When the search
  expression fails to find another word, or when point reaches the end
  of the region, the true-or-false-test tests false, the ~while~ loop
  exits, and the ~count-words-example~ function displays one or other
  of its messages.

- After incorporating these final changes, the ~count-words-example~
  works without bugs (or at least, without bugs than I have found!).
  Here is what it looks like:

  #+begin_src emacs-lisp
    ;;; Final version: while
    (defun count-words-example (beginning end)
      "Print number of words in the region."
      (interactive "r")
      (message "Counting words in region ...")

    ;;; 1. Set up appropiate conditions.
      (save-excursion
        (let ((count 0))
          (goto-char beginning)

    ;;; 2. Run the while loop
          (while (and (< (point) end)
                      (re-search-forward "\\w+\\W*" end t))
            (setq count (1+ count)))

    ;;; 3. Send message to the user.
          (cond ((zerop count)
                 (message
                  "The region does NOT have any words."))
                ((= 1 count)
                 (message
                  "The region has 1 word."))
                (t
                 (message
                  "The region has %d words." count))))))
  #+end_src

** Count Words Recursively

- You can write the function for counting words recursively as well
  with a ~while~ loop.  Let's see how this is done.

- First, we need to recognize that the ~count-words-example~ function
  has three jobs: It sets up the appropriate conditions for counting
  to occur, it counts the words in the region; and it sends a message
  to the user telling how many words there are.

- If we write a single recursive function to do everything, we will
  receive a message for every recursive call.  If the region contains
  13 words, we will receive thirteen messages, one right after the
  other.  We don't want this!  Instead, we must write two functions to
  do the job, one of which (the recursive function) will be used
  inside of the other.  One function will set up the conditions and
  display the message; the other will return the word count.

- Let us start with the function that causes the message to be
  displayed.  We can continue to call this ~count-words-example~.

- This is the function that the user will call.  It will be
  interactive.  Indeed, it will be similar to our previous versions of
  this function, except that it will call ~recursive-count-words~ to
  determine how many words are in the region.

- We can readily construct a template for this function, based on our
  previous versions:

  #+begin_src emacs-lisp
    ;; Recursive version; uses regular expression search
    (defun count-wors-example (beginning end)
      "documentation..."
      (interactive-expression...)

    ;;; 1. Set up appropiate conditions.
      (explanatory message)
      (set-up funtions....

    ;;; 2. Count the words.
         recursive call

    ;;; 3. Send a messagea to the user.
        message providing word count))
  #+end_src

- The definition looks straightforward, except that somehow the cunt
  returned by the recursive call must be passed to the message
  displaying the word count.  A little though suggests that this can
  be done by making use of a ~let~ expression: we can bind a variable
  in the varlist of a ~let~ expression to the number of words in the
  region, as returned by the recursive call; and then the ~cond~
  expression, using binding, can display the value to the user.

- Often, one thinks of the binding within a ~let~ expression as
  somehow to the primary work of a function.  But in this case, what
  you might consider the primary job of the function, counting words,
  is done within the ~let~ expression.

- Using ~let~, the function definition looks like this:

  #+begin_src emacs-lisp
    (defun count-words-example (beginning end)
      "Print number of words in the region."
      (interactive "r")

    ;;; 1. Set up appropiate conditions.
      (message "Counting words in region ...")
      (save-excursion
        (goto-char beginning)

    ;;; 2. Count the words.
        (let ((count (recursive-count-words end)))

    ;;; 3. Send a message to the user
          (cond ((zerop count)
                 (message
                  "The region does NOT have any words."))
                ((= 1 count)
                 (message
                  "The region has 1 word."))
                (t
                 (message
                  "The region has %d words." count))))))
  #+end_src

- Next, we need to write the recursive counting function.

- A recursive function has at least three parts: the
  do-again-test. the next-step-expression, and the recursive call.

- The do-again-test determines whether the function will or will not
  be called again.  Since we are counting words in a region and can
  use a function that moves that point forward for every word, the
  do-again-test can check whether point is still within the region.
  The do-again-test should find the value of point and determine
  whether point is before, at, or after the value of the end of the
  region.  We can use the ~point~ function to locate point.  Clearly,
  we must pass the value of the end of the region to the recursive
  counting function as an argument.

- In addition, the do-again-test should also test whether the search
  finds a word.  If it does not, the function should not call itself
  again.

- The next-step-expression changes a value so that when the recursive
  function is supposed to stop calling itself, it stops.  More
  precisely, the next-step-expression changes a value so that at the
  right time, the do-again-test stops the recursive function calling
  itself again.  In this case, the next-step-expression can be the
  expression that moves point forward, word by word.

- The third part of a recursive function is the recursive call.

- Somewhere, we also need a part that does the work of the function, a
  part that does the counting.  A vital part!

- But already, we have an outline of the recursive counting function:

  #+begin_src emacs-lisp
    (defun recursive-count-words (region-end)
      "documentation..."
      do-again-test
      next-step-expression
      recusive-call)
  #+end_src

- Now we need to fill in the slots.  Let's start with the simple case
  first: if point is at or beyond the end of the region, there cannot
  be any words in the region, so the function should return zero.
  Likewise, if the search fails, there are no words to count, so the
  function should return zero.

- The do-again-test is the true-or-false test of an ~if~ clause.
  Clearly, if the do-again-test succeeds, the then-part of the ~if~
  clause should call the function again; but if it fails, the
  else-part should return zero since either point is outside the
  region or the search failed because there were no words to find.

- But before considering the recursive call, we need to consider the
  next-step-expression.  What is it?  Interestingly, it is the search
  part of the do-again-test.

- In outline, then, the body of the ~recursive-count-words~ function
  looks like this:

  #+begin_src emacs-lisp
    (if do-again-test-and-next-step-combined
        ;; then
        recursive-call-returning-count
      ;; else
      return-zero)
  #+end_src

- How to incorporate the mechanism that count?

- If you are not used to writing recursive functions, a question like
  this can be troublesome.  But it can and should be approached
  systematically.

- We know that the counting mechanism should be associated in some way
  with the recursive call.  Indeed, since the next-step-expression
  moves point forward by one word, and since a recursive call is made
  for each word, the counting mechanism must be an expression that
  adds one to the value returned by a call to ~recursive-count-words~.

- Consider several cases:

  + If there are two words in the region, the function should return a
    value resulting from adding one to the value returned when it
    counts the first word, plus the number returned when it counts the
    remaining words in the region, which in this case is one.

  + If there is one word in the region, the function should return a
    value resulting from adding one to the value returned when it
    counts that words, plus the number returned when it counts the
    remaining words in the region, which in this case is zero.

  + If there are no words in the region, the function should return zero.

- Form the sketch we can see that the else-part of the ~if~ returns
  zero for the case of no words.  This means that the then-part of the
  ~if~ must return a value resulting from adding one to the value
  returned from a count of the remaining words.

- The expression will look like this, where ~1+~ is a function that
  adds one to its argument.

  #+begin_src emacs-lisp
    (1+ (recursive-count-words (region-end))
  #+end_src

- The whole ~recursive-count-words~ function will then look like this:

  #+begin_src emacs-lisp
    (defun recursive-count-words (region-end)
      "documentation..."

    ;;; 1. do-again-test
      (if (and (> (point) region-end)
               (re-search-forward "\\w+\\W*" region-end t))

    ;;; 2. then-part: the recursive call
          (1+ (recursive-count-words (region-end))

    ;;; 3. else-part
              0))
  #+end_src

- Let's examine how this works:

- If there are no words in the region, the else part of the ~if~
  expression is evaluated and consequently the function returns zero.

- If there is one word in the region, the value of point is less than
  the value of ~region-end~ and the search succeeds.  In this case,
  the true-or-false-test of the ~if~ expression test true, and the
  then-part of the ~if~ expression is evaluated.  The counting
  expression is evaluated.  This expression returns a value (which
  will be the value returned by the whole function) that is the sum of
  one added to the value returned by a recursive call.

- Meanwhile, the next-step-expression has caused point to jump over
  the first (and in this case only) word in the region.  This means
  that when ~(recursive-count-words region-end)~ is evaluated a second
  time, as a result of the recursive call, the value of point will be
  equal to or greater than the value of region end.  So this time,
  ~recursive-count-words~ on a region containing the remaining
  word--that is, it adds one to one, producing two, which is the
  correct amount.

- Similarly, if there are three words in the region, the first call to
  ~recursive-count-words~ returns one added to the value returned by
  calling ~recursive-count-words~ on a region containing remaining
  two-words--and so on and so on.

- The recursive function:

  #+begin_src emacs-lisp
    (defun recursive-count-words (region-end)
      "Number of words between point and REGION-END."

    ;;; 1. do-again-test
      (if (and (< (point) region-end)
               (re-search-forward "\\w+\\W*" region-end t))

    ;;; 2. then-part: the recursive call
          (1+ (recursive-count-words regio-end))

    ;;; 3. else-part
        0))
  #+end_src

- The wrapper:

  #+begin_src emacs-lisp
    ;;; Recursive version
    (defun count-words-example (beginning end)
      "Print number of words in the region.

    Words are defined as at least one word-conituent
    character followed by at least one character that is
    not a word-constituent.  The buffer's syntax table
    determine which characters these are."

      (interactive "r")
      (message "Counting words in region ... ")
      (save-excursion
        (goto-char beginning)
        (let ((count (recursive-count-words end)))
          (cond ((zerop count)
                 (message
                  "The region does NOT have any words."))
                ((= 1 count)
                 (message
                  "The region has 1 words."))
                (t
                 (message
                  "The region has %d words." count))))))
  #+end_src


* Counting Words in a ~defun~

- Our next object is to count the number of words in a function
  definition.  Clearly, this can be done using some variant of
  ~count-words-example~.  See [[Counting via Repetition and Regexps]]. If we
  are just going to count the words in one definition, it easy enough
  to mark the definition with the ~C-M-h (mark-defun)~ command, and
  then call ~count-words-example~.

- However, I am more ambitious: I want to count the words ans symbols
  in every definition in the Emacs sources and then print a graph that
  shows how many function there are of each length: how many contain
  40 to 49 words or symbols, how many contain 50 to 59 words or
  symbols, and so on.  I have often been curious how long a typical
  function is, and this will tell.

  - [[Divide and Conquer][Divide and Conquer]]

  - [[What to count?][Words and Symbols]]                                               What to count?

  - [[What constituent a Word or Symbols?][Syntax]]                                     What constitutes a word or symbol?

  - [[The ~count-words-in-defun~ Function][count-words-in-defun]]                       Very like ~count-words-example~

  - [[Counsel Several ~defuns~ Within a File][Several defun]]                           Counting several defuns in a file

  - [[Find a File][Find a File]]                                                        Do you want to look at a file?

  - [[~lengths-list-file~ in Detail][length-list-file]]                                 A list of the length of many definitions

  - [[Count Words in ~defuns~ in Different Files][Several length]]                      Counting in definitions in different files

  - [[Recursively Count Words in Different Files][Several files recursively]]           Recursively counting in different files

  - [[Prepare the Data for Display in a Graph][Prepare the data]]                       Prepare the data for display in a graph

** Divide and Conquer

- Described in one phrase, the histogram project is daunting; but
  divided into numerous small steps, each of which we can take one at
  a time, the project becomes less fearsome.  Let us consider what the
  steps must be:

  - First, write a function to count the words in one definition.
    This include the problem of handling symbols as well as words.

  - Second, write a function to list number of words in each function
    in a file.  This function can use the ~count-words-in-defun~
    function.

  - Third, write a function to list the number of words in each
    function in each of several files.  This entails automatically
    finding the various files, switching to them, and counting the
    words in the definitions within them.

  - Fourth, write a function to convert the list of numbers that we
    created in step three to a form that will be suitable for printing
    as a graph.

  - Fifth, write a function to print the results as a graph.

- This is quite a project!  But if we take each step slowly, it will
  not be difficult.
** What to count?

- When we first start to thinking about how to count the words in a
  function definition, the first question is (or ought to be) what are
  we going to count?  When we speak of "words" with respect to a Lisp
  function definition, we are actually speaking, in large part, of
  symbols. For example, the following ~multiply-by-seven~ function
  contains the five symbols ~defun~, ~multiply-by-seven~, ~number~,
  ~*~, and ~7~.  In addition, in the documentation string, it contains
  the four words '~Multiply~', '~NUMBER~', '~by~', and ~'seven'~.  The
  symbol '~number~' is repeated, so the definition contains a total of
  ten words and symbols.

  #+Begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number))
  #+end_src

- However, if we mark the ~multiply-by-seven~ definition with ~C-M-h
  (mark-defun)~, and then call ~count-words-example~ on it, we will
  find that ~count-words-example~ claims the definitions has eleven
  words, not ten! Something wrong!.

- The problem is twofold: ~count-words-example~ does not count '~*~'
  as a word, and it counts the single symbol, ~multiply-by-seven~ as
  containing three words.  The hyphens are treated as if they were
  interword spaces rather than intraword connectors:
  '~multiply-by-seven~' is counted as if it were written '~multiply by
  seven~'.

- The cause of this confusion is the regular expression search within
  the ~count-words-example~ definition that moves point forward word
  by word.  In the canonical version of ~count-words-example~ the
  regexp is:

  #+begin_src emacs-lisp
    "\\w+\\W*"
  #+end_src

- This regular expression is a pattern defining one or more word
  constituent characters possibly followed by one ore more characters
  that are not word constituents.  What is mean by "word constituent
  characters" brings us to the issue of syntax, which is worth a
  section of its own.

** What constituent a Word or Symbols?

- Emacs treats different characters as belonging to different /syntax
  categories/.  For example, the regular expression '~\\w+~', is a
  pattern specifying one or more /word constituent/ characters.  Word
  constituent characters are members of one syntax category.  Other
  syntax categories include the class of punctuation characters, such
  ad the period and the comma, and the class of whitespace characters,
  such as the blank space and the tab character.  (For more
  information, see [[][Syntax Tables]] In The GNU Emacs Lisp Reference
  Manual.)

- Syntax tables specify which categories.  Usually, a hyphen is not
  specified as a word constituent character.  Instead, it specified as
  being in the class of characters that are part of symbol names but
  not words.  This means that the ~count-words-example~ function
  treats it in the same way it treats an interword white space, which
  is why ~count-words-example~ counts '~multiply-by-seven~' as three
  words.

- There are two ways to cause Emacs to count '~multiply-by-seven~' as
  one symbols: modify the syntax table or modify the regular
  expression.

- We could redefine a hyphen as a word constituent character by
  modifying the syntax table that Emacs keep for each mode.  This
  action would serve our purpose, except that a hyphen is merely the
  most common character within symbols that is not typically a word
  constituent characters; there are others, too.

- Alternatively, we can redefine the regexp used in the
  ~count-words-example~ definition so as to include symbols.  This
  procedure has the merit of clarity, but the task is a little tricky.

- The first part is simple enough: the pattern must match at least one
  character that is a word or symbol constituent.  Thus:

  #+begin_src emacs-lisp
    "\\(\\w\\|\\s_\\)+"
  #+end_src

- The '~\\(~' is the first part of the grouping construct that
  includes the '~\\w~' and the '~\\s_~' as alternatives, separated by
  the '~\\|~'.  The '~\\w~' matches any word-constituent characters
  and the '~\\s_~' matches any character that is part of a symbol name
  but not a word-constituent characters.  The '~+~' following the
  group indicates that the word or symbol constituent characters must
  be matched at least once.

- However, the second part of the regexp is more difficult to design.
  What we want is to follow the first part with optionally one or more
  characters that are not constituents of a word or a symbol.  At
  first, I thought I could define this with the following:

  #+begin_src emacs-lisp
    "\\(\\W\\|\\S_\\)*"
  #+end_src

- The upper case '~W~' and '~S~' match the characters that are /not/
  word or symbol constituents.  Unfortunately, this expression matches
  any character that is either not a word constituent or not a symbol
  constituent.  This matches any character!

- I then noticed that every word or symbol in my test region was
  followed by white space (blank space, tab, or newline).  So I tried
  placing a pattern to match one or more blank spaces after the
  pattern for one or more word or symbol constituents.  This failed,
  too.  Words and symbols are often separated by whitespace, but in
  actual code parentheses may follow symbols and punctuation may
  follow words.  So finally, I designed a pattern in which the word or
  symbol constituents are followed optionally by characters that are
  not white space and then followed optionally by white space.

- Here is the full regular expression:

  #+begin_src emacs-lisp
    "\\(\\w\\|\s_\\)+[^ \t\n]*[ \t\n]*"
  #+end_src

** The ~count-words-in-defun~ Function

- We have seen that there are several ways to write a
  ~count-words-region~ function.  To write a ~count-words-in-defun~,
  we need merely adapt one of these version.

- The version that uses a ~while~ loop is easy to understand, so I am
  going to adapt that.  Because ~count-words-in-defun~ will be part of
  a more complex program, it need not be interactive and it need not
  display message but just return the count.  These considerations
  simplify the definition a little.

- On the other hand, ~count-words-in-defun~ will be used within a
  buffer that contains function definitions.  Consequently, it is
  reasonable to ask that the function determine whether it is called
  when point is within a function definition, and if it is, to return
  the count for that definition.  This adds complexity to the
  definition, but saves us from needing to pass argument to the
  function.

- These considerations lead us to prepare the following template:

  #+begin_src emacs-lisp
    (defun count-words-in-defun ()
      "documentation..."
      (set-up...
        (while loop...)
       return count)
  #+end_src

- As usual, our job is to fill the slots.

- First, the set up.

- We are presuming that this function will be called within a buffer
  containing function definition.  Point will either be within a
  function definition or not.  For ~count-words-in-defun~ to work,
  point must move to beginning of the definition, a counter must start
  at zero, and the counting loop must stop when point reaches the end
  of definition.

- The ~beginning-of-defun~ function searches backwards for an opening
  delimiter such as '~(~' at the beginning of a line, and moves point
  to that position, or else to the limit of the search.  In practice,
  this means that ~beginning-of-defun~ moves point to the beginning of
  an enclosing or preceding function definition, or else to the
  beginning of the buffer.  We can use ~beginning-of-defun~ to place
  point where we wish to start.

- The ~while~ loop requires a counter to keep track of the words or
  symbols being counted.  A ~let~ expression can be used to create a
  local variable for this purpose, and bind it to an initial value of
  zero.

- The ~end-of-defun~ functions works like ~beginning-of-defun~ except
  that it moves point to the end of the definition.  ~end-of-defun~
  can be used as part of an expression that determines the position of
  the end of the definition.

- The set up for ~count-words-in-defun~ takes shape rapidly: first we
  move to the beginning of the definition, then we create a local
  variable to hold the count, and finally, we record the position of
  the end of the definition so the ~while~ loop will know when to stop
  looping.

- The code looks like this:

  #+begin_src emacs-lisp
    (beginning-of-defun)
    (let ((count 0)
          (end (save-excursion (end-of-defun) (point))))
  #+end_src

- The code is simple.  The only slight complication is likely to
  concern ~end~: it is bound to the position of the end of the
  definition by a ~save-excursion~ expression that returns the value
  of point after ~end-of-defun~ temporarily moves it to the end of the
  definition.

- The second part of the ~count-words-in-defun~, after the step up, is
  the ~while~ loop.

- The loop must contain an expression that jumps point forward word by
  and symbol by symbol, and another expression that counts the jumps.
  The true-or-false-test for the ~while~ loop should test true so long
  as point should jump forward, and false when point is at the end of
  the definition.  We have already redefined the regular expression
  for this, so the loop is straightforward:

  #+begin_src emacs-lisp
    (while (and (< (point) end)
                (re-search-forward
                 "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*" end t))
      (setq count (1+ count)))
  #+end_src

- The third part of the function definition returns the count of words
  any symbols.  This part is the last expression within the body of
  the ~let~ expression, and can be, very simply, the local variable
  ~count~, which when evaluated returns the count.

- Put together, the ~count-words-in-defun~ definition looks like this:

  #+begin_src emacs-lisp
    (defun count-words-in-defun ()
      "Return the number of words and symbols in a defun."
      (beginning-of-defun)
      (let ((count 0)
            (end (save-excursion (end-of-defun) (point))))

        (while
            (and (< (point) end)
                 (re-search-forward
                  "\\(\\w\\|\\s_\\)+[^ \t\n]*[ \t\n]*"
                  end t))
          (setq count (1+ count)))
        count))
  #+end_src

- How to test this? The function is not interactive, but it is easy to
  put a wrapper around the function to make it interactive; we can use
  almost the same code as for the recursive version of
  ~count-words-example~:

  #+begin_src emacs-lisp
    ;;; Interactive version
    (defun count-words-defun ()
      "Number of words and symbols in a function definition."
      (interactive)
      (message
       "Counting words and symbols in function definition ... ")
      (let ((count (count-words-in-defun)))
        (cond
         ((zerop count)
          (message
           "The definition does NOT have any words or symbols."))
         ((= 1 count)
          (message
           "The definition has 1 word or symbol."))
         (t
          (message
           "The definition has  %d words or symbols." count)))))
  #+end_src

- Let's re-use ~C-c =~ as convenient keybinding:

  #+begin_src emacs-lisp
    (global-set-key "\C-c=" 'count-words-defun)
  #+end_src

- Now we can try out ~count-words-defun~: install both
  ~count-words-in-defun~ and ~count-words-defun~, and set keybinding,
  and then place the cursor within the following definition:

  #+begin_src emacs-lisp
    (defun multiply-by-seven (number)
      "Multiply NUMBER by seven."
      (* 7 number)
  #+end_src

- Success! The definition has 10 words and symbols.

- The next problem is to count the numbers of words and symbols in
  several definitions within a single file.

** Counsel Several ~defuns~ Within a File

- A file such a ~simple.el~ may have a hundred or more function
  definitions within it.  Our long goal is to collect statistics on
  many files, but as a first step, our immediate goal is to collect
  statistics on one file.

- The information will be a series of numbers, each number being the
  length of a function definition.  We can store the numbers in a
  list.

- We know that we will want to incorporate the information regarding
  one file with information regarding one file with information about
  many other files; this means that the function for counting
  definition lengths within one file need only returns the list of the
  lengths.  It need not ans should not display any message.

- The words count commands contain one expression to jump forward word
  by word and another expression to count the jumps.  The function to
  return the lengths of definitions can be designed to work the same
  way, with one expression to jump point forward definition by
  definition and another expression to construct the length's list.

- This statement of the problem makes it elementary to write the
  function definition.  Clearly, we will start the count at the
  beginning of the file, so the first command will be ~(goto-char
  (point-min))~.  Next, we start the ~while~ loop; and the
  true-or-false test of the loop can be a regular expression search
  for the next function definition--so long as the search succeeds,
  point is moved forward and then the body of the loop is evaluated.
  The body needs an expression that construct the length's list.
  ~cons~, the list construction command, can be used to create the
  list.  That is almost all there is to it.

- Here is what this fragment of code looks like:

  #+begin_src emacs-lisp
    (goto-char (point-min))
    (while (re-search-forward "^(defun" nil t)
      (setq lengths-list
            (cons (count-words-in-defun) lengths-list)))
  #+end_src

- What we have left out is the mechanism for finding the file that
  contains the function definitions.

- In previous examples, we either used this, the Info file, or we
  switched back and forth to some other buffer, such as the
  ~*scratch*~ buffer.

- Finding a file is a new process that we have not yet discussed.

** Find a File

- To find a file in Emacs, you use the ~C-x C-f (find-file)~ command.
  This command is almost, but not quite right for the lengths problem.

- Let's look at the source for ~find-file~:

  #+begin_src emacs-lisp
    (defun find-file (filename)
      "Edit file FILENAME.
    Switch to a buffer visiting file FILENAME,
    creating one if none already exists."
      (interactive "FFind file: ")
      (switch-to-buffer (find-file-noselect filename)))
  #+end_src

- (The most recent version of the ~find-file~ function definition
  permits you to specify optional wildcards to visit multiple files;
  that makes the definition more complex and we will not discuss it
  here, since it is not relevant.  You can see its source using either
  ~M-. (xref-find-definitions)~ or ~C-h f (describe-function)~.)

- The definition I am showing possesses short but complete
  documentation and a interactive specification that prompts you for a
  file name when you use the command interactively.  The body of
  definition contains two functions, ~find-file-noselect~ and
  ~switch-to-buffer~.

- According to its documentation as shown by ~C-h f~ (the
  ~describe-function~ command), the ~find-file-noselect~ function
  reads the named file into a buffer and returns the buffer.  (Its
  most recent version includes an optional /wildcards/ arguments, too,
  as well as another to read a file literally and another to suppress
  warning messages.  These optional arguments are irrelevant.)

- However, the ~find-file-noselect~ function does not select the
  buffer in which it puts the file.  Emacs does not switch its
  attention (or yours if you are using ~find-file-noselect~) to the
  selected buffer.  That is what ~switch-to-buffer~ does: it switches
  the buffer to which Emacs attention is directed; and it switches the
  buffer displayed in the window to the new buffer.  We have discussed
  buffer switching elsewhere.  (See [[Switching Buffers][Switching Buffers]].)

- In this histogram project, we do not need to display each file on
  the screen as the program determines the length of each definition
  within it.  Instead of employing ~switch-to-buffer~, we can work
  with ~set-buffer~, which redirects the attention of the computer
  program to a different buffer does not redisplay in on the screen.
  So instead of calling on ~find-file~ to do the job, we must write
  our own expression.

- The task is easy: use ~find-file-noselect~ and ~set-buffer~.

** ~lengths-list-file~ in Detail

- The core of the ~lengths-list-file~ function is a ~while~ loop
  containing to move point forward defun by defun, and a function to
  count the number of words and symbols in each defun.  This core must
  be surrounded by functions that do various other tasks, including
  finding the file, and ensuring that point start out at the beginning
  of the file.  The function definition looks like this:

  #+begin_src emacs-lisp
    (defun lengths-list-file (filename)
      "Return list of definitions' lengths within FILE.
    The returned list is s list of numbers.
    Each number is the number of words order
    Symbol in one funcion definition."

      (message "Working on `%s' ... " filename)
      (save-excursion
        (let ((buffer (find-file-noselect filename))
              (lengths-list))
          (set-buffer buffer)
          (setq buffer-read-only t)
          (widen)
          (goto-char (point-min))
          (while (re-search-forward "^(defun" nil t)
            (setq lengths-list
                  (const (count-words-in-defun) length-list)))
          ;;(message buffer)    ; debug. just comment for debug
          (kill-buffer buffer)
          length-list)))
  #+end_src

- The function is passed one argument, the name of the file on which
  it will work.  It has four lines of documentation, but no
  interactive specification.  Since people worry that a computer
  broken if they don't see anything going on, the first line of the
  body is a message.

- The next line contains a ~save-excursion~ that returns Emacs's
  attention to the current buffer when the function completes.  This
  is useful in case you embed this function in another function that
  presumes point is restored to the original buffer.

- In the varlist of the ~let~ expression, Emacs finds the file and
  binds the local variable ~buffer~ to the buffer containing the file.
  At the same time, Emacs creates ~lengths-list~ as a local variable.

- Next, Emacs switches its attention to the buffer.

- In the following line, Emacs makes the buffer read-only.  Ideally,
  this line is not necessary.  None of the function for counting words
  and symbols in a function definition should change the buffer.
  Besides, the buffer is not going to be saved, even if it were
  changed.  This line is entirely the consequence of great, perhaps
  excessive, caution.  The reason for the caution is that this
  function and those it calls work on the sources for Emacs and it is
  inconvenient if they are inadvertently modified.  It goes without
  saying that I did not realize a need for this line until an
  experiment went awry and started to modify my Emacs source files ...

- Next comes a call to widen the buffer if it is narrowed.  this
  function is usually not needed--Emacs creates a fresh buffer if none
  already exists; but if a buffer visiting the file already exists
  Emacs returns that one.  In this case, the buffer be narrowed and
  must be widened.  If we wanted to be fully user-friendly, we would
  arrange to save the restriction and the location of point, but we
  won't.

- The ~(goto-char (point-min))~ expression moves point to the
  beginning of the buffer.

- Then comes a ~while~ loop in which the work of the function is
  carried out.  In the loop, Emacs determines the length of each
  definition and constructs a lengths' list containing the
  information.

- Emacs kills the buffer after working through it.  This is to save
  space inside of Emacs.  My version of GNU Emacs 19 contained over
  300 source files of interest; GNU Emacs 22 contains over a thousand
  source files.  Another function will apply ~lengths-list-file~ to
  each of the files.

- Finally, the last expression within the ~let~ expression is the
  ~length-list~ variable; its value is returned as the value of the
  whole function.

- You can try this function by installing it in the usual fashion.
  Then place your cursor after the following expression and type ~C-x
  C-e (eval-last-sexp)~.

  #+begin_src emacs-lisp
    (length-list-file
     "/usr/local/share/emacs/22.1/lisp/emacs-lisp/debug.el")
  #+end_src

- You may need to change the pathname of the file; the one here is for
  GNU version 22.1 To change the expression, copy it to the ~*scrath*~
  buffer and edit it.

- Also, to see the full length of the list, rather than a truncated
  version, you may have to evaluate the following:

  #+begin_src emacs-lisp
    (custom-set-variable '(eval-expression-print-length nil))
  #+end_src

- (See [[][Specifying Variables using ~defcustom~]].  Then evaluate
  the ~lengths-list-file expression.)

- The length's list for ~debug.el~ takes less than a second to produce
  and looks like this in GNU Emacs 22:

  #+begin_src emacs-lisp
    (83 113 105 144 289 22 30 97 48 89 25 52 88 28 77 49 290 232 587)
  #+end_src

- (Using my old machine, the version 19 length's list for ~debug.el~
  took seven seconds to produce and looked like this:

  #+begin_src emacs-lisp
    (75 41 80 62 20 45 44 68 45 12 34 235)
  #+end_src

- The newer version of ~debug.el~ contains more defuns than the
  earlier one; and may new machine is much faster than the old one.)

- Note that the length of the last in the file is first in the list.

** Count Words in ~defuns~ in Different Files

- In the previous section, we created a function that returns a list
  of the lengths of each definition in a file.  Now, we want to define
  a function to return a master list of the lengths of the definitions
  in a list of files.

- Working on each of a list of files is repetitious act, so we can use
  either ~while~ loop or recursion.

  - [[Determine the lengths of ~defuns~][lengths-list-many-files]]              Returns a list of the lengths of defuns

  - [[The ~append~ function][append]]                                           Attach one list to another

*** Determine the lengths of ~defuns~

- The designs using a ~while~ loop is routine.  The argument passed to
  the function is a list of files.  As we say earlier (see [[][Loop
  Example]]), you can write a ~while~ loop so that the body of the
  loop is evaluated if such a list contains elements, but to exit the
  loop if the list is empty.  For this design to work, the body of the
  loop must contain an expression that shortens the list each time the
  body is evaluated, so that eventually the list is empty.  The usual
  technique is to set the value of the list to the value of the CDR of
  the list each time the body is evaluated.

- The template looks like this:

  #+begin_src emacs-lisp
    (while test-whether-list-is-empty
      body...
      set-list-to-cdr-of-list)
  #+end_src

- Also, we remember that a ~while~ loop returns ~nil~ (the result of
  evaluating the true-or-false-test), not the result of any evaluation
  within its body.  (The evaluations within the body of the loop are
  done for their side effects.)  However, the expression that sets the
  lengths' list is part of the body--and that is the value that we
  want returned by the function as whole.  To do this, we enclose the
  ~while~ loop within a ~let~ expression, and arrange that the last
  element of the ~let~ expression contains the value of the length's
  list.  (See [[][Loop Example with an Incrementing Counter]].)

- Thees considerations lead us directly to the function itself:

  #+begin_src emacs-lisp
       ;;; Use while loop.
    (defun lengths-list-many-files (list-of-files)
      "Returns list of length of defuns in LIST-OF-FILES."

      (let (lengths-list)

       ;;; true-or-false-test
        (while list-of-files
          (setq lengths-list
                (append
                 lengths-list

      ;;; Generate a length's list
                 (lengths-list-file
                  (expand-file-name (car list-of-files)))))

     ;;; Make files' list shorter
          (setq list-of-files (cdr list-of-files)))

    ;;; Return final value of legths' list
        lengths-list))
  #+end_src

- ~expand-file-name~ is built-in function that converts a file name to
  the absolute, long, path name form.  The function employs the name
  of the directory in which the function is called.

- Thus, if ~expand-file-name~ is called on ~debug.el~ when Emacs is
  visiting the ~/usr/local/share/emacs/22.1.1/ lisp/emacs-lisp/~
  directory,

  #+begin_src emacs-lisp
    debung.el
  #+end_src

- becomes

  #+begin_src emacs-lisp
    /usr/local/share/emacs/22.1.1/lisp/emacs-lisp/debug.el
  #+end_src

- The only other new element of this function definition is the as yet
  unstudied function ~append~, which merit's a short section for
  itself.

*** The ~append~ function

- The ~append~ function attached one list to another. Thus:

  #+begin_src emacs-lisp
    (append '(1 2 3 4) '(5 6 7 8))
  #+end_src

- produce this list:

  #+begin_src emacs-lisp
    (1 2 4 5 6 7 8)
  #+end_src

- This is exactly how we want to attach two lengths' list produced by
  ~lengths-list-file~ to each other.  The result contrast with ~cons~,

  #+begin_src emacs-lisp
    (cons '(1 2 3 4) '(5 6 7 8))
  #+end_src

- Which construct a new list in which the first argument to ~const~
  becomes the first element of the new list:

  #+begin_src emacs-lisp
    ((1 2 3 4) 5 6 7 8)
  #+end_src

** Recursively Count Words in Different Files

- Besides a ~while~ loop, you can work on each of a list of files with
  recursion.  A recursive version of ~lengths-list-many-files~ is
  short and simple.

- The recursive function has the usual parts: the do-again-test, the
  next-step-expression, and the recursive call.  The do-again-test
  determines whether the function should call itself again, which it
  will do if the ~list-of-files~ contains any remaining elements; the
  next-step-expression resets the ~list-of-files~ to the CDR of
  itself, so eventually the list will be empty; and the recursive call
  calls itself on the shorter list.  The complete function is shorter
  than this description!

  #+begin_src emacs-lisp
    (defun recursive-lengths-list-many-files (list-of-files)
      "Return list of lengths of eah defun in LIST-OF-FILES."
      (if list-of-files                   ; do-again-test
          (append
           (lengths-list-file
            (expand-file-name (car list-of-files)))
           (recursive-lengths-list-many-files
            (cdr list-of-files)))))
  #+end_src

- In a sentence, the function returns the lengths' list for the first
  of the ~list-of-files~ appended to the result of calling itself on
  the rest of the ~list-of-files~.

- Here is a test of ~recursive-lengths-list-many-files~, along with
  the results of running ~lengths-list-file~ on each of the list
  individually.

- Install ~recursive-lengths-list-many-files~ and ~lengths-list-file~,
  if necessary, and then evaluate the following expressions.  You many
  need to change the files' pathnames; those here work when his Info
  file and the Emacs sources are located in their customary places.
  To change the expression, copy them to the ~*scracth*~ buffer, and
  then evaluate them.

- The results are shown after the ‘~⇒~’.  (These results are for files
  from Emacs version 22.1.1; files from other versions of Emacs may
  produce different results.)

  #+begin_src emacs-lisp
    (cd "/usr/local/share/emacs/22.1.1/")

    (length-list-file "./lisp/macros.el")
         ⇒ (283 263 480 90)

    (lengths-list-file "./lisp/mail/mailalias.el")
         ⇒ (38 32 29 178 180 321 218 324)

    (lengths-list-file "./lisp/makesum.el")
         ⇒ (85 181)

    (recursive-lengths-list-many-files
        '("./lisp/macros.el"
            "/lisp/mailalias.el"
            "/lisp/makesum.el"))
         ⇒ (283 263 480 90 38 32 29 178 180 321 218 324 85 181)
  #+end_src

- The ~recursive-lengths-list-many-files~ function produces the output
  we want.

- The next step is to prepare the data in the list for display in graph.

** Prepare the Data for Display in a Graph

- The ~recursive-lengths-list-many-files~ function returns a list of
  numbers.  Each number records the length of a function definition.
  What we need to do now is transform this data into a list of numbers
  suitable for generating a graph.  The new list will tell how many
  functions definitions contains less than 10 words and symbols, how
  many contain between 10 and 19 words and symbols, how many contain
  between 20 and 29 words and symbols, and so on.

- In brief, we need to go through the length's list produced by the
  ~recursive-lengths-list-many-files~ function and count the number of
  defuns within each range of lengths, and produce a list of those
  numbers.

  - [[The Data for Display in Detail][Data for Display in Detail]]

  - [[Sorting Lists][Sorting]]                          Sorting list

  - [[Making a List of Files][Files List]]              Making a list of files

  - [[Counting function definitions][Counting function definitions]]

*** The Data for Display in Detail

- Based on what we have done before, we can readily foresee that it
  should not be too hard to write a function that CDRs down the
  length's list, looks at each element, determines which length range
  it is in, and increments a counter for that range.

- However, before beginning to write such a function, we should
  consider the advantages of sorting the lengths' list first, so the
  number ordered from smallest to largest.  First, sorting will make
  it easier to count the number in each range, since two adjacent
  numbers will either be in the same length range or in adjacent
  ranges.  Second, by inspecting a sorted list, we can discover the
  highest and lowest number, and thereby determine the largest and
  smallest length range that we will need.

*** Sorting Lists

- Emacs contains a function to sort lists, called (as you might guess)
  ~sort~.  The ~sort~ function takes two arguments, the list to be
  sorted, and a predicate that determines whether the first of two
  list elements is less than the second.

- As we saw earlier (see [[][Using the Wrong Type Object as an
  Argument]]), a predicate is a function that determines whether some
  property is true or false.  The ~false~ function will reorder a list
  according to whatever property the predicate uses; this means that
  ~sort~ can be used to sort non-numeric lists by non-numeric
  criteria--it can, for example, alphabetize a list.

- The ~<~ function is used when sorting a numeric list.  For example,

  #+begin_src emacs-lisp
    (sort '(4 8 21 17 33 7 21) '<)
  #+end_src

- produces this:

  #+begin_src emacs-lisp
    (4 7 7 8 17 21 21 33)
  #+end_src

- (Note that in this example, both the arguments are quoted so that
  the symbols are not evaluated before being passed to ~sort~ as
  arguments.)

- Sorting the list returned by the ~recursive-lengths-list-many-files~
  function is straightforward; it uses the ~<~ function:

  #+begin_src emacs-lisp
    (sort
     (recursive-lenghts-list-many-files
      '("./lisp/macros.el"
        "./lisp/mailalias.el"
        "./lisp/makesum.el"))
     '<)
  #+end_src

- which produces:

  #+begin_src emacs-lisp
    ;;; or
    (sort '(283 263 480 90 38 32 29 178 180 321 218 324 85 181) '<)

    ⇒ (29 32 38 85 90 178 180 181 218 263 283 321 324 480)
  #+end_src

- (Note in this example, the first argument to ~sort~ is not quoted,
  since the expression must be evaluated so as to produce the list
  that is passed to ~sort~.)
*** Making a List of Files

+ The ~recursive-lengths-list-many-files~ function requires a list of
  files as its argument.  For out test examples, we constructed such a
  list by hand; but the Emacs Lisp source directory is too large for
  us to do for that, we will write a function to do the job for us.
  In this function, we will use both a ~whil~ loop and recursive call.

- We did not have to write a function like this for older versions of
  GNU Emacs, since they placed all the '~.el~' files in one directory.
  Instead, we were able to use the ~directory-files~ function, which
  lists the names of files that match a specified pattern within a
  single directory.

- However, recent version of Emacs place Emacs Lisp files in
  sub-directories of the top level ~lisp~ directory.  This
  re-arrangement eases navigation.  For example, all the mail related
  files are in a ~lisp~ sub-directory called ~mail~.  But at the same
  time, this arrangement forces us to create a file listing function
  that descends into the sub-directories.

- We can create this function, called ~files-in-below-directory, using
  familiar functions such as ~car~, ~nthcdr~, and ~substring~ in
  conjunction with an existing function called
  ~directory-files-and-attributes~.  This latter function not only
  list all the filenames in a directory, including the names of
  sub-directories, but also their attributes.

- To restate our goal: to crate a function that will enable us to feed
  filenames to ~recursive-lengths-list-many-files~ as a list that
  looks like this (but which more elements):

  #+begin_src emacs-lisp
    ("./lisp.macros.el"
     "./lisp/mail/rmail.el"
     "/lisp/makesum.el")
  #+end_src

- The ~directory-files-and-attributes~ function returns a list of
  lists.  Each of the lists within the main list consists of 13
  elements.  The first element is a string that contains the name of
  the file--which, in GNU/Linux, may be a /directory file/, that is to
  say, a file with the special attributes of directory.  The second
  elements of the list is ~t~ for a directory, a string for symbolic
  link (the string is the name linked to), or nil.

- For example, the first '~.el~' file in the ~lisp/~ directory is
  ~abbrev.el~.  Its name is
  ~/usr/local/share/emacs/22.1.1/lisp/abbrev.el~ and it is not a
  directory or a symbolic link.

- This is how ~directory-files-and-attributes~lists that file and its
  attributes:

  #+begin_src emacs-lisp
    ("abbrev.el"
     nil
     1
     1000
     100
     (20165 27034 697000)
     (17905 55681 0 0)
     (20615 26327 734791 805000)
     13188
     "-rw-r--r--"

     t
     2971624
     773)
  #+end_src

- On the other hand, ~mail/~ is a directory within the ~lisp/~
  directory.  The beginning of its listing looks like this:

  #+begin_src emacs-lisp
    ("mail"
     t
     ...
     )
  #+end_src

- To learn about the different attributes, look at the documentation
  of ~file-attributes~.  Bear in mind that the ~file-attributes~
  function does not list the filename, so its first elements is
  ~directory-files-and-attributes~'s second element.)

- We will want our new function, ~files-in-below-directory~, to list
  the '~.el~' files in the directory it is told to check, and in any
  directory below that directory.

- This give us a hint on how to construct ~files-in-below-directory~:
  within a directory, the function should add '~.el~' filename to a
  list; and if, within a directory, the function comes upon a
  sub-directory, it should go into that sub-directory and repeat its
  actions.

- However, we should note that every directory contains a name that
  refers to itself, called ~.~ ("dot"), and a name that refers to its
  parent directory, called ~..~ ("dot dot").  (in ~/~, the root
  directory, ~..~ refers to itself, since ~/~ has no parent.)
  Clearly, we do not want our ~files-in-below-directory~ function to
  enter those directories, since they always lead us, directly or
  indirectly, to the current directory.

- Consequently, our ~files-in-below-directory~ function must do
  several tasks:

  - Check to see whether it is looking at a filename that ends in
    '~.el~'; and if so, add its name to a list.

  - Check to see whether it is looking a a filename that is the name
    of directory: and if so,

        - Check to see whether it is looking at ~.~ or ~..~; and if so
          skip it.

        - Or else, go into that directory and repeat that process.

- Let's write a function definition to do these tasks.  We will use a
  ~while~ loop to move from one filename to another within a
  directory, checking what needs to be done; and we will use a
  recursive call to repeat the actions on each sub-directory.  The
  recursive pattern is Accumulate (see [[]Accumulate]]), using
  ~append~ as the combiner.

  #+begin_src emacs-lisp
    (defun files-in-below-directory (directory)
      "List the .el files in DIRECTORY and in its sub-directories/"
      ;;; Although the function will be used non-interactively,
      ;;; it will be easier to test if we make it interactive.
      ;;; The directory will have a name such as
      ;;; "/usr/local/share/emacs/22.1.1/lisp/"

      (let (el-files-list
            (current-directory-list
             (directory-files-and-attributes directory t)))
        ;; while we are in the current directory
        (while current-directory-list
          (cond
           ;; check to see whether filename ends in '.el'
           ;; and if so, add its name to a list
           ((equal ".el" (substring (car (car current-directory-list)) -3))
            (setq el-files-list
                  (const (car (car current-directory-list)) el-files-list)))
           ;; check whether filename is that of a directory
           (eq t (cdr (car curent-directory-list))))
          ;; decide whether to skip or recurse
          (if
              (equal "."
                     (substring (car (car current-directory-list)) -1))
              ;; Then do nothing since filename is that of
              ;;   current directory or parent, "." or ".."
              ()
            ;; else descend into directory and repeat the process
            (setq el-files-list
                  (append
                   (files-in-below-directory
                    (car (car current-directory-list)))
                   el-files-list)))

            ;;; move to the next filename in the list; this also
            ;;; shortens the list so the while loop eventually comes to an end
          (setq current-directory-list (cdr current-directory-list)))
    ;;; returns the filenames
        el-files-list))
  #+end_src

- The ~files-in-below-directory-files~ function takes one arguments,
  the name of directory.

- Thus, on my system,

  #+begin_src emacs-lisp
    (length
        (files-in-below-directory "/usr/local/share/emacs/2.1.1/lisp/"))
  #+end_src

- tells me that in a below my Lisp sources directory are 1031 '~.el~'
  files.

- ~files-in-below-directory~ returns a list in reverse alphabetical
  order.  An expression to sort the list in alphabetical order looks
  like this:

  #+begin_src emacs-lisp
    (sort
     (files-in-below-directory "/usr/local/share/emacs/2.1.1/lisp/")
     'string-lessp)
  #+end_src

*** Counting function definitions

- our immediate goal is to generate a list that tells us how many
  function definitions contains fewer that 10 words and symbols, how
  many contain between 10 and 19 words and symbols, how many contain
  between 20 and 29 words and symbols, and so on.

- With a sorted list of numbers, this is easy: count how many elements
  of the list are smaller than 10, then, after moving the number just
  counted, count how many are smaller than 20, then, after moving past
  the number just counted, count how many are smaller than 30, and so
  on.  Each of the numbers, 10, 20, 30, 40, and the like, is one
  larger than the top of that range.  We can call the list of such
  number the ~top-of-ranges~ list.

- If we wished, we could generate this list automatically, but it is
  simpler to write a list manually.  Here it is:

  #+begin_src emacs-lisp
    (defvar top-of-ranges
      '(10   20  30  40  50
        60   70  80  90 100
        110 120 130 140 150
        160 170 180 190 200
        210 220 230 240 250
        260 270 280 290 300)
      "List specifying ranges for `defuns-per-range'.")
  #+end_src

- to change the ranges, we edit this list.

- Next, we need to write the function that creates the list of the
  number of definitions within each range.  Clearly, this function
  must take the ~sorted-lengths~ and the ~top-of-ranges~ lists as
  arguments.

- The ~defuns-per-range~ function must do two things again and again:
  it must count the number of definitions within a range specified by
  the current top-of-range value; and it must shift to the next higher
  value in the ~top-of-ranges~ list after counting the number of
  definitions in the current range.  Since each of these actions is
  repetitive, we can use ~while~ loops for the jobs.  One loop count
  the number of definitions in the range defined by the current
  top-level-range value, and the other loop selects each of the
  top-of-range values in turn.

- Several entries of the ~sorted-lengths~ list are counted for each
  range; this means that the loop for the ~sorted-lenghts~ will be
  inside the loop for the ~top-of-ranges~ list, like a small gear
  inside a big gear.

- The inner loop counts the number of definitions within a range.  It
  is a simple loop of the type we have seen before.  (See [[][A loop
  with an incrementing counter]].)  The true-or-false test of the loop
  tests whether the value from the ~sorted-lengths~ list is smaller
  than the current value of the top of the range.  If it is, the
  function increments the counter and tests the next value from the
  ~sorted-lengths~ lists.

- The inner loop looks like this:

  #+begin_src emacs-lisp
    (while length-element-smaller-than-top-of-range
      (setq number-within-range (1+ number-within-range))
      (setq sorted-lengths (cdr sorted-lengths)))
  #+end_src

- The outer loop must start with the lowest value of the
  ~top-of-ranges~ list, and then be set to each of the succeeding
  higher values in turn.  This can be done with a loop like this:

  #+begin_src emacs-lisp
    (while top-of-ranges
      body-of-loop...
      (setq top-of-ranges (cdr top-of-ranges)))
  #+end_src

- Put together, the two loops look like this:

  #+begin_src emacs-lisp
    (while top-of-ranges

      ;; Count the number of elements within the current range.
      (while length-of-element-smaller-than-top-of-range
        (setq number-within-range (1+ number-within-range))
        (setq sorted-lengths (cdr sorted-lengths)))

      ;; Move to next range
      (setq top-of-ranges (cdr top-of-ranges)))
  #+end_src

- In addition, in each circuit of the outer loop, Emacs should record
  the number of definitions within that range (the value of
  ~number-within-range~) in a list.  We van use ~cons~ for this
  purpose.  (See [[][cons]].)

- The ~cons~ function work fine, except that the list it constructs
  will contain the number of definitions for the highest range at its
  beginning and the number of definitions for the lowest range at its
  end.  This is because ~cons~ attaches new elements of the list to
  the beginning of the list, and since the two loops are working their
  way through the lengths' list from the lower end first, the
  ~defuns-per-range-list~ will end up largest number first.  But we
  will want to print our graph with smallest values first and the
  larger later.  This solution is to reverse the order of the
  ~defuns-per-range-list~.  We can do this using the ~nreverse~
  function, which reverses the order of a list.

- For example,

  #+begin_src emacs-lisp
    (nreverse '(1 2 3 4))
  #+end_src

- produces:

  #+begin_src emacs-lisp
    (4 3 2 1)
  #+end_src


- Note that the ~nreverse~ function is destructive--that is, it
  changes the list to which it is applied; this contrast with the
  ~car~ and ~cdr~ functions, which are non-destructive.  In this case,
  we do not want the original ~defuns-per-range-list~, so it does not
  matter that it is destroyed.  (The ~reverse~ function provides a
  reversed copy of list, leaving the original list as is.)

- Put all together, the ~defuns-per-range~ looks like this:

  #+begin_src emacs-lisp
    (defun defuns-per-range (sorted-lengths top-of-ranges)
      "SORTED-LENGTHS defuns in each TOP-OF-RANGES range."
      (let ((top-of-range (car top-of-ranges))
            (number-within-range 0)
            defuns-per-range-list)


        ;; Outer loop.
        (while top-of-ranges


          ;; Inner loop.
          (while (and
                  ;; Need number for numeric test.
                  (car sorted-lengths)
                  (< (car sorted-lengths) top-of-range))


            ;; Count number of definitions within current range.
            (setq number-within-range (1+ number-within-range))
            (setq sorted-lengths (cdr sorted-lengths)))

          ;; Exit inner loop but remain within outer loop.


          (setq defuns-per-range-list
                (cons number-within-range defuns-per-range-list))
          (setq number-within-range 0)      ; Reset count to zero.


          ;; Move to next range.
          (setq top-of-ranges (cdr top-of-ranges))
          ;; Specify next top of range value.
          (setq top-of-range (car top-of-ranges)))


        ;; Exit outer loop and count the number of defuns larger than
        ;;   the largest top-of-range value.
        (setq defuns-per-range-list
              (cons
               (length sorted-lengths)
               defuns-per-range-list))


        ;; Return a list of the number of definitions within each range,
        ;;   smallest to largest.
        (nreverse defuns-per-range-list)))

  #+end_src

- The function is straightforward except for one subtle feature.  The
  true-or-false test of the inner loop looks like this:

  #+begin_src emacs-lisp
    (and (car sorted-lengths)
         (< (car sorted-lengths) top-of-range))
  #+end_src

- The purpose of the test is to determine whether the first item in
  the ~sorted-lengths~ list is less than the value of the top of the
  range.

- The simple version of the test works fine unless the
  ~sorted-lengths~ list has a ~nil~ value.  In that case, the ~(car
  sorted-lengths)~ expression function returns ~nil~.  The ~<~
  function cannot compare a number to ~nil~, which is an empty list,
  so Emacs signals an error and stops the function from attempting to
  continue to execute.

- The ~sorted-lengths~ list always become ~nil~ when the counter
  reaches the end of the list.  This means that any attempt to use the
  ~defuns-per-range~ function with the simple version of the test will
  fail.

- We solve the problem by using the ~(car sorted-lengths)~ expression
  in conjunction with the ~and~ expression.  The ~(car
  sorted-lengths)~ expression returns a non-~nil~ value so long as the
  list has at least one number within it, but returns ~nil~ if the
  list empty.  The ~and~ expression first evaluates the ~(car
  sorted-lengths)~ expression, and if it is ~nil~, returns false
  /without/ evaluating the ~<~ expression.  But if the ~(car
  sorted-lengths)~ expression returns a non-~nil~ value, the ~and~
  expression evaluates the ~<~ expression, and returns that value as
  the of the ~and~ expression.

- This way, we avoid an error.

- Here is a short test of ~defuns-per-range~ function.  First,
  evaluate the expression that binds (a shortened) ~top-of-ranges~
  list to the list of values, then evaluate the expression for binding
  the ~sorted-lengths~ list, and then evaluate the ~defuns-per-range~
  function.

  #+begin_src emacs-lisp
    ;;; (Shorter list than we will use later.)
    (setq top-of-ranges
       '(110 120 130 140 150
         160 170 180 190 200))

    (setq sorted-lengths
          '(85 86 110 116 122 154 176 179 200 265 300 300))

    (defuns-per-range sorted-lengths top-of-ranges)
  #+end_src

- The list returned looks like this:

  #+begin_src emacs-lisp
    (2 2 2 0 0 1 0 2 0 0 4)
  #+end_src

- Indeed, there are two elements of the ~sorted-lengths~ list smaller
  than 110, two elements 110 and 119, two elements between 120 and
  129, and so on.  There are four elements with a values of 200 or
  larger.


* Readying a Graph

- Our goal is to construct a graph showing the numbers of function
  definitions lengths in the Emacs Lisp source.

- As a practical matter, if you were crating a graph. you would
  probably use a program such ~gnuplot~ to do job.  (~gunplot~ is
  nicely integrated into GNU Emacs.) In this case, however, we create
  one from scratch, and in the process we will re-acquaint with some
  of what we learned before and learn more.

- In this chapter, we will first write a single graph printing
  function.  This first definition will be a /prototype/, a rapidly
  written function that enables us to reconnoiter this unknown
  graph-making territory.  We will discover dragons, of find that they
  are myth.  After scouting the terrain, we will feel more confident
  and enhance the function to label the axes automatically.

  - [[Printing the Columns of a Graph][Columns of a graph]]

  - [[The ~graph-body-print~ Function][graph-body-print]]                             How to print the body of paragraph

  - [[The ~recursive-graph-body-print~ Function][recursive-graph-body-print]]

  - [[Need for Printed Axes][Printed Axes]]

** Printing the Columns of a Graph

- Since Emacs is designed to be flexible and work with all kind of
  terminals, including character-only terminals, the graph will need
  to be made from one of the typewriter symbols.  An asterisk will do;
  as we enhance the graph-printing function, we can make the choice of
  symbol a user option.

- We can call this function ~graph-body-print~; it will take a
  ~numbesr-list~ as its only argument.  At this stage, we will not
  label the graph, but only print its body.

- The ~graph-body-print~ function inserts a vertical column of
  asterisks for each element in the ~numbers-list~.  The height of each
  line is determined by the value of that element of the
  ~numbers-list~

- Inserting columns is a repetitive act; that means that this function
  can be written either with a ~while~ loop or recursively.

- Our first challenge is to discover how to print a column of
  asterisks.  Usually, in Emacs, we print characters onto a screen
  horizontally, line by line, by typing.  We have to routes we can
  follow: write our own column-insertion function or discover whether
  one exists in Emacs.

- To see whether there is one in Emacs, we can use the ~M-x apropos~
  command.  This command is like the ~C-h a~ (~command-apropos~)
  command, except that the latter finds only those functions that are
  command.  The ~M-x apropos~ command list all symbol that match a
  regular expression, including functions that are not interactive.

-  What we want to look for is some command that prints or inserts
  columns.  Very likely, the name of the function will contain either
  the word "print" or the word "insert" or the word "column".
  Therefore, we can simply type ~M-x apropos RET print\|insert\|column
  RET~ and look at the result.  On my system, this command once took
  quite some time, and hen produced a list of 79 functions and
  variables.  Now it does not take much time at all and produces a
  list of 211 functions and variables.  Scanning down the list, the
  only function that looks as if it might do the job is
  ~insert-rectangle~

- Indeed, this is the function we want; its documentation says:

  #+begin_src emacs-lisp
    insert-rectangle:
    "Insert text of RECTANGLE with upper left corner at point.
    RECTANGLE's first line is inserted at point, its second
    line is inserted at a point vertically under point, etc.
    RECTANGLE should be a list of strings.
    After this command, the mark is at the upper left corner
    and point is at the lower right corner."
  #+end_src

- We can run a quick test, to make sure it does what expect of it.

- Here is the result of placing the cursor after the
  ~insert-rectangle~ expression and typing ~C-u C-x C-e~
  (~eval-last-sexp~).  The function insert the strings '~"first"~',
  '~"second"~', '~"third"~' at and below point.  Also the function
  returns ~nil~.

  #+begin_src emacs-lisp
    (insert-rectangle '("first" "second" "third"))first
                                                  second
                                                  thirdnil
#+end_src

- Of course, we won't be inserting the text of the ~insert-rectangle~
  expression itself into the buffer in which we are making the graph,
  but will call the function from our program.  We shall, however,
  have to make sure that point in the buffer at the place where the
  ~insert-rectangle~ function will insert its column of strings.

- If you are reading this in Info, you can see how this works by
  switching to another buffer, such as the ~*scratch*~ buffer, placing
  point somewhere in the buffer, typing ~M-:~, typing the
  ~insert-rectangle~ expression into the minibuffer at the prompt, and
  then typing ~RET~.  This causes Emacs to evaluate the expression in
  the minibuffer, but to use as the value of point the position of
  point in the ~*scracth*~ buffer.  (~M-:~is the keybinding for
  ~eval-expression~.  Also, ~nil~ does not appear in the ~*scratch*~
  buffer since the expression is evaluated in the minibuffer.)

- We find when we do this that point ends up at the end of the last
  inserted line--that is to say, this function moves point as a
  side-effect.  If we were to repeat the command. with point at this
  position, the next insertion would be below and to the right of the
  previous insertion.  We don't want this! If we are going to make a
  bar graph, the columns need to be beside each other.

- We are planning to make the columns of the bar graph out of
  asterisks.  The number of asterisks in the column specified by the
  current element of the ~number-list~.  We need to construct a list
  of asterisks of the right length for each call to
  ~insert-rectangle~.  If this list consists solely of the requisite
  number of asterisks, then we will have to position the right number
  of lines above the base for the graph to print correctly.  This
  could be difficult.

- Alternatively, if we can figure out some ways to pass
  ~insert-rectangle~ a list of the same length each time, then we can
  place point on the same line each time, but move it over one column
  to the right for each new column.  If we do this, however, some of
  the entries in the list passed into ~insert-rectangle~ must be
  blanks rather than asterisks.  For example, if the maximum height of
  the graph is 5, but the height of the column is 3, then
  ~insert-rectangle~ requires an argument that looks like this:

  #+begin_src emacs-lisp
    (" " " " "*" "*")
  #+end_src

- The last proposal is not so difficult, so long as we can determine
  the column height.  There are two ways for us to specify column
  height: we can arbitrary state what it will be, which would work
  fine for graphs of that height; or we can search through the list of
  numbers and use the maximum height of the list as the maximum height
  of the graph.  If the latter operation were difficult, then the
  former procedure would be easiest, but there is a function built
  into Emacs that determines the maximum of its arguments.  We can use
  that function.  The function called ~max~ and it returns the largest
  number of all its arguments, which must be numbers.  Thus, for
  example,

 #+begin_src emacs-lisp
    (max 3 4 6 5 7 3)
 #+end_src

- returns 7.  (A corresponding function called ~min~ returns the
  smallest of all its arguments.)

- However, we cannot simply call ~max~ on the ~number-list~; the ~max~
  function expects numbers as it argument, not a list of numbers.
  Thus the following expression,

  #+begin_src emacs-lisp
    (max '(3 4 6 5 7 3))
  #+end_src

- produces the following error:

  #+begin_src emacs-lisp
    Debugger entered--Lisp error: (wrong-type-argument number-or-marker-p (3 4 6 5 7 3))
    max((3 4 6 5 7 3))
    eval((max '(3 4 6 5 7 3)) nil)
    elisp--eval-last-sexp(nil)
    eval-last-sexp(nil)
    funcall-interactively(eval-last-sexp nil)
    call-interactively(eval-last-sexp nil nil)
    command-execute(eval-last-sexp)
  #+end_src

- Just focus on the first line ~(wrong-type-argument
  number-or-marker-p (3 4 6 5 7 3))~

- We need a function that passes a list of arguments to a function.
  This function is ~apply~.  This function applies its first argument
  (a function) to it's remaining arguments, the last of which may be a
  list.

- For example,

  #+begin_src emacs-lisp
    (apply 'max 3 4 6 3 '(4 8 5))
  #+end_src

- returns 8.

- (Incidentally, I don't know how you would learn of this function
  without a book such as this.  It possible to discover other
  functions, like ~search-forward~ or ~insert-rectangle~, by guessing
  at a part of their name and then using ~apropos~.  Even though its
  base in metaphor is clear--apply its first argument to the rest--I
  doubt a novice would come up with that particular word when using
  ~apropos~ or other aid.  Of course, I could be wrong; after all, the
  function was first named by someone who had to invent it.)

- The second and subsequent arguments to ~apply~ are optional, so we
  can use ~apply~ to call a function and pass the elements of a list
  to it, like this, which also returns 8:

  #+begin_src emacs-lisp
    (apply 'max '(4 6 8 5))
  #+end_src

- This latter way is how we will use ~apply~.  The
  ~recursive-lengths-list-many-files~ function returns a numbers' list
  to which we can apply ~max~ (we could also apply ~max~ to the sorted
  numbers' list; it does not matter whether the list is sorted or
  not.)

- Hence, the operation for finding the maximum height of the graph is
  this:

  #+begin_src emacs-lisp
    (setq max-graph-height (apply 'max numbers-list))
  #+end_src

- Now we can return to the question of how to create a list of strings
  for a column of the graph.  Told the maximum height of the graph and
  the number of asterisks that should appear in the column, the
  function should return a list of strings for the ~insert-rectangle~
  command to insert.

- Each column is made up of asterisks or blanks.  Since the function
  is passed the value of the height of the column and the number of
  asterisks in the column, the number of blanks can be found by
  subtracting the number of asterisks form the height of the column.
  Given the number of blanks and the number of asterisks, two ~while~
  loop can be used to construct the list:

  #+begin_src emacs-lisp
    ;;; First version.
    (defun column-of-graph (max-graph-height actual-height)
      "Return list of strings that is one column of a graph."
      (let ((insert-list nil)
            (number-of-top-blanks
             (- max-graph-height actual-height)))


        ;; Fill in asterisks.
        (while (> actual-height 0)
          (setq insert-list (cons "*" insert-list))
          (setq actual-height (1- actual-height)))


        ;; Fill in blanks.
        (while (> number-of-top-blanks 0)
          (setq insert-list (cons " " insert-list))
          (setq number-of-top-blanks
                (1- number-of-top-blanks)))


        ;; Return whole list.
        insert-list))
  #+end_src

- If you install this function and then evaluate the following
  expression you will see that it returns the list as desired:

  #+begin_src emacs-lisp
    (column-of-graph 5 3)
  #+end_src

- returns:

  #+begin_src emacs-lisp
    (" " " " "*" "*" "*")
  #+end_src

- As written, ~column-of-graph~ contains a major flaw: the symbols
  used for the blank and for the marked entries in the column are
  hard-coded as a space and asterisk.  This is fine for a prototype,
  but you, or another use, may wish to use other symbols.  For
  example, in testing the graph function, you may want to use a period
  in place of the space, to make sure the point is being repositioned
  properly each time the ~insert-rectangle~ function is called; or you
  might want to substitute a '~+~' sign or other asterisk.  You might
  even want to make a graph column that is more than one display
  column wide.  The program should be more flexible.  The way to do
  that is to replace the blank and the asterisk with two variables
  that we can call ~graph-blank~ and ~graph-symbol~ and define those
  variables separately.

- Also, the documentation is not well written.  These considerations
  lead us to the second version of the function:

  #+begin_src emacs-lisp
    (defvar graph-symbol "*"
      "String used as symbol in graph, usually an asterisk.")

    (defvar graph-blank " "
      "String used as blank in graph, usually a blank space.
    graph-blank must be the same number of columns wide
    as graph-symbol.")
  #+end_src

- (For an explanation of ~defvar~, see [[][Initializing a Variable
  with ~defvar~]].)

  #+begin_src emacs-lisp
    ;;; Second version.
    (defun column-of-graph (max-graph-height actual-height)
      "Return MAX-GRAPH-HEIGHT strings; ACTUAL-HEIGHT are graph symbols.

    The graph-symbols are contiguous entries at the end
    of the list.
    The list will be inserted as one column as one column of a graph.
    The strings are either graph-blank or graph-symbol."

      (let ((insert-list nil)
            (number-of-top-blanks
             (- max-graph-height actual-height)))


        ;; Fill in graph-symbol
        (while (> actual-height 0)
          (setq insert-list (cons graph-symbol insert-list))
          (setq actual-height (1- actual-height)))


        ;; Fill in graph-blanks
        (while (> number-of-top-blanks 0)
          (setq insert-list (cons graph-blank insert-list))
          (setq number-of-top-blanks
                (1- number-of-top-blanks)))


        ;; Return whole list
        insert-list))
  #+end_src

- If we wished, we could rewrite ~column-of-graph~ a third time to
  provide optionally for a line graph as well as for a bra graph.
  This would not be hard to do.  One way to think of a line graph is
  that it is no more than a bar graph in which the part of each bar
  that is below the top is blank.  To construct a column for a line
  graph, the function first construct a list of blanks that is one
  shorter than the value, then it uses ~cons~ to attach a graph symbol
  to the list; then it uses ~cons~ again to attach the top blanks to
  the list.

- It is easy to see how to write such a function, but since we don't
  need it, we will not do it.  But the job could be done, and if it
  were done, it would be done with ~column-of-graph~.  Evan more
  important, it is worth noting that few changes would have to be made
  anywhere else.  the enhancement, if we ever wish to make it, is
  simple.

- Now, finally, we come to our first actual graph printing function.
  This print the body of a graph, not the labels for the vertical and
  horizontal axes, so we can call this graph ~graph-body-print~.:

** The ~graph-body-print~ Function

- After our preparation in the preceding section, the
  ~graph-body-print~ function is straightforward.  The function will
  print column after column of asterisks ans blanks, using the
  elements of a number' list to specify the number of asterisks in
  each column.  This is a repetitive pact, which means we can use a
  decrementing ~while~ loop or recursive function for the job.  In
  this section, we will write the definition using a ~while~ loop.

- The ~column-of-graph~ function requires the height of the graph as
  an argument, so we should determine and record that a local
  variable.

- This lead us to the following template for the ~while~ loop version
  of this function:

  #+begin_src emacs-lisp
    (defun graph-body-print (numbers-list)
      "documentation…"
      (let ((height  …
                     …))


        (while numbers-list
          insert-columns-and-reposition-point
          (setq numbers-list (cdr numbers-list)))))
  #+end_src

- We need to fill in the slots of the template.

- Clearly, we can use the ~(apply 'max number-list)~ expression to
  determine the height of the graph.

- The ~whil~ loop will cycle through the ~numbers-list~ one element at
  a time.  AS it is shortened by the ~(setq numbers-list (cdr
  numbers-lists))~ expression, the CAR of each instance of the list is
  the value of the argument for ~column-of-graph~.

- At each cycle of the ~while~ loop, the ~insert-rectangle~ function
  inserts the list returned by ~column-of-graph~.  Since the
  ~insert-rectangle~ function move point to the lower right of the
  inserted rectangle, we need to save the location of point at the
  time the rectangle is inserted, move back to that position after the
  rectangle is inserted, and then move horizontally to the next place
  from which ~insert-rectangle~ is called.

- If the inserted columns are one character wide, as they will be if
  single blanks and asterisks are used, the repositioning command is
  simply ~(forward-char 1)~; however, the width of a column may be
  greater than one.  This mean that the repositioning command should
  be written ~(forward-char symbol-width)~.  The ~symbol-width~ itself
  is the length of a ~graph-blank~ and can be found using the
  expression ~(length graph-blank)~.  The best place to bind the
  ~symbol-widht~ variable to the value of the width of graph column is
  the varlist of the ~let~ expression.

- These considerations lead to the following function definition:

  #+begin_src emacs-lisp
    (defun graph-body-print (numbers-list)
      "Print a bar graph of the NUMBERS-LIST.
    The numbers-list consists of the Y-axis values."

    (let ((height (apply 'max numbers-list))
            (symbol-width (length graph-blank))
            from-position)


        (while numbers-list
        (setq from-position (point))
        (insert-rectangle
        (column-of-graph height (car numbers-list)))
        (goto-char from-position)
        (forward-char symbol-width)

        ;; Draw graph column by column.
        (sit-for 0)
        (setq numbers-list (cdr numbers-list)))

        ;; Place point for X axis labels.
        (forward-line height)
        (insert "\n")
    ))
  #+end_src

- The one unexpected expression in this function is the ~(sit-for 0)~
  expression in the ~while~ loop.  This expression makes the graph
  printing operation more interesting to watch than it would be
  otherwise.  The expression causes Emacs to /sit/ or do nothing for a
  zero length of time and then redraw the screen.  Placed here, it
  causes Emacs to redraw the screen column by column.  Without it,
  Emacs would never redraw the screen until the function exits.

- We can test ~graph-body-print~ with a short list of numbers.

  + Install ~graph-symbol~, ~graph-blank~, column-of-graph~, which are
    in [[][Column of a graph]]. and ~graph-body-print~.

  + Copy the following expression:

    #+begin_src emacs-lisp
        (graph-body-print '(1 2 3 4 5 6 4 3 5 7 6 5 2 3))
    #+end_src

  + Type ~M-:~ (~eval-expression~).

  + Yank the graph-body-print~ expression into the minibuffer with
    ~C-y~ (~yank~).

  + Press ~RET~ to evaluate the ~graph-body-print~ expression.

- Emacs will print a graph like this:

  #+begin_src emacs-lisp
        *   **
       **  ****
      **** ****
     ********** *
    *************
   **************
  #+end_src

** The ~recursive-graph-body-print~ Function

- The ~graph-body-print~ function may also be written recursively.
  The recursive solution is divided into two parts: an outside wrapper
  that use a ~let~ expression to determine the values of several
  variables that need only be found once, such as the maximum height
  of the graph, and an inside function that is called recursively to
  print the graph.

- The wrapper is uncomplicated:

  #+begin_src emacs-lisp
    (defun recursive-graph-body-print (numbers-list)
      "Print a bar graph of the NUMBERS-LIST.
        The numbers-list consists of the Y-axis values."

      (let ((height (apply 'max numbers-list))
            (symbol-width (length graph-blank))
            from-position)
        (recursive-graph-body-print-internal
         numbers-list
         height
         symbol-width)))
  #+end_src

- The recursive function is a little more difficult.  It has four
  parts: the do-again-test, the printing-code, the recursive call, and
  the next-step-expression.  The do-again-test is a ~when~ expression
  that determines whether the ~number-list~ contains any remaining
  elements; if it does, the function print one column of the graph
  using the printing code and calls itself again.  The function calls
  itself again according to the value produced by the
  next-step-expression which causes the call to act on a shorter
  version of the number-list.

  #+begin_src emacs-lisp
    (defun recursive-graph-body-print-internal (numbers-list height symbol-width)
      "Print a bar graph.
    Used within recursive-graph-body-print function."

      (when numbers-list
        (setq from-position (point))
        (insert-rectangle
         (column-of-graph height (car numbers-list)))
        (goto-char from-position)
        (forward-char symbol-width)
        (sit-for 0)             ; Draw graph column by column
        (recursive-graph-body-print-internal
         (cdr numbers-list) height symbol-width)))
  #+end_src

- After installation, this expression can be tested; here is an sample:

  #+begin_src emacs-lisp
    (recursive-graph-body-print '(3 2 5 6 7 5 3 4 6 4 3 2 1))
  #+end_src

- Here is what ~recursive-graph-body-print produces:

  #+begin_src emacs-lisp
       *
      **   *
     ****  *
     **** ***
   * *********
   ************
   *************
  #+end_src

- Either of these two functions, ~graph-body-print~ or
  ~recursive-graph-body-print~, create the body of a graph.

** Need for Printed Axes

- A graph needs printed axes, so you can orient yourself.  For a
  doc-project, it may be reasonable to draw the axes by hand using
  Emacs's Picture mode; but a graph drawing function may be used more
  than once.

- For this reason, I have written enhancements to the basic
  ~print-graph-body~ function that automatically print labels for the
  horizontal and vertical axes.  Since the label printing functions do
  not contain much new material, I have placed their description in an
  appendix.  See [[][A Graph with labeled Axes]].


* Your ~.emacs~ File

- "You don't have to like Emacs to like it"--this seemingly
  paradoxical statement is the secret of GNU Emacs.  The plain,
  out-of-the-box Emacs is a generic tool.  Most people who use it
  customize it to suit themselves.

- GNU Emacs is mostly written in Emacs Lisp; this means that by
  writing expression in Emacs Lisp you can change or extend Emacs.

  - [[Emacs's Default Configuration][Default Configuration]]

  - [[Site-wide Initialization Files][Site-wide Init]]                          You can write side-wide init files

  - [[Specifying Variables using ~defcustom~][defcustom]]                       Emacs will write code for you

  - [[Beginning a ~.emacs~ file][Beginning init file]]                          How to write a ~.emacs~ init file

  - [[Text and Auto Fill Mode][Text and Auto-fill]]                             Automatically wrap lines

  - [[Mail Aliases][Mail Aliases]]                                              Use abbreviation for email addresses

  - [[Indent Tabs Mode][Indent Tabs Mode]]                                      Don't use tabs with TeX

  - [[Some Keybindings][Keybindings]]                                           Create some personal keybindings

  - [[Keymaps][Keymaps]]                                                        More about key binding

  - [[Loading Files][Loading Files]]                                            Load (i.e., evaluate) files automatically

  - [[Autoloading][Autoloading]]                                                Make functions available

  - [[A Simple Extension: ~line-to-top-of-window~][Simple Extension]]           Define a function; bind it to a key

  - [[X11 Colors][X11 Colors]]                                                  Colors in X.

  - [[Miscellaneous Setting for a ~.emacs~ File][Miscellaneous]]

  - [[A Modified Mode Line][Mode Line]]                                         How to customize your mode line

** Emacs's Default Configuration

- There are those who appreciate Emacs's default configuration.  After
  all, Emacs starts you in C mode when you edit a C file, starts you
  in Fortran mode when you edit a Fortran file, and starts you in
  Fundamental mode when you edit an unadorned file.  This makes sense,
  if you do not know who is going to use Emacs.  Who knows what a
  person hopes to do with an unadorned file? Fundamental mode is the
  right default for such a file, just as C mode is the right default
  for editing C code.  (Enough programming languages have syntaxes
  that enable them to share or nearly share features, so C mode is now
  provided by CC mode, the C Collection.)

- But when you do know who is going to use Emacs--you, yourself--then
  it makes sense to customize Emacs.

- For example, I seldom want Fundamental mode when I edit an otherwise
  undistinguished file; I want Text mode.  This is why I customize
  Emacs: so it suits me.

- You can customize and extend Emacs Lisp code.  You can write this
  code yourself; or you can use Emacs's ~customize~ feature to write
  the code for you.  You can combine your own expressions and
  auto-written Customize expression in your ~.emacs~ file.

- A ~~/.emacs~ file contains and extend Emacs by writing or adapting a
  ~~/.emacs~ file.  This is your personal initialization file; its
  contents, written in Emacs Lisp, tell Emacs what to do.

- (You may also add ~.el~ to ~~/.emacs~ and call it a ~~/.emacs.el~
  file.  In the past, you were forbidden to type the extra keystrokes
  that the name ~~/.emacs.el~ requires, but now you may.  The new
  format is consistent with the Emacs Lisp file naming convention; the
  old format saves typing.)

- A ~~/.emacs~ file contains Emacs Lisp code.  You can write this code
  yourself; or you can use Emacs's ~customize~ feature to write the
  code for you.  You can combine your own expression and auto-written
  Customize expression in your ~.emacs~ file.

- (I myself prefer to write my own expressions, except for those,
  particularly fonts, that I find easier to manipulate using the
  ~customize~ command.  I combine the two methods.)

- Most of this chapter is about writing expressions yourself.  It
  describes a simple ~.emacs~ file; for more information, see ~[[][The
  Init File]] In the GNU Emacs Manual, and the ~[[][The Init File]] in
  the GNU Emacs Lisp Reference Manual]].

** Site-wide Initialization Files

- In addition to your personal initialization file.  Emacs
  automatically loads various site-wide initialization files, if they
  exist.  These have the same form as your ~.emacs~ file, but are
  loaded by everyone.

- Two site-wide initialization files, ~site-load,el~ and
  ~site-init.el~, are loaded into Emacs and then dumped if a dumped
  version of Emacs is created, as is most common.  (Dumped copies of
  Emacs load more quickly.  However, once a file is loaded and dumped,
  a change to it does not lead to a change in Emacs unless you load it
  yourself or re-dump Emacs.  See [[][Building Emacs]] in the GNU
  Emacs Lisp Reference Manual, and the ~INSTALL~ file.)

- Three other site-wide initialization files are loaded automatically
  each time you start Emacs, if they exist.  These are
  ~site-start.el~, which is loaded before your ~.emacs~ file, and
  ~default.el~ and the terminal type file, which are both loaded
  /after/ your ~.emacs~ file.

- Setting and definition in your ~.emacs~ file will overwrite
  conflicting setting and definitions in a ~site-start.el~ file, if it
  exists; but the settings and definitions in a ~default.el~ or
  terminal type file will overwrite those in your ~.emacs~ file.  You
  can prevent interference from a terminal type file by setting
  ~term-file-prefix~ to ~nil~.  See [[][A Simple Extension]].)

- The ~INSTALL~ file that comes in the distribution contains
  description of the ~site-init.el~ and ~site-load.el~ files.

- The ~loadup.el~, ~startup.el~, and ~loaddefs.el~ files control
  loading.  These files are in the ~lisp~ directory of the Emacs
  distribution and are worth perusing.

- The ~loaddefs.el~ file contains a good many suggestions as to what
  to put into your own ~.emacs~ file, or into a site-wide
  initialization file.

** Specifying Variables using ~defcustom~

- You can specify variables using ~defcustom~ so that you and others
  can then use Emacs's ~cutomize~ feature to set their values.  (You
  cannot use ~customize~ to write function definitions; but you can
  write ~defuns~ in your ~.emacs~ file.  Indeed, you can write any
  Lisp expression in your ~.emacs~ file.)

- The ~customize~ feature depends on the ~defcustom~ macro.  Although
  you can use ~devfar~ or ~setq~ for variables that users set, the
  ~defcustom~ macro is designed for the job.

- You can use your knowledge of ~devfar~ for writing the first three
  arguments for ~defcustom~ is the name of the variable.  The second
  argument is the variable's initial value. if any; and this value is
  set only if the value has not already been set.  The third argument
  is the documentation.

- The fourth and subsequent arguments to ~defcustom~ specify types and
  options; these are not featured in ~devfar~.  (These arguments are
  optional.)

- Each of these arguments consists of a keyword followed by a value.
  Each keyword starts with the colon character '~:~'.

- For example, the customizable user option variable ~text-mode-hook~
  looks like this:

  #+begin_src emacs-lisp
    (defcustom text-mode-hook nil
      "Normal hook run when entering Text mode and many related mode."
      :type 'hook
      : options '(turn-on-auto-fill flyspell-mode)
      : group 'wp)
  #+end_src

- The name of the variable is ~text-mode-hook~l it has no default
  value; and its documentation string tells you what it does.

- The ~:type~ keyword tells Emacs the kind of data to which
  ~text-mode-hook~ should be set and how to display the value in
  Customization buffer.

- The ~:options~ keyword specifies a suggested list of values for the
  variable.  Usually ~:options~ applies to a hook.  The list is only a
  suggestion; it is not exclusive; a person who sets the variable may
  set it to other values; the list shown following the ~:options~
  keyword is intended to offer convenient choices to a user.

- Finally, the ~:group~ keyword tells the Emacs Customization command
  in which group the variable is located.  This tells where to find
  it.

- The ~defcustom~ macro recognizes more than a dozen keywords.  For
  more information, see [[][Writing Customization Definitions]] in The
  GNU Emacs Lisp Reference Manual.

- Consider ~text-mode-hook~ as an example.

- There are two ways to customize this variable.  You can use the
  customization command or write the appropriate expression yourself.

- Using the customized command, you can type:

  #+begin_src emacs-lisp
    M-x customize
  #+end_src

- and find the group for editing flies of text is called "Text".
  Enter that group.  Text Mode Hook is the first member.  You can
  click on its various options, such as ~turn-on-auto-fill~, to set
  the values, after you click on the button to

  #+begin_src emacs-lsip
    Save for Future Sessions
  #+end_src

- Emacs will write an expression into your ~.emacs~ file, it will look
  like this:

  #+begin_src emacs-lisp
    (custom-set-variables
      ;; custom-set-variables was assed by Custom.
      ;; If you edit it by hand, you could mess it up, so be careful.
      ;; Your init file should contain onlyone such instance.
      ;; If there is more than one, they won't work right.
     '(text-mode-hook '(turn-on-auto-fill text-mode-hook-identify)))
  #+end_src

- (The ~text-mode-hook-identify~ function tells
  ~toggle-text-mode-auto-fill~ which buffers are in Text mode.  It
  comes on automatically.)

- The ~custom-set-variables~ function works somewhat differently than
  a ~setq~.  While I have learned the differences, I modify the
  ~custom-set-variabels~ expression in my ~.emacs~ file by hand: I
  make the changes in what appears to me to be reasonable manner and
  have not any problems.  Others prefer to use the Customization
  command and let Emacs do the work for them.

- Another ~custom-set-...~ function is ~custom-set-faces~.  This
  function sets the various font faces.  Over time, I have set a
  considerable number of faces, some of time, I re-set them using
  ~customize:~ other times, I simply edit the ~custom-set-faces~
  expression in my ~.emacs~ file itself.

- The second way to customize your ~text-mode-hook~ is to set it
  yourself in your ~.emacs~ file using code that has nothing to do
  with the ~custom-set-...~ functions.

- When you do this, and later use ~customize~, you will see a message
  that says.

  #+begin_src emacs-lisp
    CHANGED outside Customize; operating on it here may be unreliable.
  #+end_src

- This message is only a warning. If you click on the button to

  #+begin_src emacs-lisp
    Save for Future Session
  #+end_src

- Emacs will write a ~custom-set-...~ expression near the end of your
  ~.emacs~ file that will be evaluated after your hand-written
  expression.  It will, therefore, overrule your hand-written
  expression.  No harm will be done.  When you do this, however, be
  careful to remember which expression is active; if you forget, you
  may confuse yourself.

- So long as you remember the values are set, you will have no
  trouble.  In any event, the values are always set in your
  initialization file, which is usually called ~.emacs~.

- I myself use ~customize~ for hardly anything.  Mostly, I write
  expression myself.

- Incidentally, to be more complete concerning defines: ~defsubst~
  defines an inline function.  The syntax is just like that of
  ~defun~, ~defconst~ defines a symbol as a constant.  The intent is
  that neither programs nor users ever change a value set by
  ~defconst~.  (You can change it; the value set is a variable; but
  please do not.)

** Beginning a ~.emacs~ file

- When you start Emacs, it loads your ~.emacs~file unless you tell it
  not to by specifying '~-q~' on the command line.  (The ~emacs -q~
  command gives you a plain, out-of-the-box Emacs.)

- A ~.emacs~ file contains Lisp expressions.  Often, these are no more
  than expressions to set values; sometimes they are function
  definitions.

- See
  [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Init-File][The
  Init File ~~/.emacs~]] in The GNU Emacs Manual, for a short
  description of initialization files.

- The first part of the file consists of comments: reminders to
  myself.  By now, of course, I remember these things, but when I
  started, I did not.

  #+begin_src emacs-lisp
    ;;;; Bob's .emacs file
    ; Robert J.  Chassell
    ; 26 September 1985
  #+end_src

- Look at that date! I started this file a long time ago.  I have been
  adding to it ever since.

  #+begin_src emacs-lisp
  ; Each section in this file is introduced by a
  ; line beginning with four semicolons; and each
  ; entry is introduced by a line beginning with
  ; three semicolons.
  #+end_src

- This describes the usual conventions for comments in Emacs Lisp.
  Everything on a line that follows a semicolon is a comment.  Two,
  three, and four semicolons are used as subsection and section
  markers.  (See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Comments][Comments]] in The GNU Emacs Lisp Manual, for more about
  comments.)

  #+begin_src emacs-lisp
    ;;;; The Help Key
    ; Control-h is the help key;
    ; after typing control-h, type a letter to
    ; indicate the subject about which you want help.
    ; For an explanation of the help facility,
    ; type control-h two times in a row.
  #+end_src

- Just remember: type ~C-h~ two times for help.

  #+begin_src emacs-lisp
  ; To find out about any mode, typr control-h m
  ; while in that mode.  For example, to find out
  ; about mail mode, enetr mail mode and then type
  ; control-h m.
  #+end_src

- "Mode help", as I call this,is very helpful.  Usually, it tells you
  all you need to know.

- Of course, you don't need to include comments like these in your
  ~.emacs~ file.  I included them in mine because I kept forgetting
  about Mode help or the conventions for comments--but I was able to
  remember to look here to remind myself.

** Text and Auto Fill Mode

- Now we come to the part that turns on Text mode and Auto fill mode.

  #+begin_src emacs-lisp
    ;;;  Text mode and Auto Fill mode
    ;; The next two line put Emacs into Text mode
    ;; and Auto Fill mode, and are for writers who
    ;; want to start writing prose rather than code.
    (setq-default major-mode 'text-mode)
    (add-hook 'text-mode-hook 'turn-on-auto-fill)
  #+end_src

- Here is the first part of this ~.emacs~ file that does something
  besides remind a forgetful human!

- The first of the two lines in parentheses tells Emacs to turn on
  Text mode when you find a file, /unless/ that file should go into
  some other mode, such as C mode.

- When Emacs reads a file, it looks at the extension to the file name,
  if any.  (The extension is the part that comes after a '~.~'.) If
  the file ends with a '~.c~', or '~.h~' extension then Emacs turns on
  C mode.  Also, Emacs looks at first nonblank line of the file; if
  the line says ~'-*- C -*-~', Emacs turns on C mode.  Emacs possesses
  a list of extensions ans specifications that it uses automatically.
  In addition, Emacs looks near the last page for a per-buffer, local
  variables list, if any.

- Now, back to the ~.emacs~ file.

- Here is the line again; how does it work?

  #+begin_src emacs-lisp
    (setq major-mode 'text-mode)
  #+end_src

- This line is short, but complete Emacs Lisp expression.

- We are already familiar with ~setq~.  It sets the following
  variable, ~major-mode~, to the subsequent value, which is
  ~text-mode~.  The single-quote before ~text-mode~ tells Emacs to
  deal directly with the ~text-mode~ symbol, no with whatever it might
  stand for.  See [[Setting the Value of a Variable]], for reminder of
  how ~setq~ works.  The main point is that there is no difference
  between the procedure you use to set a value in your ~.emacs~ file
  and the procedure you use anywhere else in Emacs.

- Here is the next line:

  #+begin_src emacs-lisp
    (add-hook 'text-mode-hook 'turn-on-auto-fill)
  #+end_src

- In this line. the ~add-hook~ command adds ~turn-on-auto-fill~ to the
  variable.

- ~turn-on-auto-fill~ is the name of a program, that you guessed it!,
  turns on Auto Fill mode.

- Every time Emacs turns on Text mode, Emacs runs the commands hooked
  onto Text mode.  So every time Emacs turns on Text mode, Emacs also
  turns on Auto Fill mode.

- In brief, the first line causes Emacs to enter Text mode when you
  edit a file, unless the file name extension, a first non-blank line,
  or local variables to tell Emacs otherwise.

- Text mode among other actions, sets the syntax table to work
  conveniently for writers.  In Text Mode, Emacs considers an
  apostrophe as part of a word like a letter; but Emacs does not
  consider a period or a space as part of a word.  Thus, ~M-f~ moves
  you over '~it's~'.  On the other hand, in C mode, ~M-f~ stops just
  after the '~t~' of '~it's~'.

- The second line causes Emacs to turn on Auto Fill mode when it turns
  on Text mode.  In Auto Fill mode, Emacs automatically breaks a line
  that is too wide and brings the excessively wide part of the line
  down to the next line.  Emacs breaks lines between words, not within
  them.

- When Auto Fill mode is turned off, lines continue to the right as
  you type them.  Depending on how you set the value of
  ~truncate-lines~, the words you type either disappear off the right
  side of screen, or else shown, in a rather ugly and unreadable
  manner, as a continuation line on the screen.

- In addition, in this part of my ~.emacs~ file, I tell the Emacs fill
  commands to insert two spaces after a colon:

  #+begin_src emacs-lisp
    (setq colon-double-space t)
  #+end_src

** Mail Aliases

  - Here is a ~setq~ that turns on mail aliases, along with more
    reminders.

    #+begin_src emacs-lisp
      ;;; Message mode
      ;; To enter message mode, type 'C-x m'
      ;; To enter RMAIL (for reading mail),
      ;; type 'M-x rmail'
      (setq mail-aliases t)
    #+end_src

  - This ~setq~ sets the value of the variable ~mail-aliases~ to ~t~.
    Since ~t~ means true, the line says, in effect, "Yes, use mail
    aliases."

  - Mail aliases are convenient short names for long email addresses or
    for list of email addresses.  The file where you keep your aliases
    is ~~/.mailrc~.  You write an alias like this:

    #+begin_src emacs-lisp
      alias geo george@foobar.wiz.edu
    #+end_src

  - When you write a message to George, address it to '~geo~'; the
    mailer will automatically expand '~geo~' to the full address.

** Indent Tabs Mode

- By default, Emacs inserts tabs in place of multiple spaces when it
  formats a region.  (For example, you might indent many lines of text
  all at once with the ~indent-region~ command.)  Tabs look fine on a
  terminal or with ordinary printing, but they produce badly indented
  when you use TeX of Texinfo since TeX ignores tabs.

- The following turns off Indent Tabs mode:

  #+begin_src emacs-lisp
    ;;; Prevent Extraneous Tabs
    (setq-default indent-tabs-mode nil)
  #+end_src

- Noe that this line uses ~setq-default~ rather than ~setq~ that we
  have seen before; ~setq-defaults~ sets value only in buffers that do
  not have their own local values for the variable.

** Some Keybindings

- Now for personal keybindings:

  #+begin_src emacs-lisp
    ;;; Compare windows
    (global-set-key "\C-cw" 'compare-windows)
  #+end_src

- ~compare-windows~ is a nifty command that compares the text in your
  current window with text in the next window.  It takes the
  comparison by starting at point in each window, moving over text in
  each window as far as they match.  I use this command all the time.

- This also shows how to set a key globally, for all modes.

- The command id ~global-set-key~. It is followed by the keybinding.
  In a ~.emacs~ file, the keybinding is written as shown: ~\C-c~
  stands for Control-C, which means to press the control key and the
  ~c~ key at the same time.  The ~w~ means to press the ~w~ key.  The
  keybinding is surrounded by double quotation marks.  In
  documentation, you would write this as ~C-c w~, (If you were binding
  a ~META~ key, such as ~M0-c~, rather than a ~CTRL~ key, you would
  write ~\M-c~ in your ~.emacs~ file.  See [[][Rebinding Keys in Your
  Init File]] in the GNU Emacs Manual, for details.)

- The command invoked by the keys is ~compare-windows~.  Note that
  ~compare-windows~ is preceded by single-quote; otherwise, Emacs
  would first try to evaluate the symbol to determine its value.

- These three things, the double quotation marks, the backslash before
  the '~c~', and the single-quote are necessary parts of the
  keybinding that I tend to forget.  Fortunately, I have come to
  remember that I should look at my existing ~.emacs~ file, and adapt
  what is there.

- As for the keybinding itself: ~C-c w~.  This combines the prefix
  ~C-c~, with a single character, in this case, ~w~.  This set of keys
  ~C-c~ followed by a single character, is strictly reserved for
  individuals' own use.  (I call these /own/ keys, since these are for
  my own use.)  You should always be able to crate such a keybinding
  for your own use without stomping on someone else's keybinding.  If
  you ever write an extension to Emacs, please avoid taking of these
  keys for public key, Create a key like ~C-c C-w~ instead. Otherwise,
  we will run out of own keys.

- Here is another keybinding, with a comment:

  #+begin_src emacs-lisp
    ;;; Keybinding for 'occur'
    ; I use occur a lot, so let's bind it to a key:
    (global-set-key "\C-co" 'occur)
  #+end_src

- The ~occur~ commands shows all the lines in the current buffer that
  contain a match for a regular expression.  When the region is
  active, ~occur~ restricts matches to such region.  Otherwise it uses
  the entire buffer.  Matching lines are shown in a buffer called
  ~*occur*~.  That buffer servers as a menu to jump to occurrences.

- Here is how to unbind a key, so it does not work:

  #+begin_src emacs-lisp
    ;;; Unbind 'C-x f'
    (global-unset-key "\C-xf")
  #+end_src

- There is a reason for this unbinding: I found I inadvertently type
  ~C-x f~ when I meant to type ~C-x C-f~.  Rather than find a file, as
  I intended, I accidentally set the width for filled text, almost
  always to a width I did not want.  Since I hardly ever reset my
  default width, I simply unbound the key.

- The following rebinds an existing key:

  #+begin_src emacs-lisp
    ;;; Rebind 'C-x C-b' for 'buffer-menu'
    (global-set-key "\C-x\C-b" 'buffer-menu)
  #+end_src

- By default, ~C-x C-b~ runs the ~lift-buffers~ command.  This command
  list your buffer in /another/ window.  Since I almost always want to
  do something in that window, I prefer the ~buffer-menu~ command,
  which not only lists the buffers, but moves point into that window.

** Keymaps

- Emacs uses /keymaps/ to record which keys call which command.  When
  you use ~global-set-key~ to set the keybinding for a single command
  in all parts of Emacs, you are specifying the keybinding in
  ~current-global-map~.

- Specific modes, such as C mode or Text mode, have their own keymaps;
  the mode-specific keymaps override the global map that is shared by
  all buffers.

- The ~global-set-key~ function binds, or rebinds, the global keymap.
  For example, the following binds the ~C-x C-b~ to the function
  ~buffer-menu~

  #+begin_src emacs-lisp
    (globla-set-key "\C-x\C-b 'buffer-menu)
  #+end_src

- Mode-specific keymaps are bound using the ~define-key~ function,
  which takes a specific keymap as an argument, as well as the key and
  the command.  For example, my ~.emacs~ file contains the following
  expression to bind the ~textinfo-insert-@group~ command to ~C-c C-c g~

  #+begin_src emacs-lisp
    (defun textinfo-insert-@group ()
      "Insert the string @group in Textinfo buffer."
      (interactive)
      (beginning-of-line)
      (insert "@group\n"))
  #+end_src

- (Of course, I could have use Abbrev mode to save typing, rather than
  write a function to insert word; but I prefer key strokes consistent
  with other Textinfo mode key bindings.)

- You will see numerous ~define-key~ expression in ~loaddefs.el~ as
  well as in the various mode libraries, such as ~cc-mode.el~ and
  ~lisp-mode.el~

- See [[][Customizing Key Bindings]] in the GNU Emacs Manual, and
  [[][Keymaps]] in The GNU Emacs Lisp Reference Manual, for more
  information about keymaps.

** Loading Files

- Many people in the GNU Emacs community have written extensions to
  Emacs.  As time goes by, these extensions are often included in new
  releases.  For example, the Calendar and Diary packages are now part
  the standard GNU Emacs, as is Calc.

- You can use a ~load~ command to evaluate a complete file and thereby
  install all the functions and variables in the file into Emacs, for
  Example:

  #+begin_src emacs-lisp
    (load "~/emacs/slowsplit")
  #+end_src

- This evaluate i.e., loads, the ~slowsplit.el~ file or if it exists,
  the faster, byte compiled ~slowsplit.lec~ file from the ~emacs~
  sub-directory of your home directory.  The file contains the
  function ~split-window-quitely~, which John Robinson wrote in 1989.

- The ~split-window-quitely~ function splits a window with the minimum
  of redisplay.  I installed it in 1989 because it worked well with
  the slow 1200 baud terminals I was then using.  Nowadays, I only
  occasionally come across such as slow connection, but I continue to
  use the function because I like the way it leaves the bottom half of
  a buffer in the lower of the new windows and the top half in the
  upper window.

- To replace the key binding for the default
  ~split-window-vertically~, you must also unset that key and bind the
  keys to ~split-window-quitely~, like this:

  #+begin_src emacs-lisp
    (global-unset-key "\C-x2")
    (global-set-key "\C-x2" 'split-window-quitely)
  #+end_src

- If you load many extensions, as I do, then instead of specifying the
  exact location of the extension file, as shown above, you can
  specify that directory as part of Emacs's ~load-path~.  Then, when
  Emacs loads a file, it will search that directory as well as its
  default list of directories.  (The default list is specified in
  ~path.h~ when Emacs is built.)

- The following command adds your ~~/emacs~ directory to the existing
  load path:

  #+begin_src emacs-lisp
    ;;; Emacs Load Path
    (setq load-path (cons "~/emacs" load-path))
  #+end_src

- Incidentally, ~load-library~ is an interactive interface to the
  ~load~ function.  The complete function looks like this:

  #+begin_src emacs-lisp
    (defun load-library (library)
      "Load the Emacs Lisp Library named LIBRARY.
    This is an interface to the function `load'.  LIBRARY is searched
    for in `load-path', both with and without `load-suffixes' (as
    well as ~load-file-rep-suffixes').

    See Info node `(emacs)lisp libraries' for more details.
    See `load-file' for a different interface to `load'."

      (interactive
       (list (completing-read "Load library: "
                              (apply-partially 'locate-file-completion-table
                                               load-path
                                               (get-load-suffixes)))))
      (load-library))
  #+end_src

- The name of the function, ~load-library~, comes from the use of
  "library" as conventional synonym for "file".  The source for the
  ~load-library~ command is in the ~files.el~ library.

- Another interactive command that does a slightly different job is
  ~load-file~.  See [[][Libraries of Lisp Code for Emacs]] in the GNU
  Emacs Manual, for information on the distinction between
  ~load-library~ and this command.

** Autoloading

- Instead of installing a function by loading the file that contains
  it, or by evaluating the function definition, you can make the
  function available but not actually install it until it is first
  called.  This is called /autoloading/.

- When you execute an autoloaded functions, Emacs automatically
  evaluates the file that contains the definition, and then calls the
  function.

- Rarely used functions are frequently autoloaded.  the ~loaddefs.el~
  library contains thousand of autoloaded functions, from ~5x5~ to
  ~zone~.  Of course, you may come to use a rare function frequently.
  When you do, you should load that function's file with a ~load~
  expression in your ~.emacs~ file.

- In my ~.emacs~ file, I load 14 libraries that contain functions that
  would otherwise be autoloaded.  (Actually, it would have been better
  to include these files in my dumped Emacs, but I forgot.  See
  [[][Building Emacs]] in the GNU Emacs Lisp Reference Manual, and the
  ~INSTALL~ file for more about dumping.)

- You may also want to include autoloaded expressions in your ~.emacs~
  file.  ~autoload~ is built-in function that takes up to five
  arguments, the final three of which are optional.  The first
  argument is the name of the function to be autoloaded; the second is
  the name of the file to be loaded.  The third argument is
  documentation for the function, and the fourth tells whether the
  function can be called interactively.  The fifth argument tells what
  type of object--~autoload~ can handle a keymap or macro as well as a
  function (the default is a function).

- Here is a typical example:

  #+begin_src emacs-lisp
    (autoload 'html-helper-mode
      "html-helper-mode" "Edit HTML documents" t)
  #+end_src

- (~html-helper-mode~ is an older alternative to ~html-mode~, which is
  a standard part of the distribution.)

- This expression autoloads the ~html-helper-mode~ function.  It takes
  it from the ~html-helper-mode.el~ file (or from the byte compiled
  version ~html-helper-mode.elc~, if that exists.)  The file must be
  located in a directory specified by ~load-path~.  The documentation
  says that this is a mode to help you edit documents written in Hyper
  Text Markup Language.  You can call this mode interactively by
  typing ~M-x html-helper-mode~.  (You need to duplicate the
  function's regular documentation in the autoload expression because
  the regular function is not yet loaded, so its documentation is not
  available.)

- See [[][Autoloads]] in The GNU Emacs Lisp Reference Manual, for more
  information.

** A Simple Extension: ~line-to-top-of-window~

- Here is a simple extension to Emacs that moves the line point is on
  to the top of the window.  I use this all the time, to make text
  easier to read.

- You can put the following into a separate file and then load it from
  your ~.emacs~ file, or you can include it with your ~.emacs~ file.

- Here is the definition:

  #+begin_src emacs-lisp
    ;;; Line to top of window;
    ;;; replace three keystroke sequence C-u O C-l
    (defun line-to-top-of-windoe ()
      "Move the line point is on top of window."
      (interactive)
      (recenter 0))
  #+end_src

- Now for the keybinding.

- Nowadays, function keys as well as mouse button events and non-ASCII
  characters are written within square brackets, without quotation
  marks.  (In Emacs version 18 and before, you had to write different
  function key binding for each different make of terminal.)

- I bind ~line-to-top-of-window~ to my ~F6~ function key like this:

  #+begin_src emacs-lisp
    (global-set-key [f6] 'line-to-top-of-window)
  #+end_src

- For more information, see [[][Rebinding Keys in Your Init File]] in
  The GNU Emacs Manual.

- If you run two version of GNU Emacs, such as version 22 and 23, and
  use one ~.emacs~ file, you can select which code to evaluate with
  the following conditional:

  #+begin_src emacs-lisp
    (cond
     ((= 22 emacs-major-version)
      ;; evaluate version 22 code
      ( ... ))

     ((= 23 emacs-major-version)
      ;; evalaute version 23 code
      ( ... )))
  #+end_src

- For example, recent versions blink their cursor by default.  I hate
  such blinking, as well as other features, so I placed the following
  in my ~.emacs~ file.

  #+begin_src emacs-lisp
    (when (>= emacs-major-version 21)
      (blink-cursor-mode 0)
      ;; Insert newline when you press 'C-n' (next-line)
      ;; at the end of the buffer.
      (setq next-line-add-newline t)

      ;; Turn on image viewing
      (auto-image-file-mode t)

      ;; Turn on menu bar (this bar has text)
      ;; (use numeric argument to turn on)
      (menu-bar-mode 1)

      ;; Turn off tool bar (this bar has icons)
      ;; (Use nuemric argument to turn on)
      (tool-bar-mode nil)

      ;; Turn off tooltip mode for tool bar
      ;; (This mode causes icon explanation to pop up)
      ;; (Use numeric argument to turn on)
      (tooltip-mode nil)

      ;; Of tooltips turned on, make tips appear promptly
      (setq tooltip-dela 0.1)  ; default is 0.7 second
      )
  #+end_src

** X11 Colors

- You can specify colors when you use Emacs with the MIT X Windowing
  system.

- I dislike the default colors and specific my own.

- Here are the expression in my ~.emacs~ file that set values:

  #+begin_src emacs-lisp
    ;; Sert cursor color
    (set-cursor-color "white")

    ;; Set mouse color
    (set-mouse-color "white")

    ;; Set foreground and backgroud
    (set-foreground-color "white")
    (set-background-color "darkblue")

    ;; Set highlight colors for isearch and drag
    (set-face-foreground 'highlight "white")
    (set-face-background 'highlight "blue")

    (set-face-foreground 'region "cyan")
    (set-face-background 'region "blue")

    (set-face-foreground 'secondary-selection "skyblue")
    (set-face-background 'secondary-selection "darkblue")

    ;; Set calendar highlighting colors
    (with-eval-after-load 'calendar
       (set-face-foreground 'calendar
        (set-face-foreground 'diary "skyblue")
        (set-face-background 'holiday "slate blue")
        (set-face-foreground 'holiday "white"))
  #+end_src

- The various shades of blue soothe my eye and prevent me from seeing
  the screen flicker.

- Alternatively.  I could have set my specification in various X
  initialization files.  For example, I could set the foreground,
  background, cursor, and pointer (i.e., mouse) colors in my
  ~~/.Xresources~ file like this:

  #+begin_src emacs-lisp
    Emacs*foreground:   white
    Emacs*background:   darkblue
    Emacs*cursorColor:  white
    Emacs*pointerColor: white
  #+end_src

- In any event, since it is not part of Emacs, I set the root color of
  my X window in my ~~/.xinitrc~ file like this:

  #+begin_src emacs-lisp
    xsetroot -solid Navy -fg white &
  #+end_src

** Miscellaneous Setting for a ~.emacs~ File

- Here a few miscellaneous settings:

  - Set the shape and colors of the mouse cursor:

  #+begin_src emacs-lisp
    ;; Cursosr shapes are defined in
    ;; '/usr/include/X11/cursorfont.h';
    ;; for example, the 'target' cursor is number 128;
    ;; the 'top_left_arrow' cursor is number 132.

    (let ((mpointer (x-get-resource "*mpointer"
                                    "*emacs*mpointer")))
      ;; If you have not set your mouse pointer
      ;;    then set it, otherwise leave as is:
      (if (eq mpointer nil)
          (setq mpointer "132"))  ; top_left_arrow
      (setq x-pointer-shape (string-to-number mpointer))
      (set-mouse-color "white"))
  #+end_src

  - Or you can set the values of a variety of features in an alist, like
    this:

    #+begin_src emacs-lisp
      (setq-default
       (default-frame-alist
         '((cursor-color . "white")
           (mouse-color . "white")
           (foreground-color . "white")
           (background-color . "DodgerBlue4")
           ;; (cursor-typr . bar)
           (tool-bar-lines . 0)
           (menu-bar-lines . 1)
           (width . 80)
           (height . 58)
           (font .
                 "-Misc-Fixed-Medium-R-Normal--20-200-75-75-c-100-ISO8859-1")
           ))
    #+end_src

- Convert ~CTRL-h~ into ~DEL~ and ~DEL~ into ~CTRL-h~.  (Some older
  keyboards needed this, although I have no seen the problem
  recently.)

  #+begin_src emacs-lisp
    ;; Translate 'C-h' to <DEL>.
    ; (keyboard-translate ?\C-h ?\C-?)

    ;; Translate <DEL> to 'C-h'
    (keyboard-translate ?\C-? ?\C-h)
  #+end_src

- Turn off a blinking cursor!

  #+begin_src emacs-lisp
    (if (fboundp 'blink-cursor-command)
        (blink-cursor-mode -1))
  #+end_src

- or start GNU Emacs with the command ~emacs -nbc~

- When using ~grep~

  - '~-i~' Ignore case distinctions
  - '~-n~' Prefix each line of output with line number
  - '~-H~' Print filename for each match
  - '~-e~' Protect patterns beginning with a hyphen character, '~-~'

  #+begin_src emacs-lisp
    (setq grep-command "grep -i -nH -e ")
  #+end_src

- Find an existing buffer, even if it has a different name
  This avoid problems with symbolic links.

  #+begin_src emacs-lisp
    (setq find-file-existing-other-name t)
  #+end_src

- Set your language environment and default input method

  #+begin_src emacs-lisp
    (set-language-environment "latin-1")
    ;; Remember you can enable or disable multilangual text input
    ;; with the toggle-input-method' (C-\) command
    (setq default-input-method "latin-1-prefix")
  #+end_src

- If you want to write with Chinese GB characters, set this instead:

  #+begin_src emacs-lisp
    (set-language-environment "Chinese-GB")
    (setq default-input-method "chinese-tonepy")
  #+end_src

*** Fixing Unpleasant Key Bindings

- some systems bind keys unpleasantly.  Sometimes, for example, the
  ~CTR~ key appear in an awkward spot rather than at the far left the
  home row.

- Usually, when people fix these sort of keybindings, they do not
  change their ~~/.emacs~ file.  Instead, they bind the proper keys on
  their consoles with the ~loadkeys~ or ~install-keymap~ commands in
  their boot script and then include ~xmodmap~ commands in their
  ~.xinitrc~ or ~.Xsession~ file for X windows.

- For boot script:

  #+begin_src shell
    loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz
    or
    install-keymap emacs3
  #+end_src

- For a ~.xinitrc~ or ~.Xsession~ file when the ~Caps Lock~ key is at
  the far left of the home row:

  #+begin_src shell
    # Bind the key labeled 'Caps Lock' to 'Control'
    # (Such as broken user interface suggests that keyboard manufactures
    # think that computers are typewriter from 1885.)

    xmodmap -e "celar Lock"
    xmodmap -e "add Control = Caps_Lock"
  #+end_src

- In a ~.xinitrc~ or ~.Xsession~ file to convert an ~ALT~ key to a
  ~META~ key:

  #+begin_src shell
    # Some ill designed keyboards have a key labeled ALT and no Meta
    xmodmap -e "keysysm Alt_L = Meta_L Alt_L"
  #+end_src

** A Modified Mode Line

- Finally, a feature I really like; a modified mode line.

- When I work over a network, I forget which machine I am using.
  Also, I tend to lose track of where I am, and which line point is
  on.

- So I reset m ode  line to look like this:

  #+begin_src emacs-lsip
    -;-- foo.texi      rattlesnake:/home/bob/    Line 1   (Textinfo fill) Top
  #+end_src

- I am visiting a file called ~foo.texo~, on my machine ~rattelsnake~
  in my ~/home/bob~ buffer.  I am on line ~1~, in Textinfo mode, and I
  am on the top of the buffer.

  #+begin_src emacs-lisp
    ;; Set a mode line that tells me which machine, which directory,
    ;; and which line I am on, plus the other customary information.
    (setq-default mode-line-format
     (quote
      (#("-" 0 1
         (help-echo
          "mouse-1: select window, mouse-2: delete others ..."))
       mode-line-mule-info
       mode-line-modified
       mode-line-frame-identification
       "    "

       mode-line-buffer-identification
       "    "
       (:eval (substring
               (system-name) 0 (string-match "\\..+" (system-name))))
       ":"
       default-directory
       #(" " 0 1
         (help-echo
          "mouse-1: select window, mouse-2: delete others ..."))
       (line-number-mode " Line %l ")
       global-mode-string

       #("   %[(" 0 6
         (help-echo
          "mouse-1: select window, mouse-2: delete others ..."))
       (:eval (format-time-string "%F"))
       mode-line-process
       minor-mode-alist
       #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
       ")%] "
       (-3 . "%P")
       ;;   "-%-"
       )))
    #+end_src

- Here, I redefine the default mode line.  Most of the parts are from
  the original; but I make a few changes.  I set the /default/ mode
  line format so as to permit various modes, such as Info, to override
  it.

- Many elements in the list are self-explanatory: ~mode-line-modified~
  is a variable that tells whether the buffer has been modified,
  ~mode-name~ tells the name of the mode, and so on.  However, the
  format looks complicated because of two features we have not
  discussed.

- The first string in the mode line is a dash or hyphen, '~-~'.  Id
  the old days, it would have been specified simply as "~-~".  But
  nowadays, Emacs can add properties to a string, such as highlighting
  or as in this case, a help feature.  If you place your mouse cursor
  over the hyphen, some help information appears (By default, you must
  wait seven-tenths of a second before the information appears.  You
  can change that timing by changing the value of ~tooltip-delay~.)

- The new strung format has a special syntax:

  #+begin_src emacs-lisp
    #("-" 0 1 (help-echo "mouse-1: select window, ..."))
  #+end_src

- The ~# (~ begins a list.  The first element of the list is the
  string itself, just one '~-~'.  The second and third elements
  specify the range over which the fourth elements applies.  A range
  starts /after/ a character, so a zero means the range stars just
  before the first characters.  The third elements is the property for
  the range.  It consists of a property list, a property name, in this
  case, '~help-echo~', followed by a value, in this case, a string.
  The second, third, and fourth elements of this new string format can
  be repeated.

- See [[][Text Properties]] in The GNU Emacs Lisp Reference Manual,
  and see [[][Mode Line Format]] in The GNU Emacs Lisp Reference
  Manual, for more information.

- ~mode-line-buffer-identification~ displays the current buffer name.
  It is a list beginning ~(#("%12b" 0 4 ...~.  The ~#(~ begins the
  list.

- The ~%12b~ displays the current buffer name, using the ~buffer-name~
  function with which we are familiar: the '~12~ specifies the maximum
  number of characters that will be displayed.  When a name has fewer
  characters, whitespace is added to fill out to this number.  (Buffer
  names can and often should be longer than 12 characters; this length
  work well in a typical 80 characters column wide window.)

- ~:eval~ says to evaluate the following form and use the result as a
  string to display.  In this case, the expression displays the first
  component of the full system name.  The end of the first components
  is a '~.~' (period), so I use the ~string-match~ function to tell me
  the length of the first component.  The substring from the zeroth
  character to that length is the name of the machine.

- This is the expression:

  #+begin_src emacs-lisp
    (:eval (subtring
            (system-name) 0 (string-match "\\..+" (system-name))))
  #+end_src

- '~%[~' and '~%]~' cause a pair of square brackets to appear for each
  recursive editing level.  '~%n~' says "Narrow" when narrowing is in
  effect.  '~%P~' tells you the percentage of the buffer that is above
  the bottom of the window, or "Top". "Bottom", or "All".  ( A lower
  case '~p~' tell you the percentage above the /top/ of the window.)
  '~%-~ inserts enough dashes to fill out the line.

- Remember, you don't have to like Emacs to like it--your own Emacs
  can have different colors, different commands, and different keys
  than a default Emacs.

- On the other hand, if you want to bring up a plain out-of-the-box
  Emacs, with no customization, type:

  #+begin_src shell
    emacs -q
  #+end_src

- This will start an Emacs that does /not/ load your ~~/.emacs~
  initialization file.  A plain, default Emacs.  Nothing more.


* Debugging

- GNU Emacs has two debugger, ~debug~ and ~edebug~.  The first is
  built into the internals of Emacs and is always with you; the second
  requires that you instrument a function before you can use it.

- Both debuggers are described extensively in [[][Debugging Lisp
  Programs]] in the GNU Emacs Lisp Reference Manual.  In this chapter,
  I will walk through a short example of each.

  - [[~debug~][debug]]                                          How to use the built-in debugger
  - [[~debug-on-entry~][debug-on-entry]]                        Start debugging when you call a function
  - [[The ~edebug~ Source Level Debugger][debug-on-quit]]       Start debugging when you quit with ~c-g~
  - [[The ~edebug~ Source Level Debugger][edebug]]              How to use Edebug, a source level debugger.

** ~debug~
- Suppose you have written a function definition that is intended to
  return the sum of the numbers I through a given number.  (This is
  the ~triangle~ function discussed earlier.  See [[]Example with
  Decrementing Counter]], for a discussion.)

- However, your function definition has a bug.  You have mistyped
  '~1=~' for '~1-~'.  Here is the broken definition:

  #+begin_src emacs-lisp
    (defun triangle-bugged (number)
      "Return sum of numbers 1 through NUMBER inclusive."
      (let ((total 0))
        (while (> number 0)
          (setq total (+ total number))
          (setq number (1= number)))              ;; Error here
        total))
  #+end_src

- If you are reading this in Info, you can evaluate this definition in
  the normal fashion.  You will see ~triangle-bugged~ appear in the
  echo area.

- Now evaluate the ~triangle-bugged~ function with an argument of 4:

  #+begin_src emacs-lisp
    (triangle-bugged 4)
  #+end_src

- In a recent GNU Emacs, you will create and enter a ~*Backtrace*~
  buffer that says:

  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
    Debugger entered--Lisp error: (void-function 1=)
     (1= number)
     (setq number (1= number))
     (while (> number 0) (setq total (+ total number)) (setq number (1= number)))
     (let ((total 0)) (while (> number 0) (setq total (+ total number)) (setq number (1= number))) total)
     triangle-bugged(4)
     eval((triangle-bugged 4) nil)
     elisp--eval-last-sexp(nil)
     eval-last-sexp(nil)
     funcall-interactively(eval-last-sexp nil)
     call-interactively(eval-last-sexp nil nil)
     command-execute(eval-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
  #+end_src

- (I have reformatted this example slightly; the debugger does not
  fold long lines.  As usual, you can quit the debugger by typing ~q~
  in the ~*Bakctrace*~ buffer.)

- In practice, for a bug as simple as this, the Lisp error line will
  tell you what you need to know to correct the definition.  The
  function ~1=~ is void.

- However, suppose you are not quite certain what is going on? You can
  read the complete backtrace.

- In this case, you need to run a recent GNU Emacs, which
  automatically starts the debugger that puts you in the ~*Backtrace*~
  buffer; or else, you need to start the debugger manually as
  described below.

- Read the ~*Backtrace*~ buffer from the bottom up; it tells you what
  Emacs did that led the error.  Emacs made an interactive call to
  ~C-x C-e~ (~eval-last-sexp~), which led to the evaluation of the
  ~triangle-bugged~ expression.  Each line above tells you what the
  Lisp interpreter evaluated next.

- The third line from the top of the buffer is

  #+begin_src emacs-lisp
    (setq number (1= number))
  #+end_src

- Emacs tried to evaluate this expression; in order to do so, it tried
  to evaluate the inner expression shown on the second line from the
  top:

  #+begin_src emacs-lisp
    (1= number)
  #+end_src

- This is where the error occurred; as the top line says:

  #+begin_src emacs-lisp
    Debugger entered--Lisp error: (void function 1=)
  #+end_src

** ~debug-on-entry~

- A recent GNU Emacs starts the debugger automatically when your
  function has an error.

- Incidentally, you can start the debugger manually for all version of
  Emacs; the advantage is that the debugger runs even if you do not
  have a bug in your code. Sometimes your code will be free of bugs!.

- You can enter the debugger when you call the function by calling
  ~debug-on-entry~

- Type:

  #+begin_src emacs-lisp
    M-x debug-on-entry RET triangle-bugged RET
  #+end_src

- Now, evaluate the following:

  #+begin_src emacs-lisp
    (triangle-bugged 5)
  #+end_src

- all versions of Emacs will create a ~*Backtrace*~ buffer and tell
  you that it is beginning to evaluate the ~triangle-bugged~ function:

  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
    Debugger entered--entering a function:
    * triangle-bugged(5)
      eval((triangle-bugged 5) nil)
      elisp--eval-last-sexp(nil)
      eval-last-sexp(nil)
      funcall-interactively(eval-last-sexp nil)
      call-interactively(eval-last-sexp nil nil)
      command-execute(eval-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
  #+end_src

- In the ~*Backtrace*~ buffer, type ~d~. Emacs will evaluate the first
  expression in ~triangle-bugged~; the buffer will look like this:

  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
    Debugger entered--entering a function:
     * apply((lambda (number) "Return sum of numbers 1 through NUMBER inclusive."
             (let ((total 0)) (while (> number 0) (setq total ...))
     * triangle-bugged(5)
      eval((triangle-bugged 5) nil)
      elisp--eval-last-sexp(nil)
      eval-last-sexp(nil)
      funcall-interactively(eval-last-sexp nil)
      call-interactively(eval-last-sexp nil nil)
      command-execute(eval-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
  #+end_src

- Now, type ~d~ again, eight times, slowly.  Each time you type ~d~,
  Emacs will evaluate another expression in the function definition.

- Eventually, the buffer will look like this:

  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
    Debugger entered--returning value: 5
      +(0 5)
     * (setq total (+ total number))
     * (while (> number 0) (setq total (+ total number)) (setq number (1= number)))
     * (let ((total 0)) (while (> number 0) ... )
     * (lambda (number) "Return sum of numbers 1 through NUMBER inclusive." (let ((total 0)) ...)
     * apply((lambda (number) "Return sum of numbers 1 through NUMBER inclusive." (let ((total 0)) ...)
     * triangle-bugged(5)
      eval((triangle-bugged 5) nil)
      elisp--eval-last-sexp(nil)
      eval-last-sexp(nil)
      funcall-interactively(eval-last-sexp nil)
      call-interactively(eval-last-sexp nil nil)
      command-execute(eval-last-sexp)
    * ---------- Buffer: *Backtrace* ----------
  #+end_src

- Finally, after you type ~d~ two more times, Emacs will reach the
  error, and the top two lines of the ~*Backtrace*~ buffer will look
  like this:

  #+begin_src emacs-lisp
    * ---------- Buffer: *Backtrace* ----------
    Debugger entered--Lisp error: (void-function 1=)
     * (1= number)
     * (setq number (1= number))
     ...
    * ---------- Buffer: *Backtrace* ----------
  #+end_src

- By typing ~d~, you were able to step through the function.

- You can quit ~*Backtrace*~ buffer by typing ~q~ in it; this quits
  the trace; but does not cancel ~debug-on-entry~.

- To cancel the effect of ~debug-on-entry~, call
  ~cancel-debug-on-entry~ and the name of the function like this:

  #+begin_src emacs-lisp
    M-x cancel-debug-on-entry RET triangle-bugged RET
  #+end_src

** The ~edebug~ Source Level Debugger

- Edebug is a source level debugger.  Edebug normally displays the
  source of code you are debugging, with an arrow at the left that
  shows which line you are currently executing.

- You can walk through the execution of a function, line by line, or
  run quickly until reaching a /breakpoint/ where execution stops.

- Edebug is described in [[][Edebug]] in The GNU Emacs Lisp Reference
  Manual.

- Here is a bugged function definition for ~triangle-recursively~.
  See [[Recursion in place of a counter]], for a review of it.

  #+begin_src emacs-lisp
    (defun triangle-recursively-bugged (number)
      "Return sum of numbers 1 through NUMBER inclusive.
      Use recursion."

      (if (= number 1)
          1
        (+ number
           (triangle-recursively-bugged
            (1= number)))))             ;; Error here
  #+end_src

- Normally, you would install this definition by positioning your
  cursor after the function's closing parenthesis and typing ~C-x C-e~
  (~eval-last-sexp~) or else by positioning your cursor within the
  definition and typing ~C-M-x~ (~eval-defun~).  (By default, the
  ~eval-defun~ command works only in Emacs Lisp Mode or in Lisp
  interaction mode.)

- However, to prepare this function definition for Edebug, you must
  first /instrument/ the code using a different command.  You can do
  this by positioning your cursor within or just after the definition
  and typing:

  #+begin_src emacs-lisp
    M-x edebug-defun RET
  #+end_src

- This will cause Emacs to load Edebug automatically if it is not
  loaded, and properly instrument the function.

- After instrumenting the function, place your cursor after the
  following expression and type ~C-x C-e~ (-eval-last-sexp~):

  #+begin_src emacs-lisp
    (triangle-recursively-bugged 3)
  #+end_src

- You will be jumped back to the source code for
  ~triangle-recursively-bugged~ and the cursor positioned at the
  beginning of the ~if~ line of the function.  Also, you will see an
  arrowhead at the left hand side of that line.  The arrowhead marks
  the line where the function is executing.  (In the following
  examples, we show the arrowhead '~=>~', in a windowing system, you
  may see the arrowhead as a solid triangle in the window fringe.

  #+begin_src emacs-lisp
    =>*(if (= number 1)
  #+end_src

- In the example, the location of point is displayed as '~*~' (in a
  printed book, it displayed with a five pointed star.)

- If you now press ~SPC~, point will move to the next expression to be
  executed; the line will look like this:

  #+begin_src emacs-lisp
    Result: 3 (#o3, #x3, ?\C-c)
  #+end_src

- You can continue moving through the code until you reach the line
  with the error.  Before evaluation, that lines looks like this:

  #+begin_src emacs-lisp
    =>          *(1= number)))))         ; Error here.
  #+end_src

- When you press ~SPC~ once again, you will produce an error message
  that says:

  #+begin_src emacs-lisp
    Symbol's function definition is void: 1=
  #+end_src

- This is the bug,

- Press ~q~ to quit Edebug.

- To remove instrumentation from a function definition, simply
  re-evaluate it with a command that does not instrument it.  For
  example, you could place your cursor after the definition's closing
  parenthesis and type ~C-x C-e~.

- Edebug does a great deal more than walk with you through a function.
  You can set it to it races through on its own, stopping only at an
  error at specified stopping points; you can cause it to display the
  changing values of various expressions; you can find out how many
  times a function is called, and more.

- Edebug is described in ~[[][Edebug]] in The GNU Emacs Lisp Reference
  Manual.
